<!doctype html><html lang=zh dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="
  Cross-Stage Prediction
  #


  congestion
  #


  background
  #



Routing congestion can overwhelm routing resources and lead to low cell utilization and routing detours


congestion is not known accurately until late in the design cycle, after placement and routing.


Many modern placement and synthesis tools leverage congestion estimation in their cost analysis in order to minimize the effects of congestion in the final physical design



  


It is known that the total net length can be a good proxy for congestion"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://pxgh02.github.io/zh/docs/Digtal/Digtal/flow/EDA4PR-Digtal/"><meta property="og:site_name" content="Pxmmmm"><meta property="og:title" content="EDA4PR-Digtal"><meta property="og:description" content="Cross-Stage Prediction # congestion # background # Routing congestion can overwhelm routing resources and lead to low cell utilization and routing detours
congestion is not known accurately until late in the design cycle, after placement and routing.
Many modern placement and synthesis tools leverage congestion estimation in their cost analysis in order to minimize the effects of congestion in the final physical design
It is known that the total net length can be a good proxy for congestion"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2025-02-26T11:34:54+00:00"><title>EDA4PR-Digtal | Pxmmmm</title>
<link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://pxgh02.github.io/zh/docs/Digtal/Digtal/flow/EDA4PR-Digtal/><link rel=stylesheet href=/book.min.6c8b9d2a1fc95075ed7da46ca81060b39add8fff6741ac51259f768929281e2c.css integrity="sha256-bIudKh/JUHXtfaRsqBBgs5rdj/9nQaxRJZ92iSkoHiw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/zh.search.min.8eafbac7697c4856301cceaa115ee72ef60019c2c45132b637d7543a267762ca.js integrity="sha256-jq+6x2l8SFYwHM6qEV7nLvYAGcLEUTK2N9dUOiZ3Yso=" crossorigin=anonymous></script><script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/zh/><span>Pxmmmm</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=搜索 aria-label=搜索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul class=book-languages><li><input type=checkbox id=languages class=toggle>
<label for=languages class="flex justify-between"><a role=button class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
Chinese</a></label><ul><li><a href=/>English</a></li></ul></li></ul><ul><li><input type=checkbox id=section-a7a8fb3cc34544172ff5103ce3adf7cc class=toggle>
<label for=section-a7a8fb3cc34544172ff5103ce3adf7cc class="flex justify-between"><a href=/zh/docs/Other/>Other</a></label><ul><li><input type=checkbox id=section-0f93294ac0398c75569110d47f22a323 class=toggle>
<label for=section-0f93294ac0398c75569110d47f22a323 class="flex justify-between"><a href=/zh/docs/Other/Other/>Other</a></label><ul><li><a href=/zh/docs/Other/Other/Algorithms/>Algorithms</a></li><li><a href=/zh/docs/Other/Other/Hardware/>Hardware</a></li><li><a href=/zh/docs/Other/Other/linux/>Linux</a></li><li><a href=/zh/docs/Other/Other/Literature/>Literature</a></li><li><a href=/zh/docs/Other/Other/network/>Network</a></li><li><a href=/zh/docs/Other/Other/Program/>Program</a></li><li><a href=/zh/docs/Other/Other/software/>Software</a></li><li><a href=/zh/docs/Other/Other/Tools/>Tools</a></li><li><a href=/zh/docs/Other/Other/window/>Window</a></li></ul></li><li><a href=/zh/docs/Other/Algorithms/>Algorithms</a></li><li><a href=/zh/docs/Other/git/>Git</a></li><li><a href=/zh/docs/Other/Hardware/>Hardware</a></li><li><a href=/zh/docs/Other/linux/>Linux</a></li><li><a href=/zh/docs/Other/Literature/>Literature</a></li><li><a href=/zh/docs/Other/makefile/>Makefile</a></li><li><a href=/zh/docs/Other/network/>Network</a></li><li><a href=/zh/docs/Other/Program/>Program</a></li><li><a href=/zh/docs/Other/Tools/>Tools</a></li><li><a href=/zh/docs/Other/window/>Window</a></li><li><a href=/zh/docs/Other/Writing-PPT-Presentation/>Writing Ppt Presentation</a></li></ul></li><li><input type=checkbox id=section-546194909198d851b05dc5d16088b0b9 class=toggle checked>
<label for=section-546194909198d851b05dc5d16088b0b9 class="flex justify-between"><a href=/zh/docs/Digtal/>Physical Design</a></label><ul><li><input type=checkbox id=section-50bd8d8e06f01bc507cff9ec875d9670 class=toggle checked>
<label for=section-50bd8d8e06f01bc507cff9ec875d9670 class="flex justify-between"><a href=/zh/docs/Digtal/Digtal/>Physical Design</a></label><ul><li><input type=checkbox id=section-eb886ad00a6041494cd8a2d37b9502c1 class=toggle>
<label for=section-eb886ad00a6041494cd8a2d37b9502c1 class="flex justify-between"><a href=/zh/docs/Digtal/Digtal/flow/EDA4PR/>EDA4PR</a></label></li><li><input type=checkbox id=section-56ecf627e9a5b7dcba2f2eeea116f5c8 class=toggle checked>
<label for=section-56ecf627e9a5b7dcba2f2eeea116f5c8 class="flex justify-between"><a href=/zh/docs/Digtal/Digtal/flow/EDA4PR-Digtal/ class=active>EDA4PR-Digtal</a></label></li><li><input type=checkbox id=section-531f953e4132641abe87a288f8c87537 class=toggle>
<label for=section-531f953e4132641abe87a288f8c87537 class="flex justify-between"><a href=/zh/docs/Digtal/Digtal/flow/flow/>Flow</a></label></li><li><input type=checkbox id=section-dd416fec3c1dfa9abc7052d958fac1fb class=toggle>
<label for=section-dd416fec3c1dfa9abc7052d958fac1fb class="flex justify-between"><a href=/zh/docs/Digtal/Digtal/Placement/placement/>Placement</a></label></li><li><input type=checkbox id=section-edb5a12c4e85a0cb8ad856bb96d3a791 class=toggle>
<label for=section-edb5a12c4e85a0cb8ad856bb96d3a791 class="flex justify-between"><a href=/zh/docs/Digtal/Digtal/Routing/routing2/>Routing</a></label></li><li><input type=checkbox id=section-85e7c64a7f59a04958f475e43f62710b class=toggle>
<label for=section-85e7c64a7f59a04958f475e43f62710b class="flex justify-between"><a href=/zh/docs/Digtal/Digtal/Routing/routing1/>Routing1</a></label></li></ul></li><li><input type=checkbox id=section-9bc128912acae8559e0b27b496b7779b class=toggle>
<label for=section-9bc128912acae8559e0b27b496b7779b class="flex justify-between"><a href=/zh/docs/Digtal/flow/EDA4PR/>EDA4PR</a></label></li><li><input type=checkbox id=section-50846ac4cdec99c8bd1f8b0417acad9a class=toggle>
<label for=section-50846ac4cdec99c8bd1f8b0417acad9a class="flex justify-between"><a href=/zh/docs/Digtal/flow/flow/>Flow</a></label></li><li><input type=checkbox id=section-b2241e4da59f24976e354abe344e8d4f class=toggle>
<label for=section-b2241e4da59f24976e354abe344e8d4f class="flex justify-between"><a href=/zh/docs/Digtal/Placement/placement/>Placement</a></label></li><li><input type=checkbox id=section-259735f9bf2708d778569b162c141df5 class=toggle>
<label for=section-259735f9bf2708d778569b162c141df5 class="flex justify-between"><a href=/zh/docs/Digtal/Routing/routing2/>Routing</a></label></li><li><input type=checkbox id=section-78b8f069c0c130e55062b802fff78361 class=toggle>
<label for=section-78b8f069c0c130e55062b802fff78361 class="flex justify-between"><a href=/zh/docs/Digtal/Routing/routing1/>Routing1</a></label></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>EDA4PR-Digtal</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#cross-stage-prediction>Cross-Stage Prediction</a><ul><li><a href=#congestion>congestion</a><ul><li><a href=#background>background</a></li><li><a href=#routenet-drc-hotspot-prediction-iccad-2018-cnn><a href=https://zhiyaoxie.com/files/ICCAD18_RouteNet.pdf>RouteNet-DRC Hotspot Prediction-ICCAD-2018-CNN</a></a></li><li><a href=#congestionnet-predict-congestion-hotspots-ifip-2019-gnngat-nvidia><a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=8920342&amp;tag=1">CongestionNet-predict congestion hotspots-IFIP-2019-GNN(GAT)-nvidia</a></a></li><li><a href=#-congestion-prediction--embedding--matrix-factorization--partition-arxiv-2021-gnnsage-><a href>-Congestion prediction + embedding + matrix factorization + partition-arXiv-2021-GNN(Sage)-</a></a></li><li><a href=#pgnn-drvs-predictionpin-proximity-graph-iccad-2022-gnnunetcnn-korea><a href>PGNN-DRVs prediction+Pin Proximity Graph-ICCAD-2022-GNN+UNet(CNN)-Korea</a></a></li><li><a href=#lhnn-congestionprediction-dac-2022-gnn-cuhkhuaweiyibolin><a href>LHNN-CongestionPrediction-DAC-2022-GNN-CUHK+Huawei+YiboLin</a></a></li><li><a href=#-nn-robustness-improve-arxiv-2024---uc-><a href>-NN Robustness improve-arXiv-2024- -UC-</a></a></li></ul></li><li><a href=#timing>Timing</a><ul><li><a href=#background-6>background</a></li><li><a href=#timinggcn-sta-prediction-dac-2022-gnn><a href=https://dl.acm.org/doi/abs/10.1145/3489517.3530597>TimingGCN-STA prediction-DAC-2022-GNN</a></a></li><li><a href=#multimodal-fusion-restructure-tolerantcnnendpoint-wise-masking4layout--dac-2023-gnncnn-7nm-riscvdmynotesedatimingmultimodal-fusion-pre-route-timing-prediction-dac-2023-gnn-7nm-riscvpdf>[Multimodal Fusion-Restructure tolerant+CNN+Endpoint-wise Masking4Layout -DAC-2023-GNN+CNN-7nm RISCV](D:\MyNotes\EDA\Timing\Multimodal Fusion-Pre Route Timing Prediction-DAC-2023-GNN-7nm RISCV.pdf)</a></li></ul></li></ul></li><li><a href=#optimization>Optimization</a><ul><li><a href=#timing-1>Timing</a><ul><li><a href=#tsteiner---steiner-points-opt-dac-2023-gnn-cuhk><a href>TSteiner - Steiner Points Opt-DAC-2023-GNN-CUHK</a></a></li></ul></li><li><a href=#placement>Placement</a><ul><li><a href=#-pin-accessibilitydrv-prediction-dac-2019-cnn-ntu><a href>-Pin Accessibility+DRV prediction-DAC-2019-CNN-NTU</a></a></li><li><a href=#-pin-accessibilityactiv-ispd-2020---ntusynopsys><a href=https://pdfs.semanticscholar.org/47f1/5e9fa283faddb8a6853398145d33e2ba9ae1.pdf>-Pin Accessibility+activ-ISPD-2020- -NTU+Synopsys</a></a></li><li><a href=#placement-optimization-with-deep-reinforcement-learning---ispd-2020-rlgnn-google><a href=%5Bdl.acm.org/doi/pdf/10.1145/3372780.3378174%5D(https://dl.acm.org/doi/pdf/10.1145/3372780.3378174)>Placement Optimization with Deep Reinforcement Learning- -ISPD-2020-RL+GNN-Google</a></a></li><li><a href=#pl-gnn-affinity-aware-for-icc2--ispd-2021-gnn-atlanta><a href=https://dl.acm.org/doi/pdf/10.1145/3439706.3447045>PL GNN-Affinity Aware for ICC2- ISPD-2021-GNN-Atlanta</a></a></li><li><a href=#-innovus-ppa-placement-optimize-neurips-2021-rl><a href=https://www.semanticscholar.org/paper/A-General-Framework-For-VLSI-Tool-Parameter-with-Agnesina-Pentapati/30c644ffa213418182e795ea5e8132cb15e891c2>-Innovus PPA placement optimize-Neurips-2021-RL</a></a></li><li><a href=#-gp-routability-opt-dac-2021-fcn-cuhksitingliu-beiyuyibo-lin><a href>-GP Routability Opt-DAC-2021-FCN-CUHK(SitingLiu BeiYu)+Yibo Lin</a></a></li></ul></li><li><a href=#gr>GR</a><ul><li><a href=#pros-routability-optimization-iccad-2020-fcn-cnhkcadence><a href>PROS-Routability Optimization-ICCAD-2020-FCN-CNHK+Cadence</a></a></li><li><a href=#pros-20---routability-optroute-wl-estimation-trans-2023-cnn-cnhkcadence><a href>PROS 2.0 - Routability Opt+Route WL estimation-Trans-2023-CNN-CNHK+Cadence</a></a></li><li><a href=#dr>DR</a></li><li><a href=#-detailed-router-date-2021-rl><a href=https://ieeexplore.ieee.org/document/9474007>-Detailed Router-DATE-2021-RL</a></a></li><li><a href=#dprouter-detail-routingpackage-design-optnet-order-decision-aspadc-2023-rlmarl-diagonally-routedmynotesedaroutingdprouter-detail-routingpackage-design-optnet-order-decision-aspadc-2023-rlmarl-diagonally-routepdf>[DPRouter-Detail Routing(package design) Opt+net order decision-ASPADC-2023-RL(MARL)-diagonally route](&ldquo;D:\MyNotes\EDA\Routing\DPRouter-Detail Routing(package design) Opt+net order decision-ASPADC-2023-RL(MARL)-diagonally route.pdf&rdquo;)</a></li><li><a href=#-detail-routingmatchopt-ispd-2023-rlgnn-finfet><a href>-Detail routing+match+Opt-ISPD-2023-RL+GNN-FinFET</a></a></li></ul></li></ul></li><li><a href=#pr-tools>PR Tools</a><ul><li><a href=#placer>Placer</a><ul><li><a href=#chip-placement-with-deep-reinforcement-learning-marcro-arxiv-2020-rl><a href=https://arxiv.org/pdf/2004.10746>Chip Placement with Deep Reinforcement Learning-marcro-arXiv-2020-RL</a></a></li><li><a href=#differentiable-timing-driven-global-placement-global-placement-dac-2022-gnn-><a href=https://dl.acm.org/doi/pdf/10.1145/3489517.3530486>Differentiable-Timing-Driven Global Placement-global placement-DAC-2022-GNN-</a></a></li><li><a href=#polar-20><a href=https://ieeexplore.ieee.org/document/6881450>Polar 2.0</a></a></li><li><a href=#deepplace><a href=https://github.com/PKUterran/DeepPlace>DeepPlace</a></a></li><li><a href=#replace><a href=https://ieeexplore.ieee.org/abstract/document/8418790>RePlAce&ndash;TCAD-2018-</a></a></li><li><a href=#dreamplace-gp-dactcadiccaddate-2019><a href=https://github.com/limbo018/DREAMPlace>DREAMPlace-GP-DAC+TCAD+ICCAD+DATE-2019~2023</a></a></li></ul></li><li><a href=#gr_outdated>GR_outdated</a><ul><li><a href=#fastroute102006><a href>FastRoute1.0—2006</a></a></li><li><a href=#fastroute-20-monotonic2007><a href>fastroute 2.0-Monotonic–2007</a></a></li><li><a href=#fastroute-30-virtual-capacity-iccad-2008-><a href>fastroute 3.0-virtual capacity-ICCAD-2008-</a></a></li><li><a href=#fastroute-40-via-min-tree3-bending-aspdac-2009-><a href>fastroute 4.0-via min tree+3 bending-ASPDAC-2009-</a></a></li><li><a href=#maizerouter-><a href>MaizeRouter-</a></a></li><li><a href=#boxrouter-10><a href>BoxRouter 1.0</a></a></li><li><a href=#fgr-3d-tcad-2008-><a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=4526750">FGR-3d-TCAD-2008-</a></a></li><li><a href=#-layer-assignmentvia-minization-trans-2008-dp-nthu><a href=https://ieeexplore-ieee-org-443.webvpn.scut.edu.cn/document/4603083>-Layer assignment+Via minization-Trans-2008-DP-NTHU</a></a></li><li><a href=#grip-3dip-dac-2009><a href=https://dl.acm.org/doi/pdf/10.1145/1629911.1629999>GRIP-3d+IP-DAC-2009</a></a></li><li><a href=#fastroute41-an-efficient-and-high-quality-global-router-2012><a href=https://home.engineering.iastate.edu/~cnchu/pubs/j52.pdf>FastRoute4.1-an efficient and high-quality global router-2012</a></a></li><li><a href=#nthu-route-10---tvlsi-2010-><a href=https://ieeexplore.ieee.org/document/5703167>NTHU Route 1.0- -TVLSI-2010-</a></a></li><li><a href=#nthu-route-20---tcad-2013><a href=https://ieeexplore.ieee.org/document/6504553>NTHU Route 2.0- -TCAD-2013</a></a></li><li><a href=#nctu-gr-10-3d-congestion-relaxed-layer-assignment--2011-><a href=https://ieeexplore.ieee.org/document/5703167>NCTU GR 1.0-3D-congestion relaxed layer assignment- 2011-</a></a></li><li><a href=#nctu-gr-20-multithreaded-collision-aware--cad-2013-><a href=https://ieeexplore.ieee.org/document/6504553>NCTU GR 2.0-Multithreaded Collision Aware- CAD-2013-</a></a></li><li><a href=#boxrouter-20><a href>BoxRouter 2.0</a></a></li><li><a href=#ogre--new-cost-function---2019---><a href=https://woset-workshop.github.io/PDFs/2019/a18.pdf>OGRE- new cost function- -2019- -</a></a></li><li><a href=#sproute-10-a-scalable-parallel-negotiation-based-global-router-iccad-2019><a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=8942105">SPRoute 1.0: A Scalable Parallel Negotiation-based Global Router-ICCAD-2019</a></a></li></ul></li><li><a href=#gr_adv_rl>GR_Adv_RL</a><ul><li><a href=#-drl-method-2019-drl-><a href=https://arxiv.org/pdf/1906.08809>-DRL method-2019-DRL-</a></a></li><li><a href=#-drl-arxiv-2021-jp><a href=https://arxiv.org/pdf/2010.09465>-DRL-arxiv-2021-JP</a></a></li><li><a href=#---wcmc-2023-drl-fuzhouu-genggeng-liu><a href=https://onlinelibrary.wiley.com/doi/epdf/10.1155/2023/6593938>- -WCMC-2023-DRL-FuZhouU-Genggeng Liu</a></a></li><li><a href=#-drlsegment-based-iseda-2023-drlgnn-pek><a href=https://ieeexplore.ieee.org/abstract/document/10218371>-DRL+segment based-ISEDA-2023-DRL+GNN-PEK</a></a></li><li><a href=#---apccas-2024-drlddqn-cycu><a href="https://ieeexplore-ieee-org-443.webvpn.scut.edu.cn/stamp/stamp.jsp?tp=&amp;arnumber=10808325">- -APCCAS-2024-DRL(DDQN)-CYCU</a></a></li></ul></li><li><a href=#gr_adv_gen>GR_Adv_Gen</a><ul><li><a href=#-generative-arxiv-2019-cnn-><a href=https://arxiv.org/pdf/1706.08948>-generative-arXiv-2019-CNN-</a></a></li><li><a href=#-only-cnn-dac-2020-cnnvae-><a href="https://ieeexplore-ieee-org-443.webvpn.scut.edu.cn/stamp/stamp.jsp?tp=&amp;arnumber=9218598">-only CNN-DAC-2020-CNN(VAE)-</a></a></li><li><a href=#prnet---neurips-2022---sjtunoahs-ark><a href>PRNet- -NeurIPS-2022- -SJTU+Noah’s Ark</a></a></li><li><a href=#hubrouter-generative-model-neurips-2023-ganrl-sjtu><a href>HubRouter-generative model-NeurIPS-2023-GAN+RL-SJTU</a></a></li></ul></li><li><a href=#gr_adv_parallel>GR_Adv_Parallel</a><ul><li><a href=#han-gpunetlevel-parallelism-iccad-2011---><a href>han-GPU+netlevel parallelism-ICCAD-2011- -</a></a></li><li><a href=#vfgr-congestion-modeling-aspdac-2014><a href="https://ieeexplore-ieee-org-443.webvpn.scut.edu.cn/stamp/stamp.jsp?tp=&amp;arnumber=6742945">VFGR-congestion modeling-ASPDAC-2014&ndash;THU</a></a></li><li><a href=#cugr-3d-patternmulti-level-maze-routingpatching-dac-2020-cuhk><a href=https://github.com/cuhk-eda/cu-gr>CUGR-3D pattern+Multi level maze routing+patching-DAC-2020-CUHK</a></a></li><li><a href=#sproute-20--detailed-routability-driven-asp-dac-2022-><a href=https://ieeexplore.ieee.org/abstract/document/9712557>SPRoute 2.0- detailed routability driven-ASP DAC-2022-</a></a></li><li><a href=#fastgr-gpu-pattern-routing-multi-thread-mazedate-2022-pkucuhkhnal><a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=9774606">FastGR-GPU pattern routing+ multi thread maze–DATE-2022-PKU+CUHK+HNAL</a></a></li><li><a href=#gamer---trans-2022---><a href>Gamer- -Trans-2022- -</a></a></li><li><a href=#ggr-super-fast-gpu-accelerate-iccad-2022-><a href=https://github.com/cuhk-eda/Xplace/tree/main/cpp_to_py/gpugr>GGR-super fast gpu accelerate-ICCAD-2022-</a></a></li><li><a href=#cugr-20-dag-based-dac-2023---cuhk><a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=10247702">CUGR 2.0-DAG-based-DAC-2023- -CUHK</a></a></li><li><a href=#instantgr-scalable-gpu-parallelization-iccad-2024-cuhk><a href=https://shijulin.github.io/files/1239_Final_Manuscript.pdf>InstantGR-Scalable GPU Parallelization-ICCAD-2024-CUHK</a></a></li><li><a href=#helem-gr-heterogeneouslinearized-exponential-multiplier-method-iccad-2024---pek><a href>HeLEM-GR-Heterogeneous+Linearized Exponential Multiplier Method-ICCAD-2024- -PEK</a></a></li></ul></li><li><a href=#rsmt>RSMT</a><ul><li><a href=#flute-----2008---><a href>FLUTE- - -2008- -</a></a></li><li><a href=#-obstacle-avoiding-iscas-2024><a href="https://ieeexplore-ieee-org-443.webvpn.scut.edu.cn/stamp/stamp.jsp?tp=&amp;arnumber=10558430">-Obstacle avoiding-ISCAS-2024&ndash;SYSU</a></a></li><li><a href=#-gpu-accelerated-iccad-2022><a href="https://ieeexplore-ieee-org-443.webvpn.scut.edu.cn/stamp/stamp.jsp?tp=&amp;arnumber=10069158">-GPU-Accelerated-ICCAD-2022&ndash;PEK</a></a></li></ul></li><li><a href=#dr-outdated>DR outdated</a><ul><li><a href=#drcu><a href>DRCU</a></a></li></ul></li><li><a href=#dr-adv>DR adv</a></li></ul></li><li><a href=#toread>toread</a><ul><li><ul><li><a href=#dgr---dac-2024><a href=https://dl-acm-org-443.webvpn.scut.edu.cn/doi/pdf/10.1145/3649329.3656530>DGR- -DAC-2024&ndash;CMU+NVIDA</a></a></li><li><a href=#a_><a href="https://ieeexplore-ieee-org-443.webvpn.scut.edu.cn/stamp/stamp.jsp?tp=&amp;arnumber=9835675">A_Simple_Fast_and_GPU-friendly_Steiner-Tree_Heuristic</a></a></li><li><a href=#timing-driven-routing-iccad-2023-ustc><a href="https://ieeexplore-ieee-org-443.webvpn.scut.edu.cn/stamp/stamp.jsp?tp=&amp;arnumber=10323981">Timing-Driven Routing-ICCAD-2023-USTC</a></a></li><li><a href=#timing-iccad-2024_><a href=......%5CDownload%5CTIMING_ICCAD2024_Guo.pdf>TIMING-ICCAD-2024_Guo</a></a></li><li><a href=#gpu-accelerated_><a href="https://ieeexplore-ieee-org-443.webvpn.scut.edu.cn/stamp/stamp.jsp?tp=&amp;arnumber=9256516">GPU-Accelerated_Static_Timing_Analysis</a></a></li></ul></li></ul></li><li><a href=#综述>综述</a><ul><li><a href=#ml4pr>ML4PR</a></li><li><a href=#超大规模集成电路布线算法综述>超大规模集成电路布线算法综述</a><ul><li></li></ul></li><li><a href=#edagnn>EDA+GNN</a></li></ul></li><li><a href=#参考>参考</a></li><li><a href=#bak>bak</a><ul><li><ul><li></li></ul></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=cross-stage-prediction>Cross-Stage Prediction
<a class=anchor href=#cross-stage-prediction>#</a></h1><h2 id=congestion>congestion
<a class=anchor href=#congestion>#</a></h2><h3 id=background>background
<a class=anchor href=#background>#</a></h3><ul><li><p>Routing congestion can overwhelm routing resources and lead to low cell utilization and routing detours</p></li><li><p>congestion is not known accurately until late in the design cycle, after placement and routing.</p></li><li><p>Many modern placement and synthesis tools leverage congestion estimation in their cost analysis in order to minimize the effects of congestion in the final physical design</p></li><li><p><img src=/image-20241101193119582.png alt=image-20241101193119582></p></li><li><p>It is known that the total net length can be a good proxy for congestion</p></li><li><p>A simple approximation for congestion prediction is to use the size of the local neighborhood</p></li><li><p><img src=/image-20241102170308031.png alt=image-20241102170308031></p></li><li><p>和fan-in, fan-out强相关</p></li><li><p>Precise congestion prediction from a placement solution plays a crucial role in circuit placement</p></li><li><p>Multiple <strong>previous works</strong> have attempted to predict detailed routing congestion in the <strong>placement step</strong> in an effort to optimize routability of the placement solution: RUDY, POLAR 2.0. All these techniques are implemented in the placement step and need the position information of cells .</p></li><li><p>To avoid the high computation cost of placement, it is more useful to be able to predict congestion in the logic synthesis phase.</p></li><li><p>congestion prediction problem can be frame as <strong>node regression problem</strong></p></li><li><p>with the growth of circuit scale and complexity, time consumption
tends to be unacceptable when utilizing a <strong>global router</strong> in the placement cycle to obtain the <strong>congestion map</strong>.</p></li><li><p>Current machine learning models commonly follow a two-phase workflow. First, based on domain knowledge, human experts generate various local features on the circuit using predefined functions on netlist. Then, based on the generated features, a specific model, e.g. convolution neural network (CNN) model is designed to predict either the routing demand map or the congestion map</p></li><li><p>the emergence of <strong>Graph Neural Network (GNN)</strong> triggered applications of undirected homogeneous graphs models on routing congestion prediction, since a VLSI circuit can be naturally represented by a graph</p></li><li></li></ul><h3 id=routenet-drc-hotspot-prediction-iccad-2018-cnn><a href=https://zhiyaoxie.com/files/ICCAD18_RouteNet.pdf>RouteNet-DRC Hotspot Prediction-ICCAD-2018-CNN</a>
<a class=anchor href=#routenet-drc-hotspot-prediction-iccad-2018-cnn>#</a></h3><h4 id=background-1>background
<a class=anchor href=#background-1>#</a></h4><ul><li><p>Every chip design project must complete routing <strong>without design rule violation</strong> before tapeout. However, this basic requirement is often difficult to be satisfied especially when routability is not adequately considered in early design stages.</p></li><li><p>In light of this fact, routability prediction has received serious attention in both academic research and industrial tool development. Moreover, routability is widely recognized as a main objective for <strong>cell placement</strong></p></li><li><p>CNN and Transfer Learning</p><ul><li>CNN learns more abstract patterns from images</li><li>Our RouteNet transfers such state-of-the-art ability in image pattern recognition to circuits for capturing the patterns about routability. RouteNet predicts routability based on a pretrained ResNet architecture</li><li>Fully Convolutional Network (FCN): outputs an image with size equal to or smaller than input. many FCNs have both deep and shallow paths in one network.</li></ul></li><li><p>RUDY(Rectangular Uniform wire DensitY)</p><ul><li>它被用作我们RouteNet的输入特征，因为它与路由拥塞部分相关，获取速度快，可以直接表示为与RouteNet相吻合的图像</li></ul></li><li><p>challenge of macros</p><p><img src=/image-20250205214716706.png alt=image-20250205214716706></p><ul><li>The orange circles in Figure 3 indicate a strong tendency for hotspots to aggregate at the small gap between neighboring macros</li><li>Blue dashed circles indicate the remaining sparsely distributed hotspots</li><li><img src=/image-20250205220737891.png alt=image-20250205220737891></li><li>有macro，线性程度低</li></ul></li></ul><h4 id=task>task
<a class=anchor href=#task>#</a></h4><ul><li>predict overall routability (DRC count), 分类任务，预测总的#DRV</li><li>predict <code>DRC hotspot</code> locations.DRC hotspots mean the specific locations with high density of DRVs. like an end-to-end object detection task, which is more difficult to solve. GCell内#DRV超过设定值则为<code>DRC hotspot</code></li></ul><h4 id=contribution>contribution:
<a class=anchor href=#contribution>#</a></h4><p><img src=/image-20250205210214325.png alt=image-20250205210214325></p><ul><li>mixed-size macros</li><li>first systematic study on CNN-based routability prediction</li><li>high accuracy and high speed</li><li></li></ul><h4 id=flow>flow
<a class=anchor href=#flow>#</a></h4><p><img src=/image-20250205222502598.png alt=image-20250205222502598></p><h4 id=model>model
<a class=anchor href=#model>#</a></h4><ul><li><p>#DRV prediction</p><p>ResNet18-based</p><p><img src=/image-20250205223554347.png alt=image-20250205223554347></p><p>preprocess</p><ul><li><p><img src=/image-20250205223153166.png alt=image-20250205223153166></p></li><li><p><img src=/image-20250205223742770.png alt=image-20250205223742770></p><p>ResNet是一个固定输入（224*224）的模型，为了使用知识迁移，将输入
<img src=/image-20250205223907748.png alt=image-20250205223849469>。具体怎么插？</p></li></ul></li><li><p>hotspot prediction</p></li></ul><p><img src=/image-20250205224325007.png alt=image-20250205224325007></p><h4 id=data>data
<a class=anchor href=#data>#</a></h4><p>dataset:</p><p>ISPD 2015 benchmarks</p><p><img src=/image-20250205225007139.png alt=image-20250205225007139></p><p>different placement made by “obstacle-aware macro placement" algorithm [5].</p><p>each floorplan is placed and routed by Cadence Encounter v14.20 [2]</p><h4 id=experiment>experiment
<a class=anchor href=#experiment>#</a></h4><p><img src=/image-20250205230614878.png alt=image-20250205230614878></p><p><img src=/image-20250205230628088.png alt=image-20250205230628088></p><p><img src=/image-20250205230725019.png alt=image-20250205230725019></p><p>we compare the TPR of all methods under the same FPR (error under 1%)</p><p><img src=/image-20250205230816030.png alt=image-20250205230816030></p><h3 id=congestionnet-predict-congestion-hotspots-ifip-2019-gnngat-nvidia><a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=8920342&amp;tag=1">CongestionNet-predict congestion hotspots-IFIP-2019-GNN(GAT)-nvidia</a>
<a class=anchor href=#congestionnet-predict-congestion-hotspots-ifip-2019-gnngat-nvidia>#</a></h3><p>a <strong>graph</strong>-based deep learning method for predicting <strong>routing congestion hotspots</strong> from a <strong>netlist</strong> before placement. Predict the detail routed <strong>lower metal layer</strong> congestion values</p><p><img src=/image-20241101192745004.png alt=image-20241101192745004></p><p>why low layer? 因为较低金属层上的拥塞主要是由局部逻辑结构驱动的，而不是由无关逻辑簇之间的较长互连驱动的，后者往往在较高金属层上运行. predicting lower metal layer congestion is not only more important for the underlying task of identifying congested logic structures, but also simplifies the task for our
graph based network</p><h4 id=contribution-1>contribution
<a class=anchor href=#contribution-1>#</a></h4><ul><li>阶段早,只使用网表</li><li>由于该模型仅基于网表的逻辑结构而不是任何特定的单元布局进行预测，因此它消除了基于布局的方法中存在的次优布局的伪影
<img src=/image-20241101192504194.png alt=image-20241101192504194></li><li>can be done without any physical information</li><li>GNN, 快</li><li>the first work exploring the use of graph based deep learning for physical design problems</li></ul><p><strong>数据:</strong></p><p><img src=/image-20241101194746768.png alt=image-20241101194746768></p><p><img src=/image-20241101195219055.png alt=image-20241101195219055></p><p>roughly 5000 distinct cell types</p><p>we project our per cell predictions back onto their respective 2D grid (using the <strong>final ground truth physical placement</strong>) and average all cells within each grid cell to come up with a predicted value that can be compared to the original ground truth grid value.</p><p><strong>模型参数:</strong></p><p>an 8 layer Graph Attention Network (GAT) with size 16 intermediate (or hidden) state</p><p>无向图, each node corresponds to a cell</p><p>节点特征: length 50 for each <strong>cell type</strong> and each cell’s <strong>logic description</strong> as well as the <strong>pin count</strong> and <strong>cell size</strong> of that cell</p><p><strong>实验:</strong></p><p>report correlation values using the <strong>Kendall ranking coefficient</strong></p><p>实际效果可视化</p><p><img src=/image-20241101211844804.png alt=image-20241101211844804></p><p><img src=/image-20241007114109425.png alt=image-20241007114109425></p><p>对比实验</p><p><img src=/image-20241101214611345.png alt=image-20241101214611345></p><p>消融实验</p><p><img src=/image-20241101214630174.png alt=image-20241101214630174></p><p>cell type or function is an essential part of our predictions.</p><p>cell type 不是没起作用吗</p><p><strong>缺点:</strong></p><ul><li>model needs to be <strong>retrained</strong> for every <strong>new process technology</strong>, since the embeddings are over cell types specific to a process technology.</li><li>it occasionally over predicts congestion in areas of <strong>low to moderate</strong> congestion, such as in most failing parts of Partition A</li><li>due to the <strong>graph based</strong> nature of the model, it sometimes makes <strong>overly soft decision</strong> boundaries</li><li><img src=/image-20241102170708557.png alt=image-20241102170708557></li><li>the CongestionNet uses informative cell attributes (cell size and pin count) alone as the input to the GAT and does not use any embedding encoding the netlist structure</li></ul><p><strong>可改进的点:</strong></p><p><img src=/image-20241101215450089.png alt=image-20241101215450089></p><h3 id=-congestion-prediction--embedding--matrix-factorization--partition-arxiv-2021-gnnsage-><a href=/zh/>-Congestion prediction + embedding + matrix factorization + partition-arXiv-2021-GNN(Sage)-</a>
<a class=anchor href=#-congestion-prediction--embedding--matrix-factorization--partition-arxiv-2021-gnnsage->#</a></h3><h4 id=background-2>background
<a class=anchor href=#background-2>#</a></h4><ul><li>predicting cell congestion due to improper logic combination can reduce the burden of subsequent physical implementations.</li><li>previous work: require informative cell features</li><li>Although the global routing result provides a good estimation of routing congestion [6], [19], an awareness of high congestion areas at an <strong>early</strong> design stage is of great importance to provide fast feedback and shorten design cycles</li><li>Multiple works have attempted to predict detailed <strong>routing congestion</strong> in the placement step in an effort to optimize <strong>routability</strong> of the placement solution</li><li></li></ul><h4 id=task-1>task
<a class=anchor href=#task-1>#</a></h4><p><img src=/image-20241102170157570.png alt=image-20241102170157570></p><ul><li><p>during the logic synthesis stage</p></li><li><p><img src=/image-20241102185917955.png alt=image-20241102185917955></p><p>到底是什么时候的congestion数据? Routing后的真实值还是预测plcament后的congestion RUDY预测值? 应该是<strong>Global Routing</strong>后的:强调了congestion value = wiring demand/routing capacity</p><p><img src=/image-20241102190757814.png alt=image-20241102190757814></p></li></ul><p><strong>contrbution</strong></p><h4 id=data-1>data
<a class=anchor href=#data-1>#</a></h4><p>DAC2012 contest benchmark</p><p><a href=http://archive.sigda.org/dac2012/contest/dac2012_contest.html>http://archive.sigda.org/dac2012/contest/dac2012_contest.html</a></p><p><img src=/image-20241102185210635.png alt=image-20241102185210635></p><p>OpenROAD dataset</p><p><img src=/image-20241102185314200.png alt=image-20241102185314200></p><ul><li><p>place via <strong>DREAMPLACE</strong></p></li><li><p><img src=/image-20241102185814366.png alt=image-20241102185814366></p></li><li><p>Macros and terminals are removed from the graph</p></li><li><p>Nets with degree more than 10 are excluded from the final graph as they introduce cliques too large to work with efficiently.</p></li><li><p>node features (pin number, cell size) , This follows the flow of CongestionNet</p></li><li><p><img src=/image-20241102190725383.png alt=image-20241102190725383></p></li><li><h4 id=flow-1>flow
<a class=anchor href=#flow-1>#</a></h4><p><img src=/image-20241102193019887.png alt=image-20241102193019887></p></li><li><p>congestion value for each grid cell computed as the wiring demand divided by the routing capacity , The output along the z-axis is reduced by a max function,</p></li><li><p>Our focus is on predicting congestion due to local logic structure, which manifests itself on lower metal layers. Therefore, we use congestion labels from the lower half of the metal layers to train and evaluate the model</p></li><li><p>推理的时候取所有cell的预测平均值</p></li></ul><p><strong>principle</strong></p><ul><li><p>提出相连越近的节点相似度越高,</p></li><li><p>提出structural node similarity</p><p><img src=/image-20241102182916257.png alt=image-20241102182916257></p></li><li><p>Sub-graph partition ? METIS? ClusterGCN?</p></li><li><p>Matrix Factorization ?</p></li></ul><h4 id=model-1>model
<a class=anchor href=#model-1>#</a></h4><ul><li><p>The key <strong>difference</strong> between this approach and <strong>CongestionNet</strong> lies in <strong>embedding</strong> pipeline</p></li><li><p>graph is undirected complete circuit is too <strong>large</strong> for direct matrix factorization and must be <strong>partitioned</strong> into clusters, use <strong>METIS</strong> partitioning tool in <strong>ClusterGCN</strong></p></li><li><p>Sub-graph partition: clusters of ≈ 5000 nodes each</p></li><li><p>Matrix Factorization ?</p></li><li></li></ul><h4 id=experiment-1>experiment
<a class=anchor href=#experiment-1>#</a></h4><p>three metrics of correlation to measure performance: <strong>Pearson, Spearman, Kendall</strong></p><p>Before evaluation, both the prediction and the label have some (very low) <strong>noise</strong> added to them.</p><p><img src=/image-20241102204924004.png alt=image-20241102204924004></p><p><img src=/image-20241102204932495.png alt=image-20241102204932495></p><p><img src=/image-20241102204956720.png alt=image-20241102204956720></p><p><img src=/image-20241102205029766.png alt=image-20241102205029766></p><h3 id=pgnn-drvs-predictionpin-proximity-graph-iccad-2022-gnnunetcnn-korea><a href=/zh/>PGNN-DRVs prediction+Pin Proximity Graph-ICCAD-2022-GNN+UNet(CNN)-Korea</a>
<a class=anchor href=#pgnn-drvs-predictionpin-proximity-graph-iccad-2022-gnnunetcnn-korea>#</a></h3><h4 id=background-3>background
<a class=anchor href=#background-3>#</a></h4><ul><li><p>(1) pin accessibility and (2) routing congestion are two major causes of DRVs (design rule violations)</p></li><li><p>Particularly, the complex design rules put so much burden on physical design, demanding lots of iterations on the time-consuming process of cell placement and net routing to <strong>clean up all DRVs (design rule violations)</strong> before tapping out . Thus, at the placement stage, if we were able to identify, with high confidence, DRC (design rule check) hotspots that would be
likely to occur at the routing stage, we can pay more attention</p></li><li><p>shortcoming of <strong>image based</strong>:</p><p>local pin accessibility cannot be accurately modeled by pin pattern <strong>image</strong> alone</p><p>using high-resolution pin pattern images incur significant additional <strong>run-time</strong> as well as <strong>memory</strong> overhead to the prediction models</p></li><li><p>to optimize the placement before routing.</p></li></ul><h4 id=task-2>task
<a class=anchor href=#task-2>#</a></h4><p>a novel ML based DRC hotspot prediction technique,</p><ul><li>GNN is used to embed pin accessibility information, <strong>U-net</strong> is used to extract routing congestion information from grid-based
features</li><li><img src=/image-20241108113804178.png alt=image-20241108113804178></li><li><img src=/image-20241108100942346.png alt=image-20241108100942346></li><li>placement 分割为grid, 长宽=G-Cell</li><li>DRVs are extracted as the ground-truth after <strong>detailed routing</strong></li></ul><h4 id=contribution-2>contribution
<a class=anchor href=#contribution-2>#</a></h4><ul><li>GNN model, base pin proximity graph</li><li></li></ul><h4 id=model-2>model
<a class=anchor href=#model-2>#</a></h4><p>PGNN can adopt pin proximity graph as well as grid-based feature map as input feature</p><p>Pin Proximity Graph :</p><ul><li>无向图， 同构图</li></ul><p><img src=/image-20241108105308585.png alt=image-20241108105308585></p><p><img src=/image-20241108105400483.png alt=image-20241108105400483></p><p>U-Net:</p><p><img src=/image-20241108100615500.png alt=image-20241108100615500></p><p>featrue:</p><p><img src=/image-20241108111019050.png alt=image-20241108111019050></p><p><img src=/image-20241108111430728.png alt=image-20241108111430728></p><p>整体模型:</p><p><img src=/image-20241108110729825.png alt=image-20241108110729825></p><p><strong>数据集</strong>:</p><p><img src=/image-20241108111933323.png alt=image-20241108111933323></p><p>以后也可以这么做, 同一个benchmark不同的config参数就有不同的数据</p><h4 id=experiment-2>experiment
<a class=anchor href=#experiment-2>#</a></h4><p>Nangate 15nm library</p><p>9 groups are used for training and the remaining 1 group for test. K折验证</p><p><img src=/image-20241108112502662.png alt=image-20241108112502662></p><p>positive 和 negative是什么意思?</p><p>可视化:</p><p><img src=/image-20241108102857037.png alt=image-20241108102857037></p><p>消融实验:</p><p><img src=/image-20241108112646099.png alt=image-20241108112646099></p><p>以后也可以这样用特征消融?</p><p>对比实验(F1-score):</p><p><img src=/image-20241108112751008.png alt=image-20241108112751008></p><p><img src=/image-20241108114209199.png alt=image-20241108114209199></p><ul><li><p>注意不需要GR!</p></li><li><p><strong>GR-Cong</strong> is obtained from ICC2 after global routing stage, and grids with high routing congestion are classified as DRC hotspot. 商用</p></li><li><p>RouteNet和J-Net都是相关的学术工作</p></li></ul><p>时间对比:</p><p><img src=/image-20241108114501484.png alt=image-20241108114501484></p><h3 id=lhnn-congestionprediction-dac-2022-gnn-cuhkhuaweiyibolin><a href=/zh/>LHNN-CongestionPrediction-DAC-2022-GNN-CUHK+Huawei+YiboLin</a>
<a class=anchor href=#lhnn-congestionprediction-dac-2022-gnn-cuhkhuaweiyibolin>#</a></h3><h4 id=background-4>background
<a class=anchor href=#background-4>#</a></h4><ul><li>图的节点的设置很新颖</li><li>with the growth of circuit scale and complexity, time consumption
tends to be unacceptable when utilizing a <strong>global router</strong> in the placement cycle to obtain the <strong>congestion map</strong>.</li><li>due to the need for the <strong>&ldquo;shift-left&rdquo;</strong> in circuit design, researchers begin to seek alternative solutions in machine learning [4] [5] to achieve accurate and fast congestion map prediction</li></ul><h4 id=task-3>task
<a class=anchor href=#task-3>#</a></h4><ul><li>two related tasks, <strong>routing demand regression</strong> and <strong>congestion classification</strong></li></ul><h4 id=data-2>data
<a class=anchor href=#data-2>#</a></h4><p>regard each <strong>G-cell</strong> <strong>as a node</strong> and add an edge between two nodes if the respective two G-cells are adjacent.</p><p><strong>hypergraphs and heterogeneous graph</strong> , 两种节点：G-cell和G-net</p><p><img src=/image-20241108141650136.png alt=image-20241108141650136></p><p><img src=/image-20241108142449292.png alt=image-20241108142449292></p><ul><li><p>feature：</p><p><img src=/image-20241108142931213.png alt=image-20241108142931213></p></li></ul><p><img src=/image-20241108145640376.png alt=image-20241108145640376></p><p>ISPD 2011 [16] and DAC 2012 [17] contest benchmarks ,</p><h4 id=model-3>model
<a class=anchor href=#model-3>#</a></h4><p><img src=/image-20241219145252874.png alt=image-20241219145252874></p><p><img src=/image-20241108144617443.png alt=image-20241108144617443></p><p>他这里说congestion map是一个二值化(0/1?)的数据集， 所以是分类任务, 但是为了利用数据，同时防止routing demand的信息丢失， 还设置了一个预测routing demand的任务？</p><h4 id=experiment-3>experiment
<a class=anchor href=#experiment-3>#</a></h4><p>15benchmarks: 10 for training and 5 for testing</p><p>run <strong>DREAMPlace</strong> [18] on each of the designs to generate placement solutions</p><p><strong>NCTU-GR 2.0</strong> [2] to attain horizontal/vertical <strong>routing demand maps</strong> , and set the <strong>congestion maps</strong> as a <strong>binary</strong> indicator according to whether the horizontal/vertical routing demand of the G-cell <strong>exceeds the circuit’s capacity</strong></p><p><img src=/image-20241108150810402.png alt=image-20241108150810402></p><p><img src=/image-20241108150803029.png alt=image-20241108150803029></p><p><img src=/image-20241108150837509.png alt=image-20241108150837509></p><p>对比实验：</p><p><img src=/image-20241108151611413.png alt=image-20241108151611413></p><p><img src=/image-20241108151757751.png alt=image-20241108151757751></p><p>可视化：</p><p><img src=/image-20241108150918563.png alt=image-20241108150918563></p><p>消融实验：</p><p><img src=/image-20241108152104185.png alt=image-20241108152104185></p><h3 id=-nn-robustness-improve-arxiv-2024---uc-><a href=/zh/>-NN Robustness improve-arXiv-2024- -UC-</a>
<a class=anchor href=#-nn-robustness-improve-arxiv-2024---uc->#</a></h3><h4 id=background-5>background
<a class=anchor href=#background-5>#</a></h4><ul><li>最近的工作已经证明神经网络通常是容易受到精心选择的输入小扰动的影响</li><li>Our definition of <strong>imperceptibility</strong> is characterized by a guarantee that a perturbation to a layout will not alter its global routing</li><li>recent work [10, 18] has demonstrated that image classifiers can be <strong>fooled</strong> by <strong>small, carefully chosen</strong> perturbations of their input</li><li><img src=/image-20250102215202387.png alt=image-20250102215202387></li></ul><h4 id=task-4>task
<a class=anchor href=#task-4>#</a></h4><ul><li>design two efficient methods for finding perturbations that demonstrate brittleness of recently proposed congestion predictors</li><li>one potential approach to address the issues by modifying the training procedure to promote robustness</li></ul><h4 id=contribution-3>contribution
<a class=anchor href=#contribution-3>#</a></h4><p><a href=https://ieeexplore.ieee.org/document/8807040>Painting on PIacement-predict the routing congestion-ACM-2019-GAN-</a></p><p><img src=/image-20241012153331855.png alt=image-20241012153331855></p><p><img src=/image-20241012153541960.png alt=image-20241012153541960></p><p><a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=9401274">-DRC Hotspot Prediction-ISCAS-2021-CNN</a></p><p><a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=9045178">-Routing Congestion Prediction-ASPDAC-2020-GAN</a></p><ul><li>slice
<a href=https://yibolin.com/publications/papers/FPGA_ASPDAC2020_Alawieh.slides.pdf>FPGACong_ASPDAC20 (yibolin.com)</a></li></ul><p><a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=8715126">-predict #DRV, a macro placer-DATE-2019-CNN</a></p><h2 id=timing>Timing
<a class=anchor href=#timing>#</a></h2><h3 id=background-6>background
<a class=anchor href=#background-6>#</a></h3><p><img src=/image-20241026164128136.png alt=image-20241026164128136></p><h3 id=timinggcn-sta-prediction-dac-2022-gnn><a href=https://dl.acm.org/doi/abs/10.1145/3489517.3530597>TimingGCN-STA prediction-DAC-2022-GNN</a>
<a class=anchor href=#timinggcn-sta-prediction-dac-2022-gnn>#</a></h3><ul><li>the first work！</li><li>opensource</li><li>still relies on local net/cell delay prediction as auxiliary tasks</li><li>no optimization, not fit the real-world scenario where timing <strong>optimization</strong> is taken into account</li></ul><p><a href=https://github.com/Thinklab-SJTU/EDA-AI/tree/main/PreRoutGNN>PreRoutGNN-STA prediction-AAAI-2024-GNN</a></p><ul><li>opensource</li></ul><h3 id=multimodal-fusion-restructure-tolerantcnnendpoint-wise-masking4layout--dac-2023-gnncnn-7nm-riscvdmynotesedatimingmultimodal-fusion-pre-route-timing-prediction-dac-2023-gnn-7nm-riscvpdf>[Multimodal Fusion-Restructure tolerant+CNN+Endpoint-wise Masking4Layout -DAC-2023-GNN+CNN-7nm RISCV](D:\MyNotes\EDA\Timing\Multimodal Fusion-Pre Route Timing Prediction-DAC-2023-GNN-7nm RISCV.pdf)
<a class=anchor href=#multimodal-fusion-restructure-tolerantcnnendpoint-wise-masking4layout--dac-2023-gnncnn-7nm-riscvdmynotesedatimingmultimodal-fusion-pre-route-timing-prediction-dac-2023-gnn-7nm-riscvpdf>#</a></h3><p><a href=https://www.cse.cuhk.edu.hk/~byu/papers/C167-DAC2023-PathPred-poster.pdf>slice</a></p><ul><li><p>Restructure：预测终点的延时，但是Timing Opt会改变网表结构(end point不变）。对一个Pre-routing任务来说，输入的网表和最终的网表不一样</p></li><li><p>netlist <strong>restructuring</strong> causes a mismatch between local input features and ground-truth features in the restructured sub-regions</p><p><img src=/image-20241026173420844.png alt=image-20241026173420844></p><p>As a result, prior local-view models can only be trained on the unchanged regions in a <strong>semi-supervised manner</strong>.</p><p>In other words, the better the models fit on labeled (unreplaced) net/cell delays, the worse they fit on replaced regions and eventually on endpoint arrival time</p></li><li><p>数据集：基本信息和Timing优化导致的网表变化</p><ul><li>average 40% nets and 21% cells are replaced during timing optimization</li><li>timing optimization brings an average change of 59.6% to net delays
and 33.3% to cell delays</li></ul><p><img src=/image-20241026170120254.png alt=image-20241026170120254></p></li><li><p>为什么用layout信息：Since most timing optimization techniques include gate insertion or gate sizing, placement should reserve space for subsequent timing
optimization. In other words, the timing optimizer’s efficacy is tied closely to global layout information. The layout information plays a dominant role in determining the timing optimizer’s impact since most optimization
techniques need space to be applied</p></li><li><p>整体模型</p><p><img src=/image-20241026184138343.png alt=image-20241026184138343></p><p>组成：<strong>GNN+CNN+Endpoint-wise Masking</strong></p><ul><li>Netlist(GNN):</li></ul><p><img src=/image-20241026184646854.png alt=image-20241026184646854></p><p>和
<a href=https://dl.acm.org/doi/abs/10.1145/3489517.3530597>TimingGCN-STA prediction-DAC-2022-GNN</a>很像(没发现不同)</p><ul><li><p>Layout(CNN+Endpoint-wise Masking)</p><p><img src=/image-20241026185621311.png alt=image-20241026185621311></p><p><img src=/image-20241026193815323.png alt=image-20241026193815323></p><p>三个特征：cell density, rectangular uniform wire density (RUDY), and macro cells region</p><p><img src=/image-20241026190115449.png alt=image-20241026190115449></p><p><strong>Endpoint-wise Masking</strong></p><p><img src=/image-20241026194544366.png alt=image-20241026194544366></p></li></ul></li><li><p>对比实验：</p><p><img src=/image-20241026200330616.png alt=image-20241026200330616></p><p><img src=/image-20241026200838620.png alt=image-20241026200838620></p></li><li><p>run time实验</p><p><img src=/image-20241026201203648.png alt=image-20241026201203648></p></li></ul><h4 id=other>other
<a class=anchor href=#other>#</a></h4><p><a href=file:///D:/MyNotes/EDA/Timing/aheadRCnetwork.pdf>Ahead RC network-STA prediction-DAC-2022-?</a></p><p><a href=https://ieeexplore.ieee.org/document/9643435>Doomed Run Prediction-TNS prediction-ACM-2021-GNN+RNN</a></p><p><img src=/image-20241007121002859.png alt=image-20241007121002859></p><h4 id=not-dl>not DL
<a class=anchor href=#not-dl>#</a></h4><p><img src=/image-20241026164603048.png alt=image-20241026164603048>The two-stage approaches [2], [3] first predict localnet/cell delays and then apply PERT traversals [5] to evaluate the global timing metrics, i.e., endpoint arrival time.</p><h1 id=optimization>Optimization
<a class=anchor href=#optimization>#</a></h1><h2 id=timing-1>Timing
<a class=anchor href=#timing-1>#</a></h2><h3 id=tsteiner---steiner-points-opt-dac-2023-gnn-cuhk><a href=/zh/>TSteiner - Steiner Points Opt-DAC-2023-GNN-CUHK</a>
<a class=anchor href=#tsteiner---steiner-points-opt-dac-2023-gnn-cuhk>#</a></h3><h4 id=background-7>background
<a class=anchor href=#background-7>#</a></h4><p>对于multi-pin net需要构建steiner tree来进行routing，故steiner tree中steiner points也会影响routing</p><p>FLUTE[
<a href=https://www.zhihu.com/question/579615273/answer/3154651342#ref_3>3]</a>是常用的生成steiner tree的算法。在生成steiner tree后，我们可以通过近一步优化steiner point来优化timing</p><p><img src=/image-20241102112154369.png alt=image-20241102112154369></p><p>the previous early-stage timing optimization works only focus on improving
early timing metrics. 提出了诸如net加权和可微分时间目标等策略来优化时间, only focus on improving pre-routing timing metrics, which may have a considerable gap to <strong>signoff</strong> timing performance. 斯坦那点更加靠近布线阶段(和布线更加相关)</p><p>all the aforementioned works are not directly targeted at sign-off timing performance due to its high acquisition cost</p><p><strong>任务:</strong></p><p><img src=/image-20241102111709494.png alt=image-20241102111709494></p><p>In this paper, we focus on explicit sign-off timing optimization at the pre-routing stage to reduce the turnaround time</p><p>optimization framework is built to adjust Steiner point positions for better sign-off timing performance iteratively</p><p>The most popular Steiner minimum tree construction algorithms aim to <strong>minimize wirelength</strong>. Moreover, the Steiner point refinement is introduced to update the generated Steiner point positions for specific objectives, e.g., sign-off timing performance, while maintaining the two-pin net connections</p><p><strong>启发:</strong></p><p>we surprisingly find that the signoff timing performance could be significantly affected even by a <strong>random</strong> disturbance on Steiner point positions, as shown in Fig. 2.</p><p><img src=/image-20241102114842155.png alt=image-20241102114842155></p><p>Nevertheless, the impact of random moving is considerately unstable, and its average performance is slight (with a ratio close to 1.0). 所以启发找到一个好的方法来更新斯坦纳点来降低TNS</p><p>在最广泛使用的技术节点中，与<strong>路径长度</strong>最相关的定时度量——净延迟，并不能解释大部分的整体定时性能. 这里用的初始化斯泰纳树的方法的优化目标都是路径长度最短</p><h4 id=contribution-4>contribution:
<a class=anchor href=#contribution-4>#</a></h4><ul><li>first earlystage timing optimization framework via Steiner point refinement</li><li>GNN</li><li>TSteiner framework is fully automated with an adaptive stepsize scheme and the auto-convergence scheme</li><li>improves 11.2% and 7.1% on average (up to 45.8% and 43.9%) for WNS and TNS</li></ul><p><strong>模型:</strong></p><p>Steiner tree construction decomposes each multi-pin net into <strong>a set of two-pin</strong>
<strong>nets</strong> via additional Steiner points before global routing to reduce the problem complexity</p><p>The proposed framework can be divided into two stages, <strong>sign-off timing gradient generation</strong> (Section III-A) and <strong>concurrent Steiner point refinement</strong> (Section III-B)</p><p><img src=/image-20241102123009705.png alt=image-20241102123009705></p><p><img src=/image-20241102115937138.png alt=image-20241102115937138></p><p>和TimingGCN相比就是多了Steiner 节点, 然后吧第一部分的的node embedding部分加上了steiner的部分</p><p><img src=/image-20241102121828217.png alt=image-20241102121828217></p><p>实际是:
<img src=/image-20241102122509138.png alt=image-20241102122509138></p><p><img src=/image-20241102122552273.png alt=image-20241102122552273></p><p>优化的指标, WNS和TNS的加权</p><p>根据优化指标对斯泰纳点坐标参数做梯度下降</p><p><img src=/image-20241102132825834.png alt=image-20241102132825834></p><p><img src=/image-20250102200912287.png alt=image-20250102200912287></p><p>相比简单的梯度下降，只是减小了对不同benchmark的手动学习率微调</p><p><strong>数据</strong></p><p><img src=/image-20241102132430596.png alt=image-20241102132430596></p><p><strong>实验</strong></p><p><img src=/image-20241102132506821.png alt=image-20241102132506821></p><p><img src=/image-20241102132555409.png alt=image-20241102132555409></p><p><img src=/image-20241102132646602.png alt=image-20241102132646602></p><p><img src=/image-20241102132734827.png alt=image-20241102132734827></p><h2 id=placement>Placement
<a class=anchor href=#placement>#</a></h2><h3 id=-pin-accessibilitydrv-prediction-dac-2019-cnn-ntu><a href=/zh/>-Pin Accessibility+DRV prediction-DAC-2019-CNN-NTU</a>
<a class=anchor href=#-pin-accessibilitydrv-prediction-dac-2019-cnn-ntu>#</a></h3><h4 id=background-8>background
<a class=anchor href=#background-8>#</a></h4><ul><li><p>Standard cells on the lower metal layers severely suffer from low routability due to high pin density, low pin accessibility, and limited routing resources.</p></li><li><p><img src=/image-20250206153002501.png alt=image-20250206153002501></p><p>It can be observed that the access points of pin B are blocked by the metal 2 (M2) routing segments routed from Pin A and Pin C, so an M2 short design rule violation (DRV) will be induced when dropping a via12 on Pin B. pin accessibility is not only determined by cell layout design but also strongly affected by adjacent cells</p></li><li><p>对于传统方法，两个缺点：</p><ul><li>Cell libraries provided by foundries should not be considerably redesigned because the optimized cell performance and manufacturability may be highly sensitive to cell layouts</li><li>Deterministic approaches based on <strong>human knowledge have been shown to be less effective in advanced nodes</strong> for optimization problems such as DRV prediction and minimization because of the extremely high complexity through the overall design flow</li></ul></li><li><p><img src=/image-20250206154744610.png alt=image-20250206154744610></p><p>It can be observed that most of the congested regions in the layout do not have DRVs, while some regions with DRVs are not so congested. 但是我感觉还是有相关性的。他是想说明congestion出现的地方不一定有DRV，但是没congestion的地方可能因为poor pin accessibility导致DRV</p></li><li><p><img src=/image-20250206154811206.png alt=image-20250206154811206></p><ul><li>也是说明：congestion出现的地方不一定有DRV，但是没congestion的地方可能因为poor pin accessibility导致DRV</li><li>the two M2 shorts occur at the locations having <strong>the same pin pattern</strong> in the top cell-row and mid cell-row</li></ul></li></ul><h4 id=task-5>task
<a class=anchor href=#task-5>#</a></h4><ul><li><p>DRV prediction, 二分类</p><p><img src=/image-20250206190055066.png alt=image-20250206190055066></p></li><li><p>pin accessibility optimization, 给一个合法化后的布局结构，通过算法进行减少bad pin accessibility的detailed placement</p><p><img src=/image-20250206190225309.png alt=image-20250206190225309></p></li><li><p>其实也是一个预测模型，一个优化模型</p></li></ul><h4 id=contribution-5>contribution
<a class=anchor href=#contribution-5>#</a></h4><ul><li>first work to apply pin pattern as the input features of <code>DRV prediction models</code>.</li><li></li></ul><h4 id=flow-2>flow
<a class=anchor href=#flow-2>#</a></h4><p><img src=/image-20250206191224771.png alt=image-20250206191224771></p><p><strong>model:</strong></p><p>PPR&amp;DFPPR:</p><p><img src=/image-20250206192506245.png alt=image-20250206192506245></p><p>Model-guided Detailed Placement :</p><p><img src=/image-20250206195817013.png alt=image-20250206195817013></p><p><img src=/image-20250206202610856.png alt=image-20250206202610856></p><p>Dynamic Programming-based Placement Blockage Insertion</p><p><img src=/image-20250206202803548.png alt=image-20250206202803548></p><ul><li>还会改方向？</li></ul><p>Cell Displacement Refinement</p><h4 id=data-3>data
<a class=anchor href=#data-3>#</a></h4><p><img src=/image-20250206192552413.png alt=image-20250206192552413></p><p>Both the width and height of each pixel are set as the <strong>minimum spacing of the M1 layer</strong> in order to prevent a pixel from being occupied by two different pins.</p><p>没看见关于benchmark的描述</p><h4 id=experiment-4>experiment
<a class=anchor href=#experiment-4>#</a></h4><p><img src=/image-20250206204743555.png alt=image-20250206204743555></p><p><img src=/image-20250206205223899.png alt=image-20250206205223899></p><p><strong>shortcoming:</strong></p><ul><li>flow need routed designs to train, time</li><li>The trained model is not necessarily applicable to other designs using different cells or different reference cell libraries</li><li>对于VLSI，一行一行，一对一对进行，很慢？</li><li></li></ul><h3 id=-pin-accessibilityactiv-ispd-2020---ntusynopsys><a href=https://pdfs.semanticscholar.org/47f1/5e9fa283faddb8a6853398145d33e2ba9ae1.pdf>-Pin Accessibility+activ-ISPD-2020- -NTU+Synopsys</a>
<a class=anchor href=#-pin-accessibilityactiv-ispd-2020---ntusynopsys>#</a></h3><h4 id=background-9>background
<a class=anchor href=#background-9>#</a></h4><ul><li><p>With the development of advanced process nodes of semiconductor, the problem of<code>pin access</code>has become one of the major factors to impact the occurrences of design rule violations (DRVs) due to complex design rules and limited routing resource</p></li><li><p><code>supervised learning</code> approaches extract the labels of training data by generating a great number of routed designs in advance, giving rise to large effort on training data preparation. the pre-trained model could hardly predict unseen data</p></li><li><p>Unlike most of existing studies that aim at <code>design-specific</code> training, we propose a <code>library-based</code> model which can be applied to all designs referencing to the same standard cell library set.</p></li><li><p>Due to the shrinking of modern process nodes of semiconductor, the <strong>pin access problem</strong> of standard cells has become more harder to be coped with, especially on the <strong>lower metal layers</strong>.</p></li><li><p><img src=/image-20250206150405665.png alt=image-20250206150405665></p><p>在这种placement下，Metal1 pin A/B由于各自左右两边在Metal2有pin，而且只能在黄色track下横向绕线，（Metal1不能绕线？），那么Pin A/B通过Via12后必定会短路</p></li><li><p>19年工作[5]的两个缺点</p><ul><li>flow need routed designs to train, time</li><li>The trained model is not necessarily applicable to other designs using different cells or different reference cell libraries</li></ul></li><li></li></ul><h4 id=contribution-6>contribution
<a class=anchor href=#contribution-6>#</a></h4><ul><li>first work of<code> cell library-based</code>pin accessibility prediction (PAP), which can be applied to predict other designs referencing to the same cell library set</li><li>applies <strong>active learning</strong> to train a PAP model</li><li>the proposed cell library-based PAP model <strong>can be trained at the earlier stage</strong> in a process development flow: once the cell libraries are provided.</li><li></li></ul><h3 id=placement-optimization-with-deep-reinforcement-learning---ispd-2020-rlgnn-google><a href=[dl.acm.org/doi/pdf/10.1145/3372780.3378174]%28https://dl.acm.org/doi/pdf/10.1145/3372780.3378174%29>Placement Optimization with Deep Reinforcement Learning- -ISPD-2020-RL+GNN-Google</a>
<a class=anchor href=#placement-optimization-with-deep-reinforcement-learning---ispd-2020-rlgnn-google>#</a></h3><h3 id=pl-gnn-affinity-aware-for-icc2--ispd-2021-gnn-atlanta><a href=https://dl.acm.org/doi/pdf/10.1145/3439706.3447045>PL GNN-Affinity Aware for ICC2- ISPD-2021-GNN-Atlanta</a>
<a class=anchor href=#pl-gnn-affinity-aware-for-icc2--ispd-2021-gnn-atlanta>#</a></h3><h4 id=background-10>background:
<a class=anchor href=#background-10>#</a></h4><ul><li><p>Placement is one of the most <strong>crucial problems</strong>, placement directly impacts the final quality of a full-chip design</p></li><li><p>multiple placement <strong>iterations</strong> to optimize key metrics(WL, timing), which is <strong>time-consuming</strong> and computationally inefficient, VLSI</p></li><li><p>the<code> logical affinity</code> among design instancesdominates the quality of the placement</p><p><img src=/image-20241224115010379.png alt=image-20241224115010379></p><p><code>logical affinity</code> 源于这篇文章？</p></li><li><p>performing <strong>placement guidance</strong> requires in-depth design-specific knowledge,which is only achievable by <strong>experienced designers</strong> who knows the underlying data flows in Register-Transistor Level (RTL) well</p></li><li><p><img src=/image-20241224114254672.png alt=image-20241224114254672></p></li><li><p>K-means基础：</p><ul><li><p><img src=/image-20241224172053839.png alt=image-20241224172053839></p></li><li><p><img src=/image-20241224172022162.png alt=image-20241224172022162></p></li></ul></li></ul><h4 id=task-6>task
<a class=anchor href=#task-6>#</a></h4><ul><li>基于网表数据，和floorplan结果（marco已经放好）</li><li><code>placement guidance</code>(grouping information) for commercial placers <code>ICC2</code>, by generating <strong>cell clusters</strong> based on <strong>logical affinity</strong> and manually defined attributes of design instances</li><li>our framework will determine the<code> cell clusters</code> in an <strong>unsupervised</strong> manner which serve as placement guidance in order to guide commercial placers to optimize the key metrics such as <strong>wirelength, power, and timing</strong> by placing cells with a common <strong>cluster</strong> together</li></ul><h4 id=flow-3>flow
<a class=anchor href=#flow-3>#</a></h4><p><img src=/image-20241224111801884.png alt=image-20241224111801884></p><p><strong>Two stages:</strong></p><ol><li><p>GNN do unsupervised node representation learning, (it is generalizable to any design)</p></li><li><p><code>weighted K-means clustering algorithm [3]</code> to group instances into different clusters。To find the optimal number of groups for clustering, we introduce the <code>Silhouette score [19]</code> and perform sweeping experiments to find the sweet spot</p><p>K-means算法的基本思想是：通过迭代的方式，将数据划分为<strong>K个不同的簇</strong>，并使得每个数据点与其所属簇的质心（或称为中心点、均值点）之间的<strong>距离之和最小</strong>。</p></li></ol><p><img src=/image-20241007102413593.png alt=image-20241007102413593></p><h4 id=data-4>data
<a class=anchor href=#data-4>#</a></h4><p>two multi-core CPU designs：</p><p><img src=/image-20241224181733657.png alt=image-20241224181733657></p><p><strong>nf</strong></p><ul><li><p><strong>design hierarchy</strong> : 根据网表层级. top/inst1/sky130_INV/A. (同时zero-padding)</p><p><img src=/image-20241224160726962.png alt=image-20241224160726962></p></li><li><p><strong>logical affinity of memory macros</strong> ：logical levels to memory macros 𝑀 as features. because the logic to memory paths are often the critical timing paths</p></li></ul><p><img src=/image-20241224161329678.png alt=image-20241224161329678></p><p><strong>ef:</strong></p><p><img src=/image-20241224171228803.png alt=image-20241224171228803></p><h4 id=model-4>model
<a class=anchor href=#model-4>#</a></h4><ul><li><p>GraphSAGE-based， two layers</p><p><img src=/image-20241224161923488.png alt=image-20241224161923488></p><p><img src=/image-20241224162351812.png alt=image-20241224162351812></p></li><li><p>Loss Function:</p><p><img src=/image-20241224170359079.png alt=image-20241224170359079></p><p><img src=/image-20241224170818328.png alt=image-20241224170818328></p><p><img src=/image-20241224170824860.png alt=image-20241224170824860></p></li></ul><p><strong>Silhouette score</strong></p><p>用于评估分类结果，扫描分类数目，选择最高的分的</p><p><img src=/image-20241224181023453.png alt=image-20241224181002019></p><p><img src=/image-20241224181044251.png alt=image-20241224181044251></p><p><img src=/image-20241224181052309.png alt=image-20241224181052309></p><p><img src=/image-20241224181116187.png alt=image-20241224181116187></p><h4 id=experiment-5>experiment
<a class=anchor href=#experiment-5>#</a></h4><p><strong>env</strong>:</p><ul><li>2.40𝐺𝐻𝑍 CPU</li><li>NVIDIA RTX 2070</li><li>16𝐺𝐵 memory.</li><li>PyTorch Geometric</li></ul><p><strong>setting:</strong></p><ul><li>the placement of memory macros is achieved manually based on design manuals provided by the design-house</li><li>Adam</li></ul><p><strong>result</strong></p><p>Louvain：比较实验对比模型</p><p><img src=/image-20241224181627782.png alt=image-20241224181627782></p><p><strong>Question</strong>:</p><p>benchmark少</p><p>扫描到的就适用所有？</p><p>开环？</p><h3 id=-innovus-ppa-placement-optimize-neurips-2021-rl><a href=https://www.semanticscholar.org/paper/A-General-Framework-For-VLSI-Tool-Parameter-with-Agnesina-Pentapati/30c644ffa213418182e795ea5e8132cb15e891c2>-Innovus PPA placement optimize-Neurips-2021-RL </a><a class=anchor href=#-innovus-ppa-placement-optimize-neurips-2021-rl>#</a></h3><p><img src=/image-20241007103637165.png alt=image-20241007103637165></p><p><img src=/image-20241007105134964.png alt=image-20241007105134964></p><h4 id=contribution-7>contribution:
<a class=anchor href=#contribution-7>#</a></h4><p><img src=/image-20241224114117771.png alt=image-20241224114117771></p><h3 id=-gp-routability-opt-dac-2021-fcn-cuhksitingliu-beiyuyibo-lin><a href=/zh/>-GP Routability Opt-DAC-2021-FCN-CUHK(SitingLiu BeiYu)+Yibo Lin</a>
<a class=anchor href=#-gp-routability-opt-dac-2021-fcn-cuhksitingliu-beiyuyibo-lin>#</a></h3><h4 id=background-11>background
<a class=anchor href=#background-11>#</a></h4><h4 id=flow-4>flow
<a class=anchor href=#flow-4>#</a></h4><p><img src=/image-20241226160945080.png alt=image-20241226160945080></p><ol><li>three input features are extracted from the cell placement solution</li><li>Through the inference of the pre-trained routability prediction model, we get the predicted congestion map.</li><li>take <code>mean squared Frobenius norm</code> of this congestion map as the congestion penalty</li><li></li></ol><p><img src=/image-20241226161200384.png alt=image-20241226161200384></p><h4 id=data-5>data
<a class=anchor href=#data-5>#</a></h4><h4 id=model-5>model
<a class=anchor href=#model-5>#</a></h4><p><img src=/image-20241226161132128.png alt=image-20241226161132128></p><h2 id=gr>GR
<a class=anchor href=#gr>#</a></h2><h3 id=pros-routability-optimization-iccad-2020-fcn-cnhkcadence><a href=/zh/>PROS-Routability Optimization-ICCAD-2020-FCN-CNHK+Cadence</a>
<a class=anchor href=#pros-routability-optimization-iccad-2020-fcn-cnhkcadence>#</a></h3><h4 id=background-12>background
<a class=anchor href=#background-12>#</a></h4><p><img src=/image-20241128091405687.png alt=image-20241128091405687></p><p><img src=/image-20241128091759855.png alt=image-20241128091759855></p><h4 id=task-7>task
<a class=anchor href=#task-7>#</a></h4><ul><li>congestion <strong>predictor</strong> and parameter <strong>optimizer</strong></li><li>only the data from the placement</li><li>it can optimize the cost parameters before the first routing iteration of GR and thus can give a better GR solution with less congestion.</li></ul><h4 id=contribution-8>contribution
<a class=anchor href=#contribution-8>#</a></h4><ul><li>with negligible runtime overhead</li><li>plug-in</li><li>can be embedded into the state-of-the-art commercial EDA tool (Cadence Innovus v20.1)</li></ul><h4 id=model-6>model
<a class=anchor href=#model-6>#</a></h4><p><img src=/image-20241219171627049.png alt=image-20241219171627049></p><h4 id=data-6>data
<a class=anchor href=#data-6>#</a></h4><p>19 different industrial designs</p><p><img src=/image-20241219165446998.png alt=image-20241219165446998></p><p>通过<strong>不同的placement参数和旋转</strong>（CNN原理），一共有1664 design cases in total.</p><p><strong>Feature Extraction</strong></p><ul><li><p>Horizontal/Vertical track capacity map</p></li><li><p>Cell density map</p></li><li><p>Flip-flop cell density map</p></li><li><p>Fixed cell density map</p></li><li><p>Cell pin density map</p></li><li><p>Pin accessibility map</p><p><img src=/image-20241219161307835.png alt=image-20241219161307835></p><ul><li><p>Horizontal/Vertical net density map</p></li><li><p>Small/Large-net RUDY map</p></li></ul><p><img src=/image-20241219161336920.png alt=image-20241219161336920></p></li><li><p>Pin RUDY map</p><p>a combination of cell pin density map and large-net RUDY
map</p></li></ul><p><strong>Label Generation</strong></p><p><img src=/image-20241219162403381.png alt=image-20241219162403381>PROS does not need very detailed congestion map</p><p>two-step smoothening process to convert raw data to desirable congestion labels</p><p>help to make the prediction task easier</p><p>if there are at least six congested G-cells out of the eight in the surrounding of a center G-cell д, д will be labeled as congested</p><p><img src=/image-20241219162837909.png alt=image-20241219162837909></p><p><strong>优化原理</strong></p><p>这两个值在cadence怎么改的? cadence企业内部自己弄的（这是cadence的文章）？</p><p><img src=/image-20241219165904742.png alt=image-20241219165904742></p><p><img src=/image-20241219165912121.png alt=image-20241219165912121></p><h4 id=model-7>model
<a class=anchor href=#model-7>#</a></h4><p><img src=/image-20241219163417043.png alt=image-20241219163417043></p><h4 id=experiment-6>experiment
<a class=anchor href=#experiment-6>#</a></h4><p><img src=/image-20241219172158774.png alt=image-20241219172158774></p><p><img src=/image-20241219172205431.png alt=image-20241219172205431></p><p><img src=/image-20241219172212018.png alt=image-20241219172212018></p><p><img src=/image-20241219172620444.png alt=image-20241219172620444></p><h3 id=pros-20---routability-optroute-wl-estimation-trans-2023-cnn-cnhkcadence><a href=/zh/>PROS 2.0 - Routability Opt+Route WL estimation-Trans-2023-CNN-CNHK+Cadence</a>
<a class=anchor href=#pros-20---routability-optroute-wl-estimation-trans-2023-cnn-cnhkcadence>#</a></h3><h4 id=background-13>background
<a class=anchor href=#background-13>#</a></h4><ul><li>the amount of routing resources on a design is limited.</li><li>The quality of a GR solution has a great impact on that of the resulted DR routing solution</li><li>Congestion in a GR solution is one of the major causes of DRC violations in the DR
solution since most of DRC violations are due to overcrowded wires and vias [1], [2]</li><li>a better GR solution with less congestion is needed to lower the probability of getting DRC violations in advance.</li><li>if the initial GR solution is not good and has a lot of congestion, the GR tool can hardly tackle the problem by rip-up and reroute.</li><li>placement engines <strong>[3]–[5]</strong> which take routing congestion into consideration are applied</li><li>FCN:FCN常用于图像中的每像素分类问题。采用<strong>任意输入大小</strong>，并产生大小完全相同的输出。GR拥塞预测也可以被视为任意大小的芯片设计上的像素二进制分类问题（拥塞与否）。因此，基于FCN的预测器可以自然地应用于PROS。</li></ul><h4 id=task-8>task
<a class=anchor href=#task-8>#</a></h4><ul><li>stage: post-placement, pre-route</li><li>FCN based GR congestion <code>predictor</code>, use the predicted GR congestion to optimize the <strong>cost parameters</strong> of GR.</li><li>predictor based <code>parameter optimizer</code> to generate a better GR solution. GR tools are driven by the cost parameters stored in each G-cell. When arriving at a G-cell g, the tool will compute the cost, called <code>moving cost</code>, to move to each of its neighboring G-cells and push these costs into a heap. With optimized cost parameters in G-cells, the GR tool can find better paths and allocate the routing resources to each net more smartly. PROS optimizes two types of cost parameters <strong>based on the prediction result</strong>, including <code>overflow cost</code> and <code>wire/via cost </code>. PROS will adjust the cost parameters in the projected congestion regions on <strong>all layers</strong><ul><li>overflow cost</li><li>wire/via cost: divided into two groups (small/large) according to their BBox sizes.<ul><li>Increasing the wire/via cost for small nets may be <strong>useless</strong> for congestion reduction and it may even increase the wire length or create new congestion due to detours out of the potential congestion region.</li><li>In contrast, increasing the wire/via cost for large nets can be helpful since
they can select another route within its BBox to completely avoid the potential congestion region</li></ul></li></ul></li><li>CNN based <code>wirelength estimator </code>, By <strong>multiplying</strong> the predicted wirelength ratio and the precomputed <code>FLUTE </code>wirelength (训练一个系数). The lack of consideration of routing congestion in traditional methods is due to the dif ficulty of quickly obtaining accurate congestion estimation at the placement <strong>stage</strong></li></ul><h4 id=contribution-9>contribution
<a class=anchor href=#contribution-9>#</a></h4><ul><li>plug-in for Innovus: it can avoid extra runtime overhead of feature preparation</li><li>industrial design suite</li><li>advanced technology node</li><li>SOTA</li><li>high accuracy</li><li>first work that</li><li>utilizes the information of GR congestion to estimate routed wirelength at the placement stage</li><li>PROS does not change a lot for the original EDA steps</li></ul><p><strong>Overall Flow</strong> :</p><p><img src=/image-20241225231457615.png alt=image-20241225231457615></p><p><img src=/image-20241225231740032.png alt=image-20241225231740032></p><p>分类和回归</p><p><img src=/image-20241225231939553.png alt=image-20241225231939553></p><ul><li>F is the feature number.</li><li>X<del>WL</del> has two features: These two features will be resized to 128 × 128 before prediction<ul><li>the <strong>predicted</strong> congestion map</li><li>the cell pin density map</li></ul></li></ul><h4 id=data-7>data
<a class=anchor href=#data-7>#</a></h4><p>feature F</p><ul><li><p>Horizontal/Vertical Track Capacity Map</p></li><li><p>Cell Density Map</p></li><li><p>Flip-Flop Cell Density Map</p></li><li><p>Fixed Cell Density Map</p></li><li><p>Cell Pin Density Map</p></li><li><p>Pin Accessibility Map</p><p><img src=/image-20241226095003879.png alt=image-20241226095003879></p></li><li><p>Horizontal/Vertical Net Density Map</p><p><img src=/image-20241226095234394.png alt=image-20241226095234394></p></li><li><p>Small/Large-Net RUDY Map</p><p><img src=/image-20241226095702886.png alt=image-20241226095702886></p></li><li><p>Pin RUDY Map ?</p></li></ul><p><strong>label</strong></p><p><strong>congestion label pre-process</strong></p><p>PROS does not need a very detailed congestion map</p><p><img src=/image-20241226100513980.png alt=image-20241226100513980></p><p>最后还是为了优化服务的</p><h4 id=model-8>model
<a class=anchor href=#model-8>#</a></h4><p><img src=/image-20241226133238155.png alt=image-20241226133238155></p><ul><li>DC: get more local information, but more GPU usage(acceptable)</li><li>SUB: w*h*4c –>2w*2h*c.<ul><li>Compared with bilinear upsampling which is not trainable, subpixel upsampling can learn to recover the local information.</li><li>Compared with deconvolution, subpixel upsampling is parameter free, so
it will not significantly increase the training difficulty.</li></ul></li></ul><p><img src=/image-20241226133719030.png alt=image-20241226133719030></p><p><strong>dataset</strong></p><p>industrial benchmark suite and DAC-2012 benchmark suite(19个 benchmark)</p><p>industrial benchmark suite 通过11种不同布局参数，翻转和旋转，制造了一共有1664个(约等于19*11*8)benchmark</p><p>DAC-2012 20 different placements</p><p>(4, 4, 4, 4, 3) 5折交叉验证</p><p><img src=/image-20241226134314062.png alt=image-20241226134314062></p><p><img src=/image-20241226134322968.png alt=image-20241226134322968></p><h4 id=experiment-7>experiment
<a class=anchor href=#experiment-7>#</a></h4><p><strong>env</strong></p><ul><li>Tensorflow</li><li>Intel Xeon CPUs at 2.2 GHz</li><li>256 GB memory</li><li>NVIDIA TITAN V GPU</li></ul><p><strong>setting</strong></p><ul><li><p>Adam</p></li><li><p>One entire training process of the congestion predictor has 25 training epochs! 这么少（收敛好快）</p><p><img src=/image-20241226135108986.png alt=image-20241226135108986></p></li></ul><p><strong>congestion classification prediction</strong></p><p><img src=/image-20241226135344696.png alt=image-20241226135344696></p><p><img src=/image-20241226135500109.png alt=image-20241226135500109></p><p>compare with PROBABILISTIC METHODS</p><p><img src=/image-20241226135607227.png alt=image-20241226135607227></p><p><img src=/image-20241226135730697.png alt=image-20241226135730697></p><p><img src=/image-20241226135756327.png alt=image-20241226135756327></p><p><strong>DR优化结果</strong></p><p><img src=/image-20241226140031433.png alt=image-20241226140031433></p><p><strong>线长估计</strong></p><p><img src=/image-20241226140057750.png alt=image-20241226140057750></p><p><img src=/image-20241226142425570.png alt=image-20241226142425570></p><p><img src=/image-20241226142433618.png alt=image-20241226142433618></p><p><strong>Runtime</strong></p><p><img src=/image-20241226142533340.png alt=image-20241226142533340></p><p><img src=/image-20241226142539173.png alt=image-20241226142539173></p><h3 id=dr>DR
<a class=anchor href=#dr>#</a></h3><h3 id=-detailed-router-date-2021-rl><a href=https://ieeexplore.ieee.org/document/9474007>-Detailed Router-DATE-2021-RL</a>
<a class=anchor href=#-detailed-router-date-2021-rl>#</a></h3><p><img src=/image-20241012161419196.png alt=image-20241012161419196></p><h3 id=dprouter-detail-routingpackage-design-optnet-order-decision-aspadc-2023-rlmarl-diagonally-routedmynotesedaroutingdprouter-detail-routingpackage-design-optnet-order-decision-aspadc-2023-rlmarl-diagonally-routepdf>[DPRouter-Detail Routing(package design) Opt+net order decision-ASPADC-2023-RL(MARL)-diagonally route](&ldquo;D:\MyNotes\EDA\Routing\DPRouter-Detail Routing(package design) Opt+net order decision-ASPADC-2023-RL(MARL)-diagonally route.pdf&rdquo;)
<a class=anchor href=#dprouter-detail-routingpackage-design-optnet-order-decision-aspadc-2023-rlmarl-diagonally-routedmynotesedaroutingdprouter-detail-routingpackage-design-optnet-order-decision-aspadc-2023-rlmarl-diagonally-routepdf>#</a></h3><p><img src=/image-20241027101634534.png alt=image-20241027101634534></p><ul><li><p>BackGround</p><ul><li>most time-consuming stages in the <strong>package design</strong> flow</li><li>package designs have fewer layers; thus, we need to prevent net crashing cautiously</li></ul></li><li><p>contrbution:</p><ul><li>redefine the routing area and shrink the routing problem by dividing the entire design into <strong>non-overlapping boxes</strong></li><li>use DRL, not heuristic</li><li>prove the number of design rule violations (DRVs), wirelength and layout pattern.</li></ul></li><li><p>task</p><ul><li>2-pin nets</li></ul><p><img src=/image-20241027104527603.png alt=image-20241027104527603></p><p>Initial routing: ignores the number of bends and allows design rule violations</p><p><img src=/image-20241027104906544.png alt=image-20241027104906544></p></li><li><p>Model</p><p>multi-agent deep reinforcement learning (<strong>MARL</strong>) task [15] for <strong>asynchronous</strong> routing planning between nets. We regard each net as an agent, which needs to consider the actions of other agents while making pathing decisions to avoid routing conflict</p><p><img src=/image-20241027104558097.png alt=image-20241027104558097></p><p><img src=/image-20241027105909572.png alt=image-20241027105909572></p><p>route and slide the window repeatedly. advantage of box:process every box independently</p><ul><li><p>sequential routing</p><p><img src=/image-20241027134657161.png alt=image-20241027134657161></p><p><img src=/image-20241027133917659.png alt=image-20241027133917659></p><p><img src=/image-20241027133231542.png alt=image-20241027133231542></p><p><img src=/image-20241027133826865.png alt=image-20241027133826865></p><p>the repulsion point will be moved from the inner ring to the outer one until the box is successfully routed.</p><p>具体算法：</p><p><img src=/image-20241027141238708.png alt=image-20241027141238708></p></li><li><p>sequential routing</p><p><img src=/image-20241027142631796.png alt=image-20241027142631796></p><ul><li><img src=/image-20241027143243104.png alt=image-20241027143243104></li><li><img src=/image-20241027144931328.png alt=image-20241027144931328></li></ul></li><li><p>Refinement</p><p><img src=/image-20241027144108460.png alt=image-20241027144108460></p></li></ul></li></ul><h3 id=-detail-routingmatchopt-ispd-2023-rlgnn-finfet><a href=/zh/>-Detail routing+match+Opt-ISPD-2023-RL+GNN-FinFET </a><a class=anchor href=#-detail-routingmatchopt-ispd-2023-rlgnn-finfet>#</a></h3><h4 id=background-14>background:
<a class=anchor href=#background-14>#</a></h4><ul><li><p>cutom circuits: a custom detailed router cannot adopt specialized layout strategies for specific circuit classes like human layout experts</p></li><li><p><img src=/image-20241028221540078.png alt=image-20241028221540078></p></li><li><p><img src=/image-20241028224206180.png alt=image-20241028224206180></p></li><li><p><img src=/image-20241028222447134.png alt=image-20241028222447134></p></li><li><p>一直在强调match的问题：</p><p><img src=/image-20241028224639124.png alt=image-20241028224639124></p></li></ul><h4 id=contribution-10>contribution
<a class=anchor href=#contribution-10>#</a></h4><ul><li>opt roouting, FinFET, sign-off solution</li><li>异构图</li><li>A rip-up and re-routing scheme</li><li>can easily adapt to future design constraints</li></ul><p><strong>three categories of routing methodologies</strong></p><ol><li>Template-based methods<ul><li>manual design</li><li>suffers from scalability issues</li></ul></li><li>Simulation-based techniques<ul><li>provide accurate performance feedback and can be generalized to consider various performance metrics (e.g., phase
margin, power dissipation) across circuit classes</li><li>long execution time and resource-hungry computations</li></ul></li><li>Constraint-based approaches<ul><li>widely adopted in existing custom routing studies</li></ul></li></ol><h1 id=pr-tools>PR Tools
<a class=anchor href=#pr-tools>#</a></h1><h2 id=placer>Placer
<a class=anchor href=#placer>#</a></h2><h3 id=chip-placement-with-deep-reinforcement-learning-marcro-arxiv-2020-rl><a href=https://arxiv.org/pdf/2004.10746>Chip Placement with Deep Reinforcement Learning-marcro-arXiv-2020-RL</a>
<a class=anchor href=#chip-placement-with-deep-reinforcement-learning-marcro-arxiv-2020-rl>#</a></h3><ul><li>first explores the application of artificial intelligence in solving placement with the attempt to ease the difficulties of manual effort, which may indicate a new development stage for physical design</li></ul><h3 id=differentiable-timing-driven-global-placement-global-placement-dac-2022-gnn-><a href=https://dl.acm.org/doi/pdf/10.1145/3489517.3530486>Differentiable-Timing-Driven Global Placement-global placement-DAC-2022-GNN-</a>
<a class=anchor href=#differentiable-timing-driven-global-placement-global-placement-dac-2022-gnn->#</a></h3><h3 id=polar-20><a href=https://ieeexplore.ieee.org/document/6881450>Polar 2.0</a>
<a class=anchor href=#polar-20>#</a></h3><p>An effective <strong>routability-driven</strong> placer</p><p>cells that are estimated to have high congestion are spread out and inflated to distribute routing demand more evenly.</p><h5 id=ntuplace3><strong>NTUPlace3</strong>
<a class=anchor href=#ntuplace3>#</a></h5><h3 id=deepplace><a href=https://github.com/PKUterran/DeepPlace>DeepPlace</a>
<a class=anchor href=#deepplace>#</a></h3><h4 id=flow-5>flow
<a class=anchor href=#flow-5>#</a></h4><h3 id=replace><a href=https://ieeexplore.ieee.org/abstract/document/8418790>RePlAce&ndash;TCAD-2018-</a>
<a class=anchor href=#replace>#</a></h3><h3 id=dreamplace-gp-dactcadiccaddate-2019><a href=https://github.com/limbo018/DREAMPlace>DREAMPlace-GP-DAC+TCAD+ICCAD+DATE-2019~2023</a>
<a class=anchor href=#dreamplace-gp-dactcadiccaddate-2019>#</a></h3><p><strong>introduction</strong></p><p>Over <code>30X</code> speedup over the CPU implementation (
<a href=https://doi.org/10.1109/TCAD.2018.2859220>RePlAce</a>) is achieved in global placement and legalization on ISPD 2005 contest benchmarks</p><p>DREAMPlace runs on both CPU and GPU. If it is installed on a machine without GPU, only CPU support will be enabled with multi-threading.</p><p>DREAMPlace also integrates a GPU-accelerated detailed placer,<code> ABCDPlace</code>, which can achieve around <code>16X</code> speedup on million-size benchmarks over the widely-adopted sequential placer
<a href=https://doi.org/10.1109/TCAD.2008.923063>NTUPlace3</a> on CPU.</p><p><strong>Publications</strong></p><ul><li><a href=http://yibolin.com/>Yibo Lin</a>, Shounak Dhar,
<a href=http://wuxili.net/>Wuxi Li</a>, Haoxing Ren, Brucek Khailany and
<a href=http://users.ece.utexas.edu/~dpan>David Z. Pan</a>, &ldquo;<strong>DREAMPlace: Deep Learning Toolkit-Enabled GPU Acceleration for Modern VLSI Placement</strong>&rdquo;, ACM/IEEE Design Automation Conference (DAC), Las Vegas, NV, Jun 2-6, 2019 (
<a href=http://yibolin.com/publications/papers/PLACE_DAC2019_Lin.pdf>preprint</a>) (
<a href=http://yibolin.com/publications/papers/PLACE_DAC2019_Lin.slides.pptx>slides</a>)</li><li><a href=http://yibolin.com/>Yibo Lin</a>, Zixuan Jiang,
<a href=https://jeremiemelo.github.io/>Jiaqi Gu</a>,
<a href=http://wuxili.net/>Wuxi Li</a>, Shounak Dhar, Haoxing Ren, Brucek Khailany and
<a href=http://users.ece.utexas.edu/~dpan>David Z. Pan</a>, &ldquo;<strong>DREAMPlace: Deep Learning Toolkit-Enabled GPU Acceleration for Modern VLSI Placement</strong>&rdquo;, IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems (TCAD), 2020</li><li><a href=http://yibolin.com/>Yibo Lin</a>,
<a href=http://wuxili.net/>Wuxi Li</a>,
<a href=https://jeremiemelo.github.io/>Jiaqi Gu</a>, Haoxing Ren, Brucek Khailany and
<a href=http://users.ece.utexas.edu/~dpan>David Z. Pan</a>, &ldquo;<strong>ABCDPlace: Accelerated Batch-based Concurrent Detailed Placement on Multi-threaded CPUs and GPUs</strong>&rdquo;, IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems (TCAD), 2020 (
<a href=http://yibolin.com/publications/papers/ABCDPLACE_TCAD2020_Lin.pdf>preprint</a>)</li><li><a href=http://yibolin.com/>Yibo Lin</a>,
<a href=http://users.ece.utexas.edu/~dpan>David Z. Pan</a>, Haoxing Ren and Brucek Khailany, &ldquo;<strong>DREAMPlace 2.0: Open-Source GPU-Accelerated Global and Detailed Placement for Large-Scale VLSI Designs</strong>&rdquo;, China Semiconductor Technology International Conference (CSTIC), Shanghai, China, Jun, 2020 (
<a href=http://yibolin.com/publications/papers/PLACE_CSTIC2020_Lin.pdf>preprint</a>)(Invited Paper)</li><li><a href=https://jeremiemelo.github.io/>Jiaqi Gu</a>, Zixuan Jiang,
<a href=http://yibolin.com/>Yibo Lin</a> and
<a href=http://users.ece.utexas.edu/~dpan>David Z. Pan</a>, &ldquo;<strong>DREAMPlace 3.0: Multi-Electrostatics Based Robust VLSI Placement with Region Constraints</strong>&rdquo;, IEEE/ACM International Conference on Computer-Aided Design (ICCAD), Nov 2-5, 2020 (
<a href=http://yibolin.com/publications/papers/PLACE_ICCAD2020_Gu.pdf>preprint</a>)</li><li><a href=https://enzoleo.github.io/>Peiyu Liao</a>,
<a href=https://lusica1031.github.io/>Siting Liu</a>, Zhitang Chen, Wenlong Lv,
<a href=http://yibolin.com/>Yibo Lin</a> and
<a href=https://www.cse.cuhk.edu.hk/~byu/>Bei Yu</a>, &ldquo;<strong>DREAMPlace 4.0: Timing-driven Global Placement with Momentum-based Net Weighting</strong>&rdquo;, IEEE/ACM Proceedings Design, Automation and Test in Eurpoe (DATE), Antwerp, Belgium, Mar 14-23, 2022 (
<a href=https://yibolin.com/publications/papers/PLACE_DATE2022_Liao.pdf>preprint</a>)</li><li>Yifan Chen,
<a href=http://faculty.bicmr.pku.edu.cn/~wenzw/>Zaiwen Wen</a>,
<a href=https://ericlyun.github.io/>Yun Liang</a>,
<a href=http://yibolin.com/>Yibo Lin</a>, &ldquo;<strong>Stronger Mixed-Size Placement Backbone Considering Second-Order Information</strong>&rdquo;, IEEE/ACM International Conference on Computer-Aided Design (ICCAD), San Francisco, CA, Oct, 2023 (
<a href=https://yibolin.com/publications/papers/PLACE_ICCAD2023_Chen.pdf>preprint</a>)</li></ul><p><strong>Architecture</strong></p><p><img src=/image-20241211185233352.png alt=image-20241211185233352></p><p><img src=/image-20241211185244415.png alt=image-20241211185244415></p><h4 id=flow-6>flow
<a class=anchor href=#flow-6>#</a></h4><h2 id=gr_outdated>GR_outdated
<a class=anchor href=#gr_outdated>#</a></h2><h3 id=fastroute102006><a href=/zh/>FastRoute1.0—2006</a>
<a class=anchor href=#fastroute102006>#</a></h3><ul><li>roposed a simple way to construct <strong>congestion driven Steiner tree</strong> and an edge shifting technique to further refine it</li></ul><h3 id=fastroute-20-monotonic2007><a href=/zh/>fastroute 2.0-Monotonic–2007</a>
<a class=anchor href=#fastroute-20-monotonic2007>#</a></h3><ul><li>monotonic routing to explore all shortest routing paths for two-pin connections.</li></ul><h4 id=task-9>task
<a class=anchor href=#task-9>#</a></h4><p><img src=/image-20241114191327215.png alt=image-20241114191327215></p><h4 id=flow-7>flow
<a class=anchor href=#flow-7>#</a></h4><p><strong><img src=/image-20241114205659503.png alt=image-20241114205659503></strong></p><p><img src=/image-20241115160208134.png alt=image-20241115160208134></p><h3 id=fastroute-30-virtual-capacity-iccad-2008-><a href=/zh/>fastroute 3.0-virtual capacity-ICCAD-2008-</a>
<a class=anchor href=#fastroute-30-virtual-capacity-iccad-2008->#</a></h3><h3 id=fastroute-40-via-min-tree3-bending-aspdac-2009-><a href=/zh/>fastroute 4.0-via min tree+3 bending-ASPDAC-2009-</a>
<a class=anchor href=#fastroute-40-via-min-tree3-bending-aspdac-2009->#</a></h3><p><img src=/image-20241116121010565.png alt=image-20241116121010565></p><p><img src=/image-20241115160433890.png alt=image-20241115160433890></p><p><img src=/image-20241115160445784.png alt=image-20241115160445784></p><p><img src=/image-20241116105606149.png alt=image-20241116105606149></p><p><img src=/image-20241116121317660.png alt=image-20241116121317660></p><p><img src=/image-20241116121311506.png alt=image-20241116121311506></p><p><strong>层分配</strong></p><p><img src=/image-20241116124343911.png alt=image-20241116124343911></p><p>?</p><p><img src=/image-20241116125839541.png alt=image-20241116125839541></p><p><img src=/image-20241116125830996.png alt=image-20241116125830996></p><h3 id=maizerouter-><a href=/zh/>MaizeRouter-</a>
<a class=anchor href=#maizerouter->#</a></h3><ul><li>2nd place of ISPD 2007 contest 2D GR</li><li>1st place of ISPD 2007 contest 3D GR</li></ul><h3 id=boxrouter-10><a href=/zh/>BoxRouter 1.0</a>
<a class=anchor href=#boxrouter-10>#</a></h3><ul><li>3rd place of ISPD 2007 contest 2D GR</li><li>2nd place of ISPD 2007 contest 3D GR</li><li>integer linear programming (ILP) based</li></ul><h3 id=fgr-3d-tcad-2008-><a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=4526750">FGR-3d-TCAD-2008-</a>
<a class=anchor href=#fgr-3d-tcad-2008->#</a></h3><ul><li>1st place of ISPD 2007 contest 2D GR</li><li>3rd place of ISPD 2007 contest 3D GR</li></ul><h3 id=-layer-assignmentvia-minization-trans-2008-dp-nthu><a href=https://ieeexplore-ieee-org-443.webvpn.scut.edu.cn/document/4603083>-Layer assignment+Via minization-Trans-2008-DP-NTHU</a>
<a class=anchor href=#-layer-assignmentvia-minization-trans-2008-dp-nthu>#</a></h3><ul><li>Congestion-Constrained Layer Assignment for Via Minimization in Global Routing</li><li>CUGR’s rely work</li><li>ISPD07 contest后的一个跟进工作</li><li>也没提到maze routing</li><li>没定义wire cost, 在每一对GCell之间layer assignment, 慢？</li><li>第一次用DP?</li></ul><h4 id=background-15>background
<a class=anchor href=#background-15>#</a></h4><ul><li><p>there are two main approaches</p><p><img src=/image-20250208202630352.png alt=image-20250208202630352></p><ul><li><p><code>3D</code>: route all nets directly on the multilayer solution space. Because this approach directly generates a multilayer global routing result, <strong>it can take the via cost into account during construction</strong>. However, this method may cost <strong>too much CPU time</strong> with a large problem size. (现在都用GPU做并行了，这种方法就变多了)</p><ol><li><p>such as</p><p><img src=/image-20250208201732440.png alt=image-20250208201732440></p></li></ol></li><li><p><code>2D + layer assigment</code>: The other approach is to first <strong>compress</strong> a multilayer grid graph into a one-layer grid graph, then use a <strong>one-layer router</strong> to solve the one-layer global routing problem, and finally perform <strong>layer assignment</strong> to assign each wire in the multilayer grid graph</p><p><img src=/image-20250208202642473.png alt=image-20250208202642473></p><p>The edges corresponding to <strong>vias disappear</strong> in the one-layer grid graph. The capacity of each edge in the one-layer grid graph is obtained by <strong>accumulating</strong> the corresponding edge capacities in the three-layer grid graph</p><p>This approach can take advantage of many current full-fledged one-layer routers, e.g., [2]–[4], and use an affordable run time to generate an initial one-layer routing result. 本文主要针对layer assignment. 注意layer assignment 是对二维的所有边进行层分配。</p></li></ul></li><li><p>vias not only degrade the reliability and the performance of a design but also increase the manufacturing cost.</p></li><li><p>previous work’s layer assignment use greedy heuristics [8] or time-consuming integer linear programming methods [9] to minimize the via cost.</p></li><li><p>像这种串行的还是要考虑net order, 越早布线的net越不会拥塞，net order很重要</p></li></ul><p><strong>task and contribution:</strong></p><ul><li>这篇没有考虑优先方向（To simplify the presentation of our algorithm, we do not make any assumption about the preferred routing direction for each layer in the layer assignment problem.）不过也说明了这个工作能够很简单引用到考虑优先方向的情况</li><li>follow ISPD07 contest, 假设via的capacity是无限的（CUGR中明确了不进行这种假设）</li><li>based on a one-layer routing result</li><li>minimize <code>via cost</code>, <code>WL</code> and <code>congestion overflow</code></li><li>propose a polynomial-time algorithm: first generate <code>net order</code> , then solves the layer assignment problem</li><li>can improve 3 winner of ISPD07 contest</li></ul><h4 id=model-9>model
<a class=anchor href=#model-9>#</a></h4><ul><li><p>COngestion-constrained Layer Assignment (COLA)’s submodule</p><ul><li><p>Net order generation</p><ol><li><p>The net order has a direct influence on the utilization of routing resources, so it is one of the key parts of COLA.</p></li><li><p>对net进行打分决定order</p><p><img src=/image-20250208220017618.png alt=image-20250208220017618></p><p>注意，线长越短，分数越高，net越应该先布线。解释：</p><p><img src=/image-20250208221143998.png alt=image-20250208221143998></p></li></ol></li><li><p>Eemove Cycles</p><ol><li><p>Arbitrarily remove.</p></li><li><p>（为什么映射到第一层会有cycles？初始是怎么连起来的？没说？FLUTE算法是08年才出来，可能当时还没用上）</p><p><img src=/image-20250208222041475.png alt=image-20250208222041475></p></li></ol></li><li><p>Single-net layer assignment （SOLA+APEC）</p><p><strong>SOLA</strong>(Singlenet Optimal Layer Assignment)</p><ol><li><p>determines an optimal layer assignment result <strong>without considering congestion constraints</strong> for a given net</p></li><li><p><strong>dynamic programming</strong> technique</p></li><li><p>不考虑拥塞，这个方法能得到最好质量</p></li><li><p>step:</p><blockquote><p>01: for tree in layer 1, <strong>random</strong> select a pin as root, then use DFS or DFS to get a <strong>queue</strong>, so get the edge <strong>order</strong>. It become a <strong>DAG</strong></p><p><img src=/image-20250208223956201.png alt=image-20250208223956201></p><p>02: 定义图5(c)中, a的父节点是p2，定义mvc(v, r)（minimum via cost）</p><p><img src=/image-20250209140741895.png alt=image-20250209140741895></p><p>03:</p><p>​ for pins who have not child, mvc:</p><p><img src=/image-20250209143711603.png alt=image-20250209143711603></p><p>​ for pins who have child and not root:</p><p>​ 这个公式其实就是为了确定下每个点下一步的layer在哪里。比如算出最小是mvc(v, 1), 那么e_(v, ch(e))就在第r层</p><p><img src=/image-20250209143753884.png alt=image-20250209143753884></p><p>​ for root:</p><p><img src=/image-20250209145157487.png alt=image-20250209145157487></p><ul><li><p>the difference is excluding r in ∆</p></li><li><p>because mvc(v, r) does not depend on the value of r when v</p><p>is the root, we have mvc (v, 1) = mvc(v, 2) = · · · = mvc(v, k)</p></li></ul></blockquote></li></ol><p><strong>APEC</strong>(Accurate and Predictable Examination for Congestion constraints)</p><ol><li><p>can detect and prevent any <strong>congestion</strong> constraint violation in advance</p></li><li><p>prevention condition:</p><p><img src=/image-20250209153339230.png alt=image-20250209153339230></p><p>如果存在一个在layer1上压缩的边不满足这两个condition，那么这条边的layer assignment（SOLA）结果就不可能满足congesion</p></li></ol></li><li><p>SOLA+APEC always finds a layer assignment result satisfying both <strong>prevention conditions</strong> for each net</p></li></ul></li><li><p>COLA</p><p><img src=/image-20250209153812734.png alt=image-20250209153812734></p></li></ul><p>​</p><h4 id=data-8>data
<a class=anchor href=#data-8>#</a></h4><p>six-layer benchmarks from ISPD’07</p><h3 id=grip-3dip-dac-2009><a href=https://dl.acm.org/doi/pdf/10.1145/1629911.1629999>GRIP-3d+IP-DAC-2009</a>
<a class=anchor href=#grip-3dip-dac-2009>#</a></h3><p>基于整数规划</p><p>3d: solve the 3D problem directly on the 3D routing grids,</p><p>slow: Although theoretically the direct 3D technique should produce better solutions, in practice it is less successful in both solution quality and runtime than 2D routing with layer assignment –cite–> [Fastroute4.1]</p><p>slow: Although we see solutions with shorter wirelength generated by full-3D concurrent approach like GRIP [21], that solution quality is achieved by impractically long runtime –cite–> [Fastroute4.1]</p><p><a href=https://ieeexplore.ieee.org/abstract/document/6105336>MGR–ICCAD-2011</a></p><p>multi-level （coarsened and fine-gained）</p><h3 id=fastroute41-an-efficient-and-high-quality-global-router-2012><a href=https://home.engineering.iastate.edu/~cnchu/pubs/j52.pdf>FastRoute4.1-an efficient and high-quality global router-2012</a>
<a class=anchor href=#fastroute41-an-efficient-and-high-quality-global-router-2012>#</a></h3><p><a href=https://dl.acm.org/doi/abs/10.1155/2012/608362>https://dl.acm.org/doi/abs/10.1155/2012/608362</a></p><h4 id=background-16>background
<a class=anchor href=#background-16>#</a></h4><p>FastRoute is a global routing tool for VLSI back-end design. It is based on sequential rip-up and re-route (RRR) and a lot of novel techniques.
<a href=http://home.engineering.iastate.edu/~cnchu/pubs/c36.pdf>FastRoute 1.0</a> first uses <strong>FLUTE</strong> to construct <strong>congestion-driven Steiner trees</strong>, which will later undergo the <strong>edge shifting</strong> process to optimize tree structure to reduce congestion. It then uses <strong>pattern routing and maze routing</strong> with <strong>logistic function</strong> based cost function to solve the congestion problem.
<a href=http://home.engineering.iastate.edu/~cnchu/pubs/c40.pdf>FastRoute 2.0</a> proposed <strong>monotonic routing</strong> and <strong>multi-source multi-sink maze routing</strong> techniques to enhance the capability to reduce congestion.
<a href=http://home.engineering.iastate.edu/~cnchu/pubs/c51.pdf>FastRoute 3.0</a> introduced the <strong>virtual capacity</strong> technique to adaptively change the capacity associated with each global edge to divert wire usage from highly congested regions to less congested regions.
<a href=http://home.engineering.iastate.edu/~cnchu/pubs/c52.pdf>FastRoute 4.0</a> proposed <strong>via-aware Steiner tree</strong>, <strong>3-bend routing</strong> and a <strong>delicate layer assignment algorithm</strong> to effectively reduce via count while maintaining outstanding congestion reduction capability.
<a href=http://home.engineering.iastate.edu/~cnchu/pubs/j52.pdf>FastRoute 4.1</a> simplifies the way the <strong>virtual capacities</strong> are updated and applies a single set of tuning parameters to all benchmark circuits.</p><h4 id=model-10>model
<a class=anchor href=#model-10>#</a></h4><p><img src=/image-20241211103407310.png alt=image-20241211103407310></p><h4 id=flow-8>flow
<a class=anchor href=#flow-8>#</a></h4><p><img src=/image-20241211103347856.png alt=image-20241211103347856></p><h3 id=nthu-route-10---tvlsi-2010-><a href=https://ieeexplore.ieee.org/document/5703167>NTHU Route 1.0- -TVLSI-2010-</a>
<a class=anchor href=#nthu-route-10---tvlsi-2010->#</a></h3><p><img src=/image-20241115155033412.png alt=image-20241115155033412></p><h3 id=nthu-route-20---tcad-2013><a href=https://ieeexplore.ieee.org/document/6504553>NTHU Route 2.0- -TCAD-2013</a>
<a class=anchor href=#nthu-route-20---tcad-2013>#</a></h3><p>2D</p><h3 id=nctu-gr-10-3d-congestion-relaxed-layer-assignment--2011-><a href=https://ieeexplore.ieee.org/document/5703167>NCTU GR 1.0-3D-congestion relaxed layer assignment- 2011-</a>
<a class=anchor href=#nctu-gr-10-3d-congestion-relaxed-layer-assignment--2011->#</a></h3><ul><li>it improved the scheme to estimate the realtime congestion more accurately by using a history term that will gradually wear off as the number of iterations increases if the overflow disappears.</li><li></li></ul><h3 id=nctu-gr-20-multithreaded-collision-aware--cad-2013-><a href=https://ieeexplore.ieee.org/document/6504553>NCTU GR 2.0-Multithreaded Collision Aware- CAD-2013-</a>
<a class=anchor href=#nctu-gr-20-multithreaded-collision-aware--cad-2013->#</a></h3><p><a href=https://people.cs.nycu.edu.tw/~whliu/NCTU-GR.htm>people.cs.nycu.edu.tw/~whliu/NCTU-GR.htm</a></p><p><a href=https://github.com/PengjuY/NCTU-GR2>PengjuY/NCTU-GR2: This is a binary file of NCTUgr2, which is a global router</a></p><ul><li>net-level parallel method</li><li>2D</li></ul><h3 id=boxrouter-20><a href=/zh/>BoxRouter 2.0</a>
<a class=anchor href=#boxrouter-20>#</a></h3><h4 id=background-17>background
<a class=anchor href=#background-17>#</a></h4><h4 id=task-10>task
<a class=anchor href=#task-10>#</a></h4><p>是一个2d的</p><p>整数规划</p><p><img src=/image-20241115155857782.png alt=image-20241115155857782></p><h3 id=ogre--new-cost-function---2019---><a href=https://woset-workshop.github.io/PDFs/2019/a18.pdf>OGRE- new cost function- -2019- -</a>
<a class=anchor href=#ogre--new-cost-function---2019--->#</a></h3><ul><li><a href=https://github.com/AUCOHL/OGRE>Open source!</a></li><li><strong>LEF/DEF-based</strong></li><li>3D</li><li>用的是老方法，不过解释的挺清楚的</li><li>components by a group of undergraduate students as a course project.</li></ul><h3 id=sproute-10-a-scalable-parallel-negotiation-based-global-router-iccad-2019><a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=8942105">SPRoute 1.0: A Scalable Parallel Negotiation-based Global Router-ICCAD-2019</a>
<a class=anchor href=#sproute-10-a-scalable-parallel-negotiation-based-global-router-iccad-2019>#</a></h3><ul><li><p>基于<code>net-level</code>多线程的并行加速<code>迷宫算法</code></p></li><li><p><code>negotiation-based</code> rip-up and reroute two-phase maze routing</p></li><li><p>resolves livelock issue(CPU)</p></li><li><p>open source</p></li><li><p>introduced a concept called <code>soft capacity</code> to reserve routing space for detailed routing and explored <code>several parallelization strategies</code> to speed up global routing.</p></li><li><p>是CPU上的并行，讲了挺多关于锁的问题，没看懂，让我们看2.0吧</p></li></ul><h4 id=background-18>background
<a class=anchor href=#background-18>#</a></h4><p>总体</p><p><img src=/image-20241118140649906.png alt=image-20241118140649906></p><p>In many global routers, maze routing is the most time-consuming stage.</p><p><img src=/image-20241118141048410.png alt=image-20241118141048410></p><p><strong>challenge</strong></p><p><img src=/image-20241118144548718.png alt=image-20241118144548718></p><p><img src=/image-20241118144701004.png alt=image-20241118144701004></p><p>因为这个现象，多线程反而慢了</p><p><img src=/image-20241118144924768.png alt=image-20241118144924768></p><p><strong>原理</strong></p><ul><li><p>Galois system</p><p><img src=/image-20241118150854386.png alt=image-20241118150854386></p></li><li><p>Net-level Parallelism</p></li><li><p>Fine-grain Parallelism</p></li></ul><h4 id=data-9>data
<a class=anchor href=#data-9>#</a></h4><p>ISPD 2008 contest</p><h2 id=gr_adv_rl>GR_Adv_RL
<a class=anchor href=#gr_adv_rl>#</a></h2><h3 id=-drl-method-2019-drl-><a href=https://arxiv.org/pdf/1906.08809>-DRL method-2019-DRL-</a>
<a class=anchor href=#-drl-method-2019-drl->#</a></h3><ul><li>first DRL related work</li><li>proves its overall performance is better than the sequential A∗ algorithm.</li></ul><h4 id=task-11>task
<a class=anchor href=#task-11>#</a></h4><ul><li>DRL(DQN) for global route</li><li>have not use real world design</li></ul><p>example:</p><p>​ from A to B</p><p>​ read means over flow</p><p><img src=/image-20241114192638647.png alt=image-20241114192638647></p><p><img src=/image-20241114193438871.png alt=image-20241114193438871></p><p><strong>pipeline</strong></p><p><img src=/image-20241114192055104.png alt=image-20241114192055104></p><h4 id=model-11>model
<a class=anchor href=#model-11>#</a></h4><p>state:</p><ul><li>(pos_x/y/z, distance_x/y/z, 周围的capacity, )这种编码方案可以被视为当前状态、导航和本地容量信息的混合</li></ul><p>action: 上下左右前后</p><p>reward：</p><p><img src=/image-20241114200225347.png alt=image-20241114200225347></p><p><img src=/image-20241114200512353.png alt=image-20241114200512353></p><h4 id=contribution-11>contribution
<a class=anchor href=#contribution-11>#</a></h4><p>first deep learning model for global routing</p><h3 id=-drl-arxiv-2021-jp><a href=https://arxiv.org/pdf/2010.09465>-DRL-arxiv-2021-JP</a>
<a class=anchor href=#-drl-arxiv-2021-jp>#</a></h3><h3 id=---wcmc-2023-drl-fuzhouu-genggeng-liu><a href=https://onlinelibrary.wiley.com/doi/epdf/10.1155/2023/6593938>- -WCMC-2023-DRL-FuZhouU-Genggeng Liu</a>
<a class=anchor href=#---wcmc-2023-drl-fuzhouu-genggeng-liu>#</a></h3><ul><li>most of the existing methods are heuristic algorithms, which cannot conjointly optimize the subproblems of global routing, resulting in congestion and overflow</li><li>DRL和RL的区别：RL often faces the problem of the excessive number of states when dealing with high-dimensional spaces. With the development of deep learning, the Deep Reinforcement Learning (DRL) algorithm is developed by combining artificial neural networks with RL [10], which makes it possible for RL to solve the policy decision in a high-dimensional space</li><li></li></ul><h4 id=background-19>background
<a class=anchor href=#background-19>#</a></h4><ul><li>this paper takes the overflow as the main design goal and optimizes the wire length and congestion based on the overflow as 0.</li><li><code>Serial routing</code> usually sorts nets in a specific order and routes them one by one; ==this method is fast==（相对并行组合优化的方法？）. However, there is an unfair phenomenon: the routing difficulty of the earlier nets has sufficient routing resources (meaning that the capacity of each edge in the routing area is large), while most of the later nets have tight routing resources, so the serial routing method usually rips up part of the nets and reroutes them</li><li>The <code>parallel method</code> routes multiple nets at the same time [21], solving the unfairness of routing resources in a serial method, but it is ==often very time-consuming and even impossible to solve==, mainly based on the commodity flow model [22] and ==integer linear programming== model [23]</li></ul><h4 id=contribution-12>contribution
<a class=anchor href=#contribution-12>#</a></h4><ul><li>use DDQN instead of DQN</li><li>an action reduction method</li><li>a concurrent training method<ul><li>solve the unfair resource allocation problem</li></ul></li><li>a new reward function</li></ul><h4 id=model-12>model
<a class=anchor href=#model-12>#</a></h4><p>输入state：a 15-bit code is used; the starting point, the ending point, and the agent’s position are all represented by a 3-bit code; and a 6-bit code represents the edge capacities in six directions</p><p>输出 action：action-value of 6 directions. 但是由于每层有优先方向，所以实际上最多4个。需要在代理选择动作时，首先消除无法执行的动作，以防止代理在训练过程中执行冗余动作，存储冗余经验，然后学习冗余信息。</p><p>reward:</p><p><img src=/image-20250224230102150.png alt=image-20250224230102150></p><p>If ed is higher than ec/2, a reward r &lt; 0 is given; otherwise, a reward r ≥ 0 will be given. （他公式是不是错了？）</p><p>uses a heuristic algorithm to search for the path in advance and burn it into the experience replay buffer （类似预训练）convergence speedup</p><p><img src=/image-20250224224528028.png alt=image-20250224224528028></p><h3 id=-drlsegment-based-iseda-2023-drlgnn-pek><a href=https://ieeexplore.ieee.org/abstract/document/10218371>-DRL+segment based-ISEDA-2023-DRL+GNN-PEK</a>
<a class=anchor href=#-drlsegment-based-iseda-2023-drlgnn-pek>#</a></h3><ul><li>DRL(GAT)</li><li>segment-based feature extraction</li><li>pattern routing enhance</li><li></li></ul><p><strong>enhance:</strong></p><ul><li>3d?</li><li>加上GCELL之间的连接？</li><li>像InstantGR做一些水平垂直分层的操作？</li><li>capacity 放边上</li></ul><h4 id=background-20>background
<a class=anchor href=#background-20>#</a></h4><ul><li>many traditional global routing methods lack learning ability.</li><li>more and more problems in physical design are searching for automated solutions based on machine learning. One popular application is to adopt machine learning to help early prediction</li><li></li></ul><h4 id=contribution-13>contribution
<a class=anchor href=#contribution-13>#</a></h4><ul><li>congestion-aware reinforcement learning model</li><li>Integrating pattern routing with reinforcement learning</li><li>Proposing a net segment mode</li></ul><h4 id=flow-9>flow
<a class=anchor href=#flow-9>#</a></h4><p><img src=/image-20250221235557954.png alt=image-20250221235557954></p><p><strong>model:</strong></p><ul><li><p>GNN feature</p><ul><li>Node embedding.</li><li>Pin number.</li><li>Fly line number.</li><li>Capacity value</li><li>Bounding box number.</li><li>Position correlation.</li></ul></li><li><p>DRL(A3C)</p><ul><li>We set the policy network as a fully connected layer with 200 neurons and the value network as a fully connected layer with 100 neurons.</li><li>Feature of net segments<ul><li>Net density value</li><li>Congestion prediction value</li><li>Capacity ratio value</li></ul></li></ul></li></ul><h4 id=data-10>data
<a class=anchor href=#data-10>#</a></h4><p>ISPD18 benchmark</p><h4 id=experiment-8>experiment
<a class=anchor href=#experiment-8>#</a></h4><p><strong>question:</strong></p><ul><li>原文没说prediction model的label是什么</li><li>RL怎么做并行？具体是怎么样的，不熟</li></ul><h3 id=---apccas-2024-drlddqn-cycu><a href="https://ieeexplore-ieee-org-443.webvpn.scut.edu.cn/stamp/stamp.jsp?tp=&amp;arnumber=10808325">- -APCCAS-2024-DRL(DDQN)-CYCU</a>
<a class=anchor href=#---apccas-2024-drlddqn-cycu>#</a></h3><ul><li>DRL-based A* search algorithm</li><li>没有pattern routing的环节</li><li>就是19年那一篇，把DQN改成DDQN</li><li>俗文</li></ul><h4 id=background-21>background
<a class=anchor href=#background-21>#</a></h4><ul><li>aim to find better solutions to minimize total wire length (WL) and edge overflow (OF)</li><li>current solutions mainly rely on heuristic-driven greedy methods, which primarily address situations with strict constraints on the problems to be solved, such as sequential network routing after network sorting [2].</li><li>The A* algorithm is based on heuristic search, using a heuristic function to estimate the minimum cost from the current node to the target node. It can be used to find the shortest path from the starting point to the target pin.</li><li></li></ul><h2 id=gr_adv_gen>GR_Adv_Gen
<a class=anchor href=#gr_adv_gen>#</a></h2><h3 id=-generative-arxiv-2019-cnn-><a href=https://arxiv.org/pdf/1706.08948>-generative-arXiv-2019-CNN-</a>
<a class=anchor href=#-generative-arxiv-2019-cnn->#</a></h3><ul><li>first CNN</li></ul><h3 id=-only-cnn-dac-2020-cnnvae-><a href="https://ieeexplore-ieee-org-443.webvpn.scut.edu.cn/stamp/stamp.jsp?tp=&amp;arnumber=9218598">-only CNN-DAC-2020-CNN(VAE)-</a>
<a class=anchor href=#-only-cnn-dac-2020-cnnvae->#</a></h3><ul><li>no experiment!</li><li>只用CNN分类结果不会好吧</li><li>不知道是什么类型的文章，只用了两页</li><li>evaluates its router on parts of the nets from a public benchmark layout and achieves 96.8% of routability</li><li>it seems that the router can only route two- and three-pin nets, which may have some limitations for application.</li></ul><h4 id=background-22>background
<a class=anchor href=#background-22>#</a></h4><ul><li>is approach treats the global routing problem as an <strong>image processing</strong> problem and solves it with a deep learning system</li><li></li></ul><p><img src=/image-20241114161657070.png alt=image-20241114161657070></p><h4 id=data-11>data
<a class=anchor href=#data-11>#</a></h4><p>ISPD’98 ibm01 64x64 circuit</p><h4 id=model-13>model
<a class=anchor href=#model-13>#</a></h4><p><img src=/image-20241114162111775.png alt=image-20241114162111775></p><h3 id=prnet---neurips-2022---sjtunoahs-ark><a href=/zh/>PRNet- -NeurIPS-2022- -SJTU+Noah’s Ark</a>
<a class=anchor href=#prnet---neurips-2022---sjtunoahs-ark>#</a></h3><ul><li>PRNet can generate each route in <code>one-shot</code> but <strong>cannot guarantee connectivity</strong> which requires considerable<code> post-processing</code> for failed routes</li><li>HubRouter 是两阶段框架，PRNet 是端到端框架。</li></ul><h3 id=hubrouter-generative-model-neurips-2023-ganrl-sjtu><a href=/zh/>HubRouter-generative model-NeurIPS-2023-GAN+RL-SJTU</a>
<a class=anchor href=#hubrouter-generative-model-neurips-2023-ganrl-sjtu>#</a></h3><ul><li><a href=https://github.com/Thinklab-SJTU/EDA-AI/tree/main/HubRouter>open source!</a></li><li><a href=https://picrew.github.io/2024/03/10/HubRouter/>a chinese interpretation</a></li><li>a global routing solver that includes a two-phase learning framework</li><li>HubRouter 是两阶段框架，PRNet 是端到端框架。</li><li>对比 PRNet 生成模型，PRNet 在 CGAN 中使用双向映射将连接约束注入训练目标，将准确率提高了 10%，但在复杂情况下几乎无效。</li></ul><h4 id=background-23>background
<a class=anchor href=#background-23>#</a></h4><p><img src=/image-20250210234157942.png alt=image-20250210234157942></p><ul><li><p>全局布线(Global Routing - GR)是 VLSI 设计中最复杂且最耗时的组合问题之一。GR 目标是总线长最小，同时避免拥塞(Congestion)，是个 NP 问题。</p><p>传统采用启发式算法，多样性和规模问题对传统算法有了挑战，机器学习(ML)已经用于全局布线，在芯片设计中从逻辑合成到布局</p></li><li><p>深度强化学习(Deep Reinforcement Learning - DRL )和生成式模型(Generative model)已经被用来解决全局布线。问题在于，<strong>DRL很受状态空间(State Space)影响，随着网格空间增大，需要花费大量时间生成</strong>。However, DRL methods suffer from large state space and often need to spend enormous time on generating routes as the scale of grids increases on the test instance, i.e., the netlist, which is practically intimidating for real-world global routing</p></li><li><p>相反，生成式模型有<strong>一次性生成能力</strong>，在计算上更容易处理。</p></li><li><p>生成式方法在训练时候考虑连通性限制，确保布线满足电路连通性要求。但是问题在于，如果初始生成路径不满足连通性要求时候，后处理阶段会变成一种穷举搜索过程。</p></li><li><p><img src=/image-20250210231714841.png alt=image-20250210231714841></p></li><li><p>图一这里上图表示原始布线，下图表示算法生成的布线，生成布线没有正确连接所有应该连接的点(pin)，对于这样的情况，平均连通率很低，低于20%，意味着超过80%的生成布线需要经过耗时的后处理才能达到要求。显著的缺点。其实就和[CNN-based](#
<a href="https://ieeexplore-ieee-org-443.webvpn.scut.edu.cn/stamp/stamp.jsp?tp=&amp;arnumber=9218598">-only CNN-DAC-2020-CNN(VAE)-</a>)这篇一样</p></li><li><p><img src=/image-20250210233812834.png alt=image-20250210233812834></p></li></ul><h4 id=contribution-14>contribution
<a class=anchor href=#contribution-14>#</a></h4><ul><li><p>为了解决上述问题，定义了一个新的概念，叫<code>hub</code>。将pin - pin问题 &ndash;> hub - pin问题 。</p></li><li><p>提出了一种新的两阶段全局布线方法 &ndash;> HubRouter</p><ul><li><p>generation phase（生成阶段）</p><p><code>hubs</code>, <code>routes</code>, and <code>stripe masks</code> are together generated under a multi-task framework by generative models</p><p>可以在多个框架下生成，比如 GAN (Generative Adversarial Nets) , VAE (Variational Auto-Encoder) , DPM (Diffusion Probabilistic Models) 。虽然hub是生成阶段的主要输出，但为了提升生成质量和准确性，发现生成附加信息是非常有用的。比如感知和掩码(<code>local perception</code> and <code>stripe masks</code>)，能够去除噪声点。引入<code>多任务学习</code>，布线和掩码一起生成，提高 hub 生成质量</p></li><li><p>pin-hub-connection phase（hub和pin连接阶段）</p><p>将连接视为<code>最小斯坦纳树(RSMT)</code>问题，使用 <code>actor-critic </code>模型网络策略。</p><p>is hub generate correcttly, reconstruction time complexity can be reduced to <strong>O(n log n)</strong></p></li></ul></li><li><p>SOTA generative global routing models</p></li></ul><p><strong>model:</strong></p><p><img src=/image-20250210234537382.png alt=image-20250210234537382></p><ul><li><p>Hub</p><p><img src=/image-20250212194312475.png alt=image-20250212194312475></p><ul><li>(virtual) key point in the route</li><li>transferring the pin-pin connection problem to the hub-pin connection problem</li><li>斯坦纳点(Rectilinear Steiner Point &ndash;> RSP)是搜索全局最小总距离，但是 hub 是来确定路径。RSPs are special cases of hubs</li><li>RSP是Hub的特例，Hub可以随意生成不同形状的路径(不仅是最短的)</li><li>这里的 <code>c</code> 和 <code>x</code> 分别代表条件图像和输入图像。条件图像可能包括引脚位置、已经提取的中心点以及条带掩模（stripe mask）。条带掩模是用来指示布线区域的一种方式，它可以帮助模型更好地理解哪些区域可以用于布线</li><li></li></ul></li></ul><h4 id=flow-10>flow
<a class=anchor href=#flow-10>#</a></h4><p><img src=/image-20250212201906601.png alt=image-20250212201906601></p><ul><li><p>hub生成阶段</p><ul><li><p>Hub 生成可以表示为图像到图像的<code>multi-task learning framework</code> 任务, address the impact of sensitive <strong>noise</strong> points with stripe <code>mask learning</code></p></li><li><p><code>附录 B </code>介绍了将 GAN，VAE，EAN 纳入到生成框架</p></li><li><p>在这个阶段，模型旨在逼近条件分布 <code>pθ(x|z, c)</code> 使其接近先验分布 <code>p(x|c)</code>。给定条件 <code>c</code> 和从先验分布 <code>pz(z)</code> 中采样得到的潜在变量 <code>z</code>（通常假设为<strong>高斯分布</strong>），模型会生成一些“中心点（hubs）”. 这里的 <code>c</code> 和 <code>x</code> 分别代表条件图像和输入图像。z is a latent variable from a prior distribution</p></li><li><p>The main objective of hub generation is to minimize the difference between probability distributions <code>p(x|c) </code>and <code>pθ(x|z, c)</code></p></li><li><p>a noise hub, especially the outermost one, can largely harm the wirelength of routing. Use <code>stripe mask</code> to focus on bad cases for hub generation</p><p><img src=/image-20250212202848907.png alt=image-20250212202848907></p></li></ul></li><li><p>hub和pin连接阶段</p><ul><li>模型连接第一阶段生成的<strong>中心点</strong>，以获得最终的布线路由。这个过程可以被视为构建矩形稳定最小生成树（Rectilinear Steiner Minimum Tree，RSMT）的一部分。为了完成布线，模型遵循了一个基于强化学习（Reinforcement Learning，RL）的算法 <code>REST</code>。</li><li>在两阶段的过程中，作者还提出了一个<code>多任务学习框架</code>来提高生成中心点的质量。特别是，提出了一种新颖的<code>条带掩模学习方法</code>，旨在减轻噪声点案例可能造成的负面影响。算法的具体细节在<code>附录 B </code>中给出。</li></ul></li></ul><h2 id=gr_adv_parallel>GR_Adv_Parallel
<a class=anchor href=#gr_adv_parallel>#</a></h2><h3 id=han-gpunetlevel-parallelism-iccad-2011---><a href=/zh/>han-GPU+netlevel parallelism-ICCAD-2011- -</a>
<a class=anchor href=#han-gpunetlevel-parallelism-iccad-2011--->#</a></h3><h3 id=vfgr-congestion-modeling-aspdac-2014><a href="https://ieeexplore-ieee-org-443.webvpn.scut.edu.cn/stamp/stamp.jsp?tp=&amp;arnumber=6742945">VFGR-congestion modeling-ASPDAC-2014&ndash;THU</a>
<a class=anchor href=#vfgr-congestion-modeling-aspdac-2014>#</a></h3><ul><li>net-level and region-level parallelization</li></ul><h3 id=cugr-3d-patternmulti-level-maze-routingpatching-dac-2020-cuhk><a href=https://github.com/cuhk-eda/cu-gr>CUGR-3D pattern+Multi level maze routing+patching-DAC-2020-CUHK</a>
<a class=anchor href=#cugr-3d-patternmulti-level-maze-routingpatching-dac-2020-cuhk>#</a></h3><ul><li><p>ICCAD 2019 Contest First Place</p></li><li><p><a href=https://github.com/cuhk-eda/cu-gr>open source!</a></p></li><li><p>3d+多线程+</p></li><li><p>这个文章没有讨论prefer direction</p></li><li><p>多线程体现在哪里？</p></li><li><p>注意：这种格式的GR输出可以适配Innovus</p></li><li><p>time-complexity of 3D pattern routing is $\mathcal{O}(L^4|V|)$</p><p>compare with [Trans-2008](#
<a href=https://ieeexplore-ieee-org-443.webvpn.scut.edu.cn/document/4603083>-Layer assignment+Via minization-Trans-2008-DP-NTHU</a>), CUGR reduces the complexity to $\mathcal{O}(L^4|V|)$ by selecting the root carefully so that each vertex will have at most three preceding vertices instead of four. <del>注意，这里说 相比[Trans-2008](#
<a href=https://ieeexplore-ieee-org-443.webvpn.scut.edu.cn/document/4603083>-Layer assignment+Via minization-Trans-2008-DP-NTHU</a>)的$\mathcal{O}(L^5|V|)$ ，它的复杂度是$\mathcal{O}(L^4|V|)$ ，感觉是放在了[Trans-2008](#
<a href=https://ieeexplore-ieee-org-443.webvpn.scut.edu.cn/document/4603083>-Layer assignment+Via minization-Trans-2008-DP-NTHU</a>)进行不转弯的DP-based layer assignment方法上了，实际上按照本文说的方法，理论上是$L * L^{2<em>3}|V|$，因为CUGR每次是对一个L pattern为单位计算<code>mvc</code>,时间复杂度是$2</em>L*L$</del>.确实是$L^4$, CUGR对一个L pattern分了两部分计算<code>mvc</code>没一部分时间复杂度是$L*2$</p></li></ul><h4 id=background-24>background
<a class=anchor href=#background-24>#</a></h4><p><img src=/image-20241122110742970.png alt=image-20241122110742970></p><ul><li>A common strategy of doing 3D global routing, as adopted by NCTU-GR 2.0 [5], NTHU-Route 2.0 [6], NTUgr [7] and FastRoute 4.0 [8], is to <strong>first compress the 3D grid graph into a 2D grid graph and perform 2D global routing</strong>.</li><li>directly route the nets in a 3D grid graph：FGR [10] , GRIP [11] , MGR [12]</li><li>Traditional pattern routing generates 2D topologies only, while <strong>our</strong> proposed 3D pattern routing directly generates 3D topologies without the need of an extra layer assignment stage</li><li>使用DR结果进行多角度metrics 评估：</li></ul><p><img src=/image-20241122113634633.png alt=image-20241122113634633></p><h4 id=task-12>task
<a class=anchor href=#task-12>#</a></h4><ul><li>detailed-routability-driven directly-3d multi thread GR</li></ul><h4 id=contibution>contibution
<a class=anchor href=#contibution>#</a></h4><ul><li>probability-based cost scheme<ul><li>minimizing the possibility of overflow after detailed routing</li></ul></li><li><code>3D pattern routing</code> technique (2D pattern routing + layer assignment)(前面又说directly in the 3D space?)<ul><li>without overflow even only L shape patten routing</li><li>pre-work[15] 是先在2d上进行pattern routing, 然后进行layer assignment, 这里是直接在3d进行pattern routing. 3d pattern routing can avoid loss of accuracy caused by compressing 3D grid graph to 2D</li></ul></li><li><code>multi-level maze routing</code>:<ul><li>coarsened level –> searches for a region with the <strong>best routability</strong>. <strong>first</strong> narrows the search space to a smaller region</li><li>fine-grained level –> searches for a <strong>lowest cost</strong> solution within the region</li></ul></li><li>patching mechanism<ul><li>further improve the detailed routability</li></ul></li></ul><h4 id=flow-11>flow
<a class=anchor href=#flow-11>#</a></h4><p><img src=/image-20241122123825463.png alt=image-20241122123825463></p><p>In <code>3D pattern routing</code> (<code>inital routing</code>), the nets are broken down into two-pin nets, and a <code>dynamic programming</code> based algorithm will route the two pin nets sequentially using Lshape patterns and <code>stacking vias</code> at the turns.</p><p>In the <code>multi-level 3D maze routing</code> phase, the grid graph is <code>coarsened</code> to shrink the routing space, and maze routing is first performed in the coarsened space with an objective to find a routing region with the <strong>highest routability</strong>. A <code>fine-grained maze routing</code> will then search for a lowest cost path within the region. use its <code>patching</code> mechanism here.</p><h4 id=model-14>model
<a class=anchor href=#model-14>#</a></h4><ul><li><p>Gcell之间的容量等于track，一般GR表征via的容量是无限的，但是在本文中不是</p></li><li><p><strong>three base definition:</strong></p><ul><li>resource = capacity - demand</li><li>这三个变量在GCell和wire_edge上都有特征，也就是说有6个值</li><li>resource 能够直接表示拥程度</li><li><img src=/image-20241122130729921.png alt=image-20241122130729921></li><li><img src=/image-20241122130736928.png alt=image-20241122130736928></li></ul></li><li><p><strong>cost scheme</strong></p><ul><li><p>主要分成wire和via两部分：</p><p><img src=/image-20241122130626631.png alt=image-20241122130626631></p></li><li><p>wire cost:</p><p><img src=/image-20241122130653693.png alt=image-20241122130653693></p><ol><li><p>*<code>wl</code>*is wire lenght cost</p></li><li><p><em><code>eo</code></em> is expected overflow cost, where <em><code>uoc</code></em> is hyper parameter, The larger <em><code>d(u, v)</code></em> is, the more likely it is to be congested. is accurate if the <strong>DR</strong> adopts the simplest strategy of picking a track <strong>randomly</strong> to route. However, most well designed detailed routers will do much better than random selection.</p></li><li><p><em><code>lg(u,v)</code></em> is a variable to refine <em><code>d(u, v)</code></em>. “+1” 是为了值域在（0，1）表示概率。 <em><code>slope</code></em> is hyper parameter. When the resources are abundant, there is almost <strong>no congestion cost</strong>, but the cost will increase rapidly as the resources are being used up and will keep increasing almost <strong>linearly</strong> after all the resources are used</p><p><img src=/image-20241122130807532.png alt=image-20241122130807532></p></li></ol></li><li><p>via cost:</p><ol><li>thanks to our <strong>3D pattern routing strategy</strong>, a via cost scheme can be embedded to reflect the impact.</li><li><img src=/image-20241122130701652.png alt=image-20241122130701652></li><li><em><code>uvc</code></em> is hyper parameter.</li><li>公式（5a）为什么要“+1”</li></ol></li></ul></li><li><p>Initial Routing / 3D Pattern Routing</p><ol><li><p>use <code>FLUTE</code> first (not congestion awared)</p></li><li><p>use <code>edge shifting</code> (described in
<a href=/zh/#[FastRoute1.0%e2%80%942006]%28%29>FastRoute</a>) to alleviate congestion.</p></li><li><p><strong>randomly</strong> choose one node in net, use DFS to get a queue and then get a DAG</p></li><li><p>类似[15]，动态规划选择cost最小的3d L pattern，每个L pattern有(2 * L * L)种可能</p><p><img src=/image-20250209165125803.png alt=image-20250209165125803></p><p>最后在root处得到最终的结果</p></li></ol></li><li><p>Multi-level 3D Maze Routing</p><ul><li><p>maze route planing</p><p>aims at finding a smaller but highly routable search space</p><ol><li><p>compress a block of G-cells (5x5 in our implementation), use avg to descripe <code>capacity, demand, resource</code></p></li><li><p>cost function:</p><p><img src=/image-20250209172954350.png alt=image-20250209172954350></p></li><li><p>得到灰色粗网格：</p><p><img src=/image-20250209173822187.png alt=image-20250209173822187></p></li><li><p>之后会在这几个BBox中分别进行计算<code>cost scheme</code>，得到上图黑色实线</p></li></ol></li><li><p>fine-grained maze routing within guides</p></li></ul></li><li><p>Postprocessing / Guide Patching</p><ul><li><p>we can add new guides to improve detailed routability. adding new stand-alone guides to alleviate routing hot spots.</p></li><li><p>three kind of patching:</p><ol><li><p>Pin Region Patching</p><ul><li><p>most effective</p></li><li><p>the ideal way of improving pin accessibility is to identify those hard-to-access pins and assign more resources to them</p><p><img src=/image-20250209191227014.png alt=image-20250209191227014></p></li><li><p>Our global router will check the upper (or lower) two layers of a pin, which are vital for accessing the pin. use 3 × 3 patching guides.</p></li><li><p>没写判断<code>hard-to-access pins </code>的具体的方法</p></li></ul></li><li><p>Long Segment Patching:</p><ul><li>a longer routing segment often means more wrong way wires and causing more congestion.</li><li>If a guide is longer than a specified length I, we’ll consider long segment patching.</li></ul><p><img src=/image-20250209191725644.png alt=image-20250209191725644></p><ul><li>if a G-cell with resource below a threshold T is encountered, a single G-cell route guide will be patched above or below it, depending on which of them has sufficient resource</li></ul></li><li><p>Violation Patching:</p><ul><li><p>For G-cell with inevitable violations, patching will be used again to enable the detailed router to search with more flexibility.</p><p><img src=/image-20250209192310471.png alt=image-20250209192310471></p></li><li></li></ul></li></ol></li></ul></li></ul><h4 id=data-12>data
<a class=anchor href=#data-12>#</a></h4><p>iccad 2019 dataset</p><h4 id=experiment-9>experiment
<a class=anchor href=#experiment-9>#</a></h4><p><img src=/image-20241122113716242.png alt=image-20241122113716242></p><p><img src=/image-20250209192916035.png alt=image-20250209192916035></p><ul><li><p>他自己又比赛后改进了</p></li><li><p><img src=/image-20250209195431218.png alt=image-20250209195431218></p></li><li><p>our algorithm’s peak memory is close to the first place and is 1.83 times of that of the second place on average (ours is 8.22 GB on average and is <strong>19.8 GB</strong> for</p><p>the biggest design)</p></li></ul><h3 id=sproute-20--detailed-routability-driven-asp-dac-2022-><a href=https://ieeexplore.ieee.org/abstract/document/9712557>SPRoute 2.0- detailed routability driven-ASP DAC-2022-</a>
<a class=anchor href=#sproute-20--detailed-routability-driven-asp-dac-2022->#</a></h3><ul><li><a href=https://github.com/asyncvlsi/SPRoute/tree/master>OpenSource!</a></li><li>2D</li><li>可以将guide文件输入到innovus?</li><li><code>soft capacity</code> The soft capacity is downsized from the hard capacity (number of available tracks), using the pin density and RUDY value of the region.</li><li><code>batch</code> for ==deterministic== net-level parallelization strategy</li><li><code>bulk-synchronously</code> maze-routes</li><li>baseline FLUTE, [FastRoute 4.0](#
<a href=/zh/>fastroute 4.0-via min tree+3 bending-ASPDAC-2009-</a>) for pattern routing, [CUGR](#
<a href=https://github.com/cuhk-eda/cu-gr>CUGR-3D pattern+Multi level maze routing+patching-DAC-2020-CUHK</a>)</li></ul><h4 id=background-25>background
<a class=anchor href=#background-25>#</a></h4><ul><li>In terms of parallelization, maze routing is widely used in global routing and ==is the most time-consuming stage== on hardto-route benchmarks.</li><li></li></ul><h4 id=contribution-15>contribution
<a class=anchor href=#contribution-15>#</a></h4><ul><li><code>soft capacity</code> to reserve space for detailed routability.</li><li>parallelize maze routing in a <code>deterministic bulk synchronous approach</code></li><li>design a <code>scheduler</code> for the deterministic parallel execution model</li></ul><h4 id=flow-12>flow
<a class=anchor href=#flow-12>#</a></h4><p><img src=/image-20250225114628773.png alt=image-20250225114628773></p><h4 id=model-15>model
<a class=anchor href=#model-15>#</a></h4><h5 id=soft-capacity>soft capacity
<a class=anchor href=#soft-capacity>#</a></h5><p><img src=/image-20250225120300741.png alt=image-20250225120300741></p><p><img src=/image-20250225120328607.png alt=image-20250225120328607></p><p><img src=/image-20250225120309420.png alt=image-20250225120309420></p><p>Different layers have different parameters for the ratio function since they are influenced by the congestion in different scales</p><h5 id=bulk-synchronous-deterministic-approach>bulk synchronous deterministic approach
<a class=anchor href=#bulk-synchronous-deterministic-approach>#</a></h5><p>就是分batch，all threads execute one batch of nets at a time</p><p>在批处理开始时，每个线程从批处理中获取一个网络，读取全局图的使用情况，并在其线程局部图中执行撕裂和重新路由。</p><p><img src=/image-20250225163426630.png alt=image-20250225163426630></p><p>还是看不太懂</p><h4 id=data-13>data
<a class=anchor href=#data-13>#</a></h4><p>ICCAD19 contest</p><h4 id=experiment-10>experiment
<a class=anchor href=#experiment-10>#</a></h4><h3 id=fastgr-gpu-pattern-routing-multi-thread-mazedate-2022-pkucuhkhnal><a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=9774606">FastGR-GPU pattern routing+ multi thread maze–DATE-2022-PKU+CUHK+HNAL</a>
<a class=anchor href=#fastgr-gpu-pattern-routing-multi-thread-mazedate-2022-pkucuhkhnal>#</a></h3><ul><li>GPU-accelerated</li><li>accelerated the 3D pattern routing algorithm of [CUGR](#
<a href=https://github.com/cuhk-eda/cu-gr>CUGR-3D pattern+Multi level maze routing+patching-DAC-2020-CUHK</a>) for initial routing by both <code>net-level</code> and <code>path-level</code> parallelization on GPU</li></ul><h3 id=gamer---trans-2022---><a href=/zh/>Gamer- -Trans-2022- -</a>
<a class=anchor href=#gamer---trans-2022--->#</a></h3><ul><li>GPU-accelerated</li><li>accelerated the two-level maze routing of [CUGR](#
<a href=https://github.com/cuhk-eda/cu-gr>CUGR-3D pattern+Multi level maze routing+patching-DAC-2020-CUHK</a>) for rip-up and reroute by updating vertical and horizontal routing costs alternatively on GPU</li></ul><h3 id=ggr-super-fast-gpu-accelerate-iccad-2022-><a href=https://github.com/cuhk-eda/Xplace/tree/main/cpp_to_py/gpugr>GGR-super fast gpu accelerate-ICCAD-2022-</a>
<a class=anchor href=#ggr-super-fast-gpu-accelerate-iccad-2022->#</a></h3><p>open source！
<a href=https://github.com/cuhk-eda/Xplace/tree/main/cpp_to_py/gpugr>Xplace/cpp_to_py/gpugr at main · cuhk-eda/Xplace</a></p><h4 id=background-26>background
<a class=anchor href=#background-26>#</a></h4><p><img src=/image-20241114223402627.png alt=image-20241114223402627></p><p><strong>Performance depends on the detail route</strong></p><p>Modern global routing problem, which was introduced at the 2019 CAD contest at ICCAD, targets at closing
the gap between global routing and detailed routing. The LEF/DEF files for detailed routing are directly used as the input for global routing.</p><p>The global routing quality is evaluated using an academic <strong>detailed router Dr. CU[8]</strong></p><p>2019 ICCAD contest on global routing did not directly evaluate global routing results based on overflows and total wirelength. The new evaluation uses the global routing results as route guides for a detailed router, and the metrics are all detailed routing related</p><p><strong>2D & 3D</strong></p><p>NCTU-GR 2.0[13], SPRoute[7] and FastRoute 4.0[14] are 2D GR</p><p>However, compressed 2D grid graphs are less accurate than 3D grid graphs in terms of routing resources, which could limit the global routing quality.</p><p>CUGR[11]. It has both 3D pattern routing and 3D maze routing</p><p><strong>multi-thread vs GPU</strong></p><p><img src=/image-20241114225533925.png alt=image-20241114225533925></p><p><img src=/image-20241114231041875.png alt=image-20241114231041875></p><p>LEF/DEF based academic global routers <strong>SPRoute 2.0[6]</strong> is the only 2D GR</p><p><strong>GAMER[10]</strong> is a novel parallel <strong>maze</strong> routing algorithm integrated in <strong>CUGR</strong>.</p><p><strong>FastGR[12]</strong> introduced <strong>GPU</strong> parallelization of <strong>L-shape pattern</strong> routing</p><h4 id=contribution-16>contribution
<a class=anchor href=#contribution-16>#</a></h4><p><img src=/image-20241114225935669.png alt=image-20241114225935669></p><h4 id=flow-13>flow
<a class=anchor href=#flow-13>#</a></h4><p><img src=/image-20241114230008749.png alt=image-20241114230008749></p><h4 id=data-14>data
<a class=anchor href=#data-14>#</a></h4><h4 id=model-16>model
<a class=anchor href=#model-16>#</a></h4><h3 id=cugr-20-dag-based-dac-2023---cuhk><a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=10247702">CUGR 2.0-DAG-based-DAC-2023- -CUHK</a>
<a class=anchor href=#cugr-20-dag-based-dac-2023---cuhk>#</a></h3><ul><li><a href=https://github.com/cuhk-eda/cu-gr-2>open source!</a></li></ul><h4 id=background-27>background
<a class=anchor href=#background-27>#</a></h4><ul><li>many of the aforementioned global routers is that most of them rely heavily on <strong>time-consuming path search algorithms</strong> like maze routing to resolve overflows. These approaches are not efficient enough even with parallilization and may cause lots of unnecessary detours</li></ul><h4 id=contribution-17>contribution
<a class=anchor href=#contribution-17>#</a></h4><ul><li><p>a <strong>DAG-based</strong> generalized pattern routing algorithm</p></li><li><p>a <strong>new</strong> <code>dynamic programming-based</code> algorithm to calculate the routing cost</p><p>time complexity from $\mathcal{O}(L^4|V|)$ to $\mathcal{O}(L^2|V|)$</p></li><li><p>a DAG <code>augmentation algorithm</code> that enables the creation of <strong>alternative paths</strong> in a routing DAG. can even shift or create Steiner points. over 99% nets can be successfully routed without the need of maze routing</p></li><li><p>a new <strong>sparse</strong> graph maze routing algorithm</p><p>creation of alternative paths in a</p><p>routing DAG</p></li></ul><h4 id=flow-14>flow
<a class=anchor href=#flow-14>#</a></h4><ol><li><p>RSMT</p><p><img src=/image-20250210142956411.png alt=image-20250210142956411></p></li><li><p>DFS and<code> Routing DAG</code> with L pattern</p><p>注意多了节点g,f,i,h, 现在每条都是直线</p><p><img src=/image-20250210143037337.png alt=image-20250210143037337></p><p><code>Routing DAG</code> with other patterns，但是在这里没用做初始布线，初始只用了L-shape。文章也就这里提了一下，后面都和这个无关，得去源码仔细看看。</p><p><img src=/image-20250210143529434.png alt=image-20250210143529434></p></li><li><p>Dynamic Programming-based DAG routing(L-shape + Layer assignment)</p><p>没说怎么舍弃的？</p></li><li><p>DAG-based pattern routing with <strong>augmentation</strong></p></li><li><p>sparse graph <strong>maze</strong> routing algorithm</p></li></ol><h4 id=model-17>model
<a class=anchor href=#model-17>#</a></h4><ul><li><p>cost</p><ul><li><p>Dynamic Programming-based</p><p><img src=/image-20250210203428984.png alt=image-20250210203428984></p></li><li><p>DAG Augmentation for Congestion</p><p><img src=/image-20250210203818643.png alt=image-20250210203818643></p><ol><li><p>create alternative paths</p><p><img src=/image-20250210204123847.png alt=image-20250210204123847></p></li><li><p>Steiner point movement</p><p>具体怎么移动的文章也没说</p></li></ol></li></ul></li></ul><h4 id=experiment-11>experiment
<a class=anchor href=#experiment-11>#</a></h4><ul><li><p>compare with CUGR [12] and SPRoute 2.0 [13]</p><p><img src=/image-20250210211951988.png alt=image-20250210211951988></p><p><img src=/image-20250210212311337.png alt=image-20250210212311337></p><p>only one thread for run time</p></li><li><p><img src=/image-20250210212636193.png alt=image-20250210212636193></p></li><li><p>Effectiveness of steiner point augmentation</p></li><li><p><img src=/image-20250210212920933.png alt=image-20250210212920933></p></li><li><p>run time compare with GPU-accelerated GR</p><ul><li><p>compare with FastGR [14] and GAMER [15]</p></li><li><p>GPU的好坏也有关系吧。本实验用的RTX 3090</p></li><li><p>slightly faster than FastGR for initial routing</p><p><img src=/image-20250210213728850.png alt=image-20250210213728850></p></li><li><p>around 5.2× as fast as GAMER</p><p><img src=/image-20250210215926150.png alt=image-20250210215926150></p></li></ul></li></ul><h3 id=instantgr-scalable-gpu-parallelization-iccad-2024-cuhk><a href=https://shijulin.github.io/files/1239_Final_Manuscript.pdf>InstantGR-Scalable GPU Parallelization-ICCAD-2024-CUHK</a>
<a class=anchor href=#instantgr-scalable-gpu-parallelization-iccad-2024-cuhk>#</a></h3><ul><li><a href=https://github.com/cuhk-eda/InstantGR>open source!</a></li><li>second place of ISPD25 contest</li><li>GPU Parallelization</li><li>parallel algorithm is mainly based on the DAG-based global routing algorithm in [CUGR2](#
<a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=10247702">CUGR2.0 EDGE- -DAC-2023-</a>). 应该是3D pattern routing DP的部分和maze routing的部分</li><li>parallel while do initial routing and RRR</li><li>提高了并行度，但是还是有串行的部分</li><li>也用了FLUTE</li><li>一定要以net为单元吗？是为了用DP</li><li></li></ul><h4 id=background-28>background
<a class=anchor href=#background-28>#</a></h4><ul><li>GPU memory is limited<ul><li>This requires memory-efficient solutions that can minimize CPU-GPU communication while maximizing GPU utilization</li><li>large designs have more nets with bigger routing graphs, providing many new parallelization opportunities that are not yet explored</li></ul></li><li>nets in a batch can be routed in parallel</li></ul><h4 id=task-13>task
<a class=anchor href=#task-13>#</a></h4><ul><li>parallelism for large-scale</li><li>partitioned design</li></ul><h4 id=contribution-18>contribution
<a class=anchor href=#contribution-18>#</a></h4><ul><li>a new method for <code>net-level batch generation</code>. based on 3D fine-grained overlap checking and explores more parallelism by increasing the number of nets per batch</li><li><code>node-level</code> parallel routing approach. achieves much higher parallelism compared to traditional net-level parallel routing.</li></ul><h4 id=flow-15>flow
<a class=anchor href=#flow-15>#</a></h4><ul><li>In initial routing, we construct a basic <code>routing DAG</code> to perform <strong>L-shape pattern routing</strong>.</li></ul><p><strong>key points</strong></p><p>specific explanation show in
<a href=/zh/docs/Digtal/Digtal/Routing/routing2/>routing2</a></p><ul><li><p>NET-LEVEL PARALLELISM</p><ul><li><p>simultaneous routing of a <code>batch</code> of nets that do not “<code>overlap</code>”</p></li><li><p>[2, 3, 14, 19, 20, 22, 26] 19年开始的，cugr2和fastgr都用了</p></li><li><p><strong>Typical</strong> Batch Generation Algorithm</p><p>used in [2, 3, 14, 19, 20]</p><p><img src=/image-20250212100127751.png alt=image-20250212100127751></p><p><code>R-trees </code>是实现<code>line 4</code>的常用做法</p><p><code>pessimistically approximates</code> significantly lowers the degree of parallelism</p></li><li><p>define and graph model</p><p><img src=/image-20250212111440550.png alt=image-20250212111440550></p><p><img src=/image-20250212100930831.png alt=image-20250212100930831></p><p>以<code>segment</code>为单位，同时分开了水平和垂直两个部分，假设全部为L-shape，同时对于不在一条线上的两个节点，有两个L</p><p>These four nets will be divided into just <code>one batch</code> based on our exact representation of routing graphs for overlap checking, while into <code>four batches</code> by the traditional bounding box-based pessimistic approximation</p><p>via model:</p><p><img src=/image-20250212110626674.png alt=image-20250212110626674></p><p><img src=/image-20250212104214378.png alt=image-20250212104214378></p><p>via用一个十字表示</p></li><li><p>Overlap Checking Algorithms</p><ol><li><p>以水平子图进行展示，垂直同理</p></li><li><p>以水平segment为单位进行checking</p></li><li><p>首先判断是不是y坐标相等：group the segments with the same 𝑦</p></li><li><p>tradictional algorithm:</p><p>This is a classical computational geometry problem that can be efficiently solved by <code>segment trees</code> [1] in 𝑂(log𝑛) time for both operations,</p><p><img src=/image-20250212114550426.png alt=image-20250212114550426></p></li><li><p>new algorithm motivation:</p><p><img src=/image-20250212114611742.png alt=image-20250212114611742></p><p>segments are very short</p></li><li><p>new algorithm: <code>Point Exhaustion</code></p><p>simply use a Boolean array to record whether each point in [1, 𝑛] is covered by some segment 𝑠 ∈ 𝑆. We mark every point 𝑥 ∈ [𝑙, 𝑟] when a segment [𝑙, 𝑟] is inserted, and check every point 𝑥 ∈ [𝑙𝑞, 𝑟𝑞] for overlap query of a segment [𝑙𝑞, 𝑟𝑞].</p><p>further improve the efficiency of this point exhaustion by using bit arrays</p></li><li><p>another improvement: <code>representative point exhaustion</code></p><ul><li>allowing a little bit of overlap.</li><li>it only checks the two end points of a query segment. ??什么意思</li><li>covering most overlap scenarios in practice.</li><li>The only scenario that this algorithm fails to find the overlap of two overlapping segments is when the query segment [𝑙𝑞,𝑟𝑞] contains the overlapping segment [𝑙,𝑟], [𝑙,𝑟] ⊂ [𝑙𝑞,𝑟𝑞]</li></ul></li></ol></li></ul></li><li><p>NODE-LEVEL PARALLELISM</p><p><img src=/image-20250212142040816.png alt=image-20250212142040816></p><ul><li><p>还是以net为单位分到不同的batch？</p></li><li><p>routing nodes of the same depth in parallel</p><p><img src=/image-20250212143816082.png alt=image-20250212143816082></p><p>Suppose we have 4 nets, Net A, B, C and D in our grid graph. Since nets with overlap cannot be routed together, Net A and B are distributed to batch 0, as shown in Figure 7a, and nets C and D are distributed to batch 1.</p><p><img src=/image-20250212143140834.png alt=image-20250212143140834></p></li></ul></li></ul><h4 id=experiment-12>experiment
<a class=anchor href=#experiment-12>#</a></h4><ul><li><p>4 NVIDIA A800 GPUs and 8 CPU threads.</p></li><li><p>compare different overlap checking methods</p><p><img src=/image-20250212145328644.png alt=image-20250212145328644></p><p>The number of nets per batch is limited to 1000</p></li><li><p>compare 2 largest benchmark</p><p><img src=/image-20250212154458440.png alt=image-20250212154458440></p></li><li><p>compare with Top-3 Global Routers of ISPD2024 Contest</p><p><img src=/image-20250212161238221.png alt=image-20250212161238221></p></li><li><p>Runtime (s) of DAG-Based Augmented Routing with and without Node-Level Parallelism</p><p><img src=/image-20250212161314333.png alt=image-20250212161314333></p><p>acceleration 那一行好像是加速倍率才对</p></li></ul><h3 id=helem-gr-heterogeneouslinearized-exponential-multiplier-method-iccad-2024---pek><a href=/zh/>HeLEM-GR-Heterogeneous+Linearized Exponential Multiplier Method-ICCAD-2024- -PEK</a>
<a class=anchor href=#helem-gr-heterogeneouslinearized-exponential-multiplier-method-iccad-2024---pek>#</a></h3><ul><li>first place of ISPD25 contest</li><li>not open source 2025/2/6</li><li>2D routing algorithm</li></ul><p>background</p><h4 id=contribution-19>contribution:
<a class=anchor href=#contribution-19>#</a></h4><ul><li><code>LEM</code>(linearized exponential multiplier) method for ==2D routing problem== to minimize wirelength and overflow. This LEM framework is ==general to integrate any routing kernels.==</li><li><code>batched routing kernels</code> including ==L shape and 3-bend routing== for GPU parallelization.</li><li><code>sweep operations</code> for GPU-accelerated layer assignment.</li><li></li></ul><h4 id=flow-16>flow
<a class=anchor href=#flow-16>#</a></h4><p><img src=/image-20250225103529314.png alt=image-20250225103529314></p><ul><li>preparation<ul><li>run on CPU</li><li>use FLUTE</li><li>use<code> SPRoute 2.0</code> to compact 3D graph to 2D graph</li></ul></li><li>2D routing<ul><li>run on GPU</li></ul></li><li>layer assignment<ul><li>run on GPU</li></ul></li></ul><h2 id=rsmt>RSMT
<a class=anchor href=#rsmt>#</a></h2><h3 id=flute-----2008---><a href=/zh/>FLUTE- - -2008- -</a>
<a class=anchor href=#flute-----2008--->#</a></h3><p>FLUTE is an RSMT construction algorithm adopting a look-up table approach, which is both fast and optimal for low-degree nets. However, FLUTE is unaware of routing <strong>congestion</strong>.</p><p><img src=/image-20241116114652698.png alt=image-20241116114652698></p><p>下面是一系列FLUTE和基于FLUTE的改进</p><p><img src=/image-20241116114634422.png alt=image-20241116114634422></p><h3 id=-obstacle-avoiding-iscas-2024><a href="https://ieeexplore-ieee-org-443.webvpn.scut.edu.cn/stamp/stamp.jsp?tp=&amp;arnumber=10558430">-Obstacle avoiding-ISCAS-2024&ndash;SYSU</a>
<a class=anchor href=#-obstacle-avoiding-iscas-2024>#</a></h3><h3 id=-gpu-accelerated-iccad-2022><a href="https://ieeexplore-ieee-org-443.webvpn.scut.edu.cn/stamp/stamp.jsp?tp=&amp;arnumber=10069158">-GPU-Accelerated-ICCAD-2022&ndash;PEK</a>
<a class=anchor href=#-gpu-accelerated-iccad-2022>#</a></h3><ul><li>first GPU-accelerated RSMT generation algorithm</li><li></li></ul><h4 id=background-29>background
<a class=anchor href=#background-29>#</a></h4><ul><li><p>Rectilinear Steiner minimum tree (RSMT) generation is a fundamental component in the VLSI design automation flow. Due to its extensive usage in circuit design iterations at early design stages like ==synthesis, placement, and routing==, the performance of RSMT generation is critical for a reasonable design turnaround time.</p></li><li><p>previous work are CPU-based</p></li><li><p>在GPU上加速RSMT生成是一项重要但极具挑战性的任务，主要原因在于其复杂的、非平凡(non-trivial)的分治(divide-and-conquer)计算模式与递归操作。</p></li><li><p>NP-completeness of RSMT generation &ndash;cite&ndash;>[1]</p></li><li><p>the current most efficient and widely-adopted heuristic is FLUTE [9],</p></li><li><p>Although most of the nets in a typical circuit design have only a small degree (≤ 9), larger nets are exponentially harder to solve</p><p><img src=/image-20250225234107526.png alt=image-20250225234107526></p></li><li><p>RSMT algorithms, such as FLUTE, are based on a ==divide-and-conquer== strategy with deep recursions, which are impossible to be executed on GPU threads with very limited stack memory</p></li><li><p>The sizes of nets in a circuit netlist are ==highly uneven==, from 2-pin nets to nets with 40 pins or more, which leads to an extremely ==imbalanced workload== and harms the parallelism.</p></li></ul><h4 id=contribution-20>contribution
<a class=anchor href=#contribution-20>#</a></h4><ul><li>propose a <code>levelized task decomposition strategy</code><ul><li>ensures a balanced workload and enables high-performance data parallelism</li></ul></li><li>a algorithmic transforms<ul><li>eliminate the recursion patterns of FLUTE</li></ul></li><li>GPU-efficient kernels</li></ul><h2 id=dr-outdated>DR outdated
<a class=anchor href=#dr-outdated>#</a></h2><h3 id=drcu><a href=/zh/>DRCU</a>
<a class=anchor href=#drcu>#</a></h3><ul><li>academic DR</li></ul><h2 id=dr-adv>DR adv
<a class=anchor href=#dr-adv>#</a></h2><h1 id=toread>toread
<a class=anchor href=#toread>#</a></h1><h3 id=dgr---dac-2024><a href=https://dl-acm-org-443.webvpn.scut.edu.cn/doi/pdf/10.1145/3649329.3656530>DGR- -DAC-2024&ndash;CMU+NVIDA</a>
<a class=anchor href=#dgr---dac-2024>#</a></h3><ul><li><a href=/zh/>OpenSource!</a></li></ul><h3 id=a_><a href="https://ieeexplore-ieee-org-443.webvpn.scut.edu.cn/stamp/stamp.jsp?tp=&amp;arnumber=9835675">A_Simple_Fast_and_GPU-friendly_Steiner-Tree_Heuristic</a>
<a class=anchor href=#a_>#</a></h3><h3 id=timing-driven-routing-iccad-2023-ustc><a href="https://ieeexplore-ieee-org-443.webvpn.scut.edu.cn/stamp/stamp.jsp?tp=&amp;arnumber=10323981">Timing-Driven Routing-ICCAD-2023-USTC</a>
<a class=anchor href=#timing-driven-routing-iccad-2023-ustc>#</a></h3><h3 id=timing-iccad-2024_><a href=..%5c..%5c..%5cDownload%5cTIMING_ICCAD2024_Guo.pdf>TIMING-ICCAD-2024_Guo</a>
<a class=anchor href=#timing-iccad-2024_>#</a></h3><h3 id=gpu-accelerated_><a href="https://ieeexplore-ieee-org-443.webvpn.scut.edu.cn/stamp/stamp.jsp?tp=&amp;arnumber=9256516">GPU-Accelerated_Static_Timing_Analysis</a>
<a class=anchor href=#gpu-accelerated_>#</a></h3><h1 id=综述>综述
<a class=anchor href=#%e7%bb%bc%e8%bf%b0>#</a></h1><h2 id=ml4pr>ML4PR
<a class=anchor href=#ml4pr>#</a></h2><p><a href=https://blog.csdn.net/SP_FA/article/details/134063224>Towards Machine Learning for Placement and Routing in Chip Design: a Methodological Overview</a></p><p><img src=/image-20241101173512416.png alt=image-20241101173512416></p><p>放置和布线是两个不可或缺且具有挑战性的 NP-hard 问题</p><p>机器学习凭借其数据驱动的性质显示出了广阔的前景，它可以减少对知识和先验的依赖，并且通过其先进的计算范式具有更大的可扩展性 (例如 GPU 加速的深度网络)</p><p><strong>挑战:</strong></p><p>placement:</p><ul><li>在路由完成之前，无法评估诸如可达性之类的放置目标；因此，在优化循环中可能需要花费数小时才能获得反馈，这对于进行数千次查询来说是负担不起的</li><li>现代的放置器需要在几个小时内处理数万个宏和数百万个标准单元。这种可扩展性的要求仍然超出了现有 ML 方法的能力</li></ul><p>routing:</p><ul><li>在公平的比较下，现有技术很难在效率和求解质量上系统地优于经典布线算法</li><li>大多数基于学习的技术在具有数千个网络的小型电路上工作得很好，而实际的布线引擎需要在超大型 3D 网格图 ( > 1000 × 1000 × 10 ) (> 1000 × 1000 × 10)(>1000×1000×10) 上有效地处理数百万个网络并产生高质量的解决方案</li></ul><p>相关工作</p><ul><li><p>placement</p><ul><li><img src=/image-20241101175552665.png alt=image-20241101175552665></li><li><img src=/image-20241101175600184.png alt=image-20241101175600184></li><li><img src=/image-20241101175612168.png alt=image-20241101175612168></li></ul></li><li><p>Routing</p><ul><li><p><img src=/image-20241101175915691.png alt=image-20241101175915691></p><p><img src=/image-20241101175922593.png alt=image-20241101175922593></p><p><img src=/image-20241101175934137.png alt=image-20241101175934137></p></li><li><p><img src=/image-20241101180007732.png alt=image-20241101180007732></p></li><li><p><img src=/image-20241101180029509.png alt=image-20241101180029509></p></li></ul></li></ul><h2 id=超大规模集成电路布线算法综述>超大规模集成电路布线算法综述
<a class=anchor href=#%e8%b6%85%e5%a4%a7%e8%a7%84%e6%a8%a1%e9%9b%86%e6%88%90%e7%94%b5%e8%b7%af%e5%b8%83%e7%ba%bf%e7%ae%97%e6%b3%95%e7%bb%bc%e8%bf%b0>#</a></h2><p><a href=https://www.sciengine.com/MNEIM/doi/10.19816/j.cnki.10-1594/TN.2021.02.086>超大规模集成电路布线算法综述</a></p><h4 id=background-30>background
<a class=anchor href=#background-30>#</a></h4><p><img src=/image-20241116095906162.png alt=image-20241116095906162></p><p><img src=/image-20241116095924293.png alt=image-20241116095924293></p><p><img src=/image-20241116095932126.png alt=image-20241116095932126></p><p>布线相关详细看routing2.md, 详细布线、面向可制造性设计的布线算法 还没记录</p><h2 id=edagnn>EDA+GNN
<a class=anchor href=#edagnn>#</a></h2><p>详细看
<a href=.%5cnotebak%5cEDA+GNN.md>A Comprehensive Survey on Electronic Design Automation and Graph Neural Networks</a></p><h1 id=参考>参考
<a class=anchor href=#%e5%8f%82%e8%80%83>#</a></h1><ol><li>[AI技术带给EDA的机遇和挑战](AI技术带给EDA的机遇和挑战-Yibo Lin.pdf)</li><li>[Towards Machine Learning for Placement and Routing in Chip Design: a Methodological Overview]([
<a href=https://blog.csdn.net/SP_FA/article/details/134063224>读论文] Towards Machine Learning for Placement and Routing in Chip Design: a Methodological Overview_toward machine learning&mldr;.lake-CSDN博客</a>)</li><li><a href=https://blog.csdn.net/sxf1061700625/article/details/127865492>【阅读】A Comprehensive Survey on Electronic Design Automation and Graph Neural Networks——EDA+GNN综述翻译_ppaml-CSDN博客</a></li></ol><h1 id=bak>bak
<a class=anchor href=#bak>#</a></h1><p><a href=/zh/>CongestionNet-Congestion Prediction-IFIP-2019-GNN</a></p><p><a href=/zh/>-placement Congestion prediction-arXiv-2021-GNN</a></p><p><img src=/image-20241101171055570.png alt=image-20241101171055570></p><p>输入：网表</p><p>输出：congestion at placement stage</p><p><a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=10528675">EDA-ML: Graph Representation LearningFramework for Digital IC Design Automation</a></p><p>德雷塞尔大学电气与计算机工程系 Pratik Shrestha和Ioannis Savidis</p><h4 id=background-31>background
<a class=anchor href=#background-31>#</a></h4><p>VLSI : traditional methodologies -> ML,Graph representation learning ability to capture complex relationships in graph-structured data</p><p>GNN：</p><p><img src=/image-20241116142013379.png alt=image-20241116142013379></p><p><img src=/image-20241116142052562.png alt=image-20241116142052562></p><h4 id=task-14>task
<a class=anchor href=#task-14>#</a></h4><p><img src=/image-20241116143449696.png alt=image-20241116143449696></p><h4 id=flow-17>flow
<a class=anchor href=#flow-17>#</a></h4><p><img src=/image-20241116144708326.png alt=image-20241116144708326></p><h4 id=data-15>data
<a class=anchor href=#data-15>#</a></h4><p><img src=/image-20241116155309167.png alt=image-20241116155309167></p><p><img src=/image-20241116143927933.png alt=image-20241116143927933></p><p><img src=/image-20241116155354597.png alt=image-20241116155354597></p><p><strong>模型</strong></p><p><img src=/image-20241116155947525.png alt=image-20241116155947525></p><p><img src=/image-20241116155857412.png alt=image-20241116155857412></p><p><strong>实验</strong></p><p><img src=/image-20241116160529100.png alt=image-20241116160529100></p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/alex-shpak/hugo-book/commit/558fe9e6a91fcab8fceb5cf8e0e72df4b2de59b9 title='最后修改者 pxhg02 | 二月 26, 2025' target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt>
<span>二月 26, 2025</span></a></div><div><a class="flex align-center" href=https://github.com/alex-shpak/hugo-book/edit/main/exampleSite/content.zh/docs/Digtal/Digtal/flow/EDA4PR-Digtal.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt>
<span>编辑本页</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#cross-stage-prediction>Cross-Stage Prediction</a><ul><li><a href=#congestion>congestion</a><ul><li><a href=#background>background</a></li><li><a href=#routenet-drc-hotspot-prediction-iccad-2018-cnn><a href=https://zhiyaoxie.com/files/ICCAD18_RouteNet.pdf>RouteNet-DRC Hotspot Prediction-ICCAD-2018-CNN</a></a></li><li><a href=#congestionnet-predict-congestion-hotspots-ifip-2019-gnngat-nvidia><a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=8920342&amp;tag=1">CongestionNet-predict congestion hotspots-IFIP-2019-GNN(GAT)-nvidia</a></a></li><li><a href=#-congestion-prediction--embedding--matrix-factorization--partition-arxiv-2021-gnnsage-><a href>-Congestion prediction + embedding + matrix factorization + partition-arXiv-2021-GNN(Sage)-</a></a></li><li><a href=#pgnn-drvs-predictionpin-proximity-graph-iccad-2022-gnnunetcnn-korea><a href>PGNN-DRVs prediction+Pin Proximity Graph-ICCAD-2022-GNN+UNet(CNN)-Korea</a></a></li><li><a href=#lhnn-congestionprediction-dac-2022-gnn-cuhkhuaweiyibolin><a href>LHNN-CongestionPrediction-DAC-2022-GNN-CUHK+Huawei+YiboLin</a></a></li><li><a href=#-nn-robustness-improve-arxiv-2024---uc-><a href>-NN Robustness improve-arXiv-2024- -UC-</a></a></li></ul></li><li><a href=#timing>Timing</a><ul><li><a href=#background-6>background</a></li><li><a href=#timinggcn-sta-prediction-dac-2022-gnn><a href=https://dl.acm.org/doi/abs/10.1145/3489517.3530597>TimingGCN-STA prediction-DAC-2022-GNN</a></a></li><li><a href=#multimodal-fusion-restructure-tolerantcnnendpoint-wise-masking4layout--dac-2023-gnncnn-7nm-riscvdmynotesedatimingmultimodal-fusion-pre-route-timing-prediction-dac-2023-gnn-7nm-riscvpdf>[Multimodal Fusion-Restructure tolerant+CNN+Endpoint-wise Masking4Layout -DAC-2023-GNN+CNN-7nm RISCV](D:\MyNotes\EDA\Timing\Multimodal Fusion-Pre Route Timing Prediction-DAC-2023-GNN-7nm RISCV.pdf)</a></li></ul></li></ul></li><li><a href=#optimization>Optimization</a><ul><li><a href=#timing-1>Timing</a><ul><li><a href=#tsteiner---steiner-points-opt-dac-2023-gnn-cuhk><a href>TSteiner - Steiner Points Opt-DAC-2023-GNN-CUHK</a></a></li></ul></li><li><a href=#placement>Placement</a><ul><li><a href=#-pin-accessibilitydrv-prediction-dac-2019-cnn-ntu><a href>-Pin Accessibility+DRV prediction-DAC-2019-CNN-NTU</a></a></li><li><a href=#-pin-accessibilityactiv-ispd-2020---ntusynopsys><a href=https://pdfs.semanticscholar.org/47f1/5e9fa283faddb8a6853398145d33e2ba9ae1.pdf>-Pin Accessibility+activ-ISPD-2020- -NTU+Synopsys</a></a></li><li><a href=#placement-optimization-with-deep-reinforcement-learning---ispd-2020-rlgnn-google><a href=%5Bdl.acm.org/doi/pdf/10.1145/3372780.3378174%5D(https://dl.acm.org/doi/pdf/10.1145/3372780.3378174)>Placement Optimization with Deep Reinforcement Learning- -ISPD-2020-RL+GNN-Google</a></a></li><li><a href=#pl-gnn-affinity-aware-for-icc2--ispd-2021-gnn-atlanta><a href=https://dl.acm.org/doi/pdf/10.1145/3439706.3447045>PL GNN-Affinity Aware for ICC2- ISPD-2021-GNN-Atlanta</a></a></li><li><a href=#-innovus-ppa-placement-optimize-neurips-2021-rl><a href=https://www.semanticscholar.org/paper/A-General-Framework-For-VLSI-Tool-Parameter-with-Agnesina-Pentapati/30c644ffa213418182e795ea5e8132cb15e891c2>-Innovus PPA placement optimize-Neurips-2021-RL</a></a></li><li><a href=#-gp-routability-opt-dac-2021-fcn-cuhksitingliu-beiyuyibo-lin><a href>-GP Routability Opt-DAC-2021-FCN-CUHK(SitingLiu BeiYu)+Yibo Lin</a></a></li></ul></li><li><a href=#gr>GR</a><ul><li><a href=#pros-routability-optimization-iccad-2020-fcn-cnhkcadence><a href>PROS-Routability Optimization-ICCAD-2020-FCN-CNHK+Cadence</a></a></li><li><a href=#pros-20---routability-optroute-wl-estimation-trans-2023-cnn-cnhkcadence><a href>PROS 2.0 - Routability Opt+Route WL estimation-Trans-2023-CNN-CNHK+Cadence</a></a></li><li><a href=#dr>DR</a></li><li><a href=#-detailed-router-date-2021-rl><a href=https://ieeexplore.ieee.org/document/9474007>-Detailed Router-DATE-2021-RL</a></a></li><li><a href=#dprouter-detail-routingpackage-design-optnet-order-decision-aspadc-2023-rlmarl-diagonally-routedmynotesedaroutingdprouter-detail-routingpackage-design-optnet-order-decision-aspadc-2023-rlmarl-diagonally-routepdf>[DPRouter-Detail Routing(package design) Opt+net order decision-ASPADC-2023-RL(MARL)-diagonally route](&ldquo;D:\MyNotes\EDA\Routing\DPRouter-Detail Routing(package design) Opt+net order decision-ASPADC-2023-RL(MARL)-diagonally route.pdf&rdquo;)</a></li><li><a href=#-detail-routingmatchopt-ispd-2023-rlgnn-finfet><a href>-Detail routing+match+Opt-ISPD-2023-RL+GNN-FinFET</a></a></li></ul></li></ul></li><li><a href=#pr-tools>PR Tools</a><ul><li><a href=#placer>Placer</a><ul><li><a href=#chip-placement-with-deep-reinforcement-learning-marcro-arxiv-2020-rl><a href=https://arxiv.org/pdf/2004.10746>Chip Placement with Deep Reinforcement Learning-marcro-arXiv-2020-RL</a></a></li><li><a href=#differentiable-timing-driven-global-placement-global-placement-dac-2022-gnn-><a href=https://dl.acm.org/doi/pdf/10.1145/3489517.3530486>Differentiable-Timing-Driven Global Placement-global placement-DAC-2022-GNN-</a></a></li><li><a href=#polar-20><a href=https://ieeexplore.ieee.org/document/6881450>Polar 2.0</a></a></li><li><a href=#deepplace><a href=https://github.com/PKUterran/DeepPlace>DeepPlace</a></a></li><li><a href=#replace><a href=https://ieeexplore.ieee.org/abstract/document/8418790>RePlAce&ndash;TCAD-2018-</a></a></li><li><a href=#dreamplace-gp-dactcadiccaddate-2019><a href=https://github.com/limbo018/DREAMPlace>DREAMPlace-GP-DAC+TCAD+ICCAD+DATE-2019~2023</a></a></li></ul></li><li><a href=#gr_outdated>GR_outdated</a><ul><li><a href=#fastroute102006><a href>FastRoute1.0—2006</a></a></li><li><a href=#fastroute-20-monotonic2007><a href>fastroute 2.0-Monotonic–2007</a></a></li><li><a href=#fastroute-30-virtual-capacity-iccad-2008-><a href>fastroute 3.0-virtual capacity-ICCAD-2008-</a></a></li><li><a href=#fastroute-40-via-min-tree3-bending-aspdac-2009-><a href>fastroute 4.0-via min tree+3 bending-ASPDAC-2009-</a></a></li><li><a href=#maizerouter-><a href>MaizeRouter-</a></a></li><li><a href=#boxrouter-10><a href>BoxRouter 1.0</a></a></li><li><a href=#fgr-3d-tcad-2008-><a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=4526750">FGR-3d-TCAD-2008-</a></a></li><li><a href=#-layer-assignmentvia-minization-trans-2008-dp-nthu><a href=https://ieeexplore-ieee-org-443.webvpn.scut.edu.cn/document/4603083>-Layer assignment+Via minization-Trans-2008-DP-NTHU</a></a></li><li><a href=#grip-3dip-dac-2009><a href=https://dl.acm.org/doi/pdf/10.1145/1629911.1629999>GRIP-3d+IP-DAC-2009</a></a></li><li><a href=#fastroute41-an-efficient-and-high-quality-global-router-2012><a href=https://home.engineering.iastate.edu/~cnchu/pubs/j52.pdf>FastRoute4.1-an efficient and high-quality global router-2012</a></a></li><li><a href=#nthu-route-10---tvlsi-2010-><a href=https://ieeexplore.ieee.org/document/5703167>NTHU Route 1.0- -TVLSI-2010-</a></a></li><li><a href=#nthu-route-20---tcad-2013><a href=https://ieeexplore.ieee.org/document/6504553>NTHU Route 2.0- -TCAD-2013</a></a></li><li><a href=#nctu-gr-10-3d-congestion-relaxed-layer-assignment--2011-><a href=https://ieeexplore.ieee.org/document/5703167>NCTU GR 1.0-3D-congestion relaxed layer assignment- 2011-</a></a></li><li><a href=#nctu-gr-20-multithreaded-collision-aware--cad-2013-><a href=https://ieeexplore.ieee.org/document/6504553>NCTU GR 2.0-Multithreaded Collision Aware- CAD-2013-</a></a></li><li><a href=#boxrouter-20><a href>BoxRouter 2.0</a></a></li><li><a href=#ogre--new-cost-function---2019---><a href=https://woset-workshop.github.io/PDFs/2019/a18.pdf>OGRE- new cost function- -2019- -</a></a></li><li><a href=#sproute-10-a-scalable-parallel-negotiation-based-global-router-iccad-2019><a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=8942105">SPRoute 1.0: A Scalable Parallel Negotiation-based Global Router-ICCAD-2019</a></a></li></ul></li><li><a href=#gr_adv_rl>GR_Adv_RL</a><ul><li><a href=#-drl-method-2019-drl-><a href=https://arxiv.org/pdf/1906.08809>-DRL method-2019-DRL-</a></a></li><li><a href=#-drl-arxiv-2021-jp><a href=https://arxiv.org/pdf/2010.09465>-DRL-arxiv-2021-JP</a></a></li><li><a href=#---wcmc-2023-drl-fuzhouu-genggeng-liu><a href=https://onlinelibrary.wiley.com/doi/epdf/10.1155/2023/6593938>- -WCMC-2023-DRL-FuZhouU-Genggeng Liu</a></a></li><li><a href=#-drlsegment-based-iseda-2023-drlgnn-pek><a href=https://ieeexplore.ieee.org/abstract/document/10218371>-DRL+segment based-ISEDA-2023-DRL+GNN-PEK</a></a></li><li><a href=#---apccas-2024-drlddqn-cycu><a href="https://ieeexplore-ieee-org-443.webvpn.scut.edu.cn/stamp/stamp.jsp?tp=&amp;arnumber=10808325">- -APCCAS-2024-DRL(DDQN)-CYCU</a></a></li></ul></li><li><a href=#gr_adv_gen>GR_Adv_Gen</a><ul><li><a href=#-generative-arxiv-2019-cnn-><a href=https://arxiv.org/pdf/1706.08948>-generative-arXiv-2019-CNN-</a></a></li><li><a href=#-only-cnn-dac-2020-cnnvae-><a href="https://ieeexplore-ieee-org-443.webvpn.scut.edu.cn/stamp/stamp.jsp?tp=&amp;arnumber=9218598">-only CNN-DAC-2020-CNN(VAE)-</a></a></li><li><a href=#prnet---neurips-2022---sjtunoahs-ark><a href>PRNet- -NeurIPS-2022- -SJTU+Noah’s Ark</a></a></li><li><a href=#hubrouter-generative-model-neurips-2023-ganrl-sjtu><a href>HubRouter-generative model-NeurIPS-2023-GAN+RL-SJTU</a></a></li></ul></li><li><a href=#gr_adv_parallel>GR_Adv_Parallel</a><ul><li><a href=#han-gpunetlevel-parallelism-iccad-2011---><a href>han-GPU+netlevel parallelism-ICCAD-2011- -</a></a></li><li><a href=#vfgr-congestion-modeling-aspdac-2014><a href="https://ieeexplore-ieee-org-443.webvpn.scut.edu.cn/stamp/stamp.jsp?tp=&amp;arnumber=6742945">VFGR-congestion modeling-ASPDAC-2014&ndash;THU</a></a></li><li><a href=#cugr-3d-patternmulti-level-maze-routingpatching-dac-2020-cuhk><a href=https://github.com/cuhk-eda/cu-gr>CUGR-3D pattern+Multi level maze routing+patching-DAC-2020-CUHK</a></a></li><li><a href=#sproute-20--detailed-routability-driven-asp-dac-2022-><a href=https://ieeexplore.ieee.org/abstract/document/9712557>SPRoute 2.0- detailed routability driven-ASP DAC-2022-</a></a></li><li><a href=#fastgr-gpu-pattern-routing-multi-thread-mazedate-2022-pkucuhkhnal><a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=9774606">FastGR-GPU pattern routing+ multi thread maze–DATE-2022-PKU+CUHK+HNAL</a></a></li><li><a href=#gamer---trans-2022---><a href>Gamer- -Trans-2022- -</a></a></li><li><a href=#ggr-super-fast-gpu-accelerate-iccad-2022-><a href=https://github.com/cuhk-eda/Xplace/tree/main/cpp_to_py/gpugr>GGR-super fast gpu accelerate-ICCAD-2022-</a></a></li><li><a href=#cugr-20-dag-based-dac-2023---cuhk><a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=10247702">CUGR 2.0-DAG-based-DAC-2023- -CUHK</a></a></li><li><a href=#instantgr-scalable-gpu-parallelization-iccad-2024-cuhk><a href=https://shijulin.github.io/files/1239_Final_Manuscript.pdf>InstantGR-Scalable GPU Parallelization-ICCAD-2024-CUHK</a></a></li><li><a href=#helem-gr-heterogeneouslinearized-exponential-multiplier-method-iccad-2024---pek><a href>HeLEM-GR-Heterogeneous+Linearized Exponential Multiplier Method-ICCAD-2024- -PEK</a></a></li></ul></li><li><a href=#rsmt>RSMT</a><ul><li><a href=#flute-----2008---><a href>FLUTE- - -2008- -</a></a></li><li><a href=#-obstacle-avoiding-iscas-2024><a href="https://ieeexplore-ieee-org-443.webvpn.scut.edu.cn/stamp/stamp.jsp?tp=&amp;arnumber=10558430">-Obstacle avoiding-ISCAS-2024&ndash;SYSU</a></a></li><li><a href=#-gpu-accelerated-iccad-2022><a href="https://ieeexplore-ieee-org-443.webvpn.scut.edu.cn/stamp/stamp.jsp?tp=&amp;arnumber=10069158">-GPU-Accelerated-ICCAD-2022&ndash;PEK</a></a></li></ul></li><li><a href=#dr-outdated>DR outdated</a><ul><li><a href=#drcu><a href>DRCU</a></a></li></ul></li><li><a href=#dr-adv>DR adv</a></li></ul></li><li><a href=#toread>toread</a><ul><li><ul><li><a href=#dgr---dac-2024><a href=https://dl-acm-org-443.webvpn.scut.edu.cn/doi/pdf/10.1145/3649329.3656530>DGR- -DAC-2024&ndash;CMU+NVIDA</a></a></li><li><a href=#a_><a href="https://ieeexplore-ieee-org-443.webvpn.scut.edu.cn/stamp/stamp.jsp?tp=&amp;arnumber=9835675">A_Simple_Fast_and_GPU-friendly_Steiner-Tree_Heuristic</a></a></li><li><a href=#timing-driven-routing-iccad-2023-ustc><a href="https://ieeexplore-ieee-org-443.webvpn.scut.edu.cn/stamp/stamp.jsp?tp=&amp;arnumber=10323981">Timing-Driven Routing-ICCAD-2023-USTC</a></a></li><li><a href=#timing-iccad-2024_><a href=......%5CDownload%5CTIMING_ICCAD2024_Guo.pdf>TIMING-ICCAD-2024_Guo</a></a></li><li><a href=#gpu-accelerated_><a href="https://ieeexplore-ieee-org-443.webvpn.scut.edu.cn/stamp/stamp.jsp?tp=&amp;arnumber=9256516">GPU-Accelerated_Static_Timing_Analysis</a></a></li></ul></li></ul></li><li><a href=#综述>综述</a><ul><li><a href=#ml4pr>ML4PR</a></li><li><a href=#超大规模集成电路布线算法综述>超大规模集成电路布线算法综述</a><ul><li></li></ul></li><li><a href=#edagnn>EDA+GNN</a></li></ul></li><li><a href=#参考>参考</a></li><li><a href=#bak>bak</a><ul><li><ul><li></li></ul></li></ul></li></ul></nav></div></aside></main></body></html>