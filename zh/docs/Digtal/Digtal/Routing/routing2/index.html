<!doctype html><html lang=zh dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="
  简介
  #


  GR & DR
  #

Routing is a critical yet complex phase in the implementation process of integrated circuits (ICs), often necessitating considerable time and effort. Given its complexity, the routing process is typically divided into two stages: global routing and detailed routing. Global routing, the initial stage, establishes coarse-grained wire paths for signal nets, thereby providing valuable guidance for the subsequent detailed routing stage, enhancing its efficiency. Detailed routing, on the other hand, focuses on identifying valid physical paths, primarily within the routing guides set by global routing, while taking into account design rule constraints"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://pxgh02.github.io/zh/docs/Digtal/Digtal/Routing/routing2/"><meta property="og:site_name" content="Pxmmmm"><meta property="og:title" content="Routing"><meta property="og:description" content="简介 # GR & DR # Routing is a critical yet complex phase in the implementation process of integrated circuits (ICs), often necessitating considerable time and effort. Given its complexity, the routing process is typically divided into two stages: global routing and detailed routing. Global routing, the initial stage, establishes coarse-grained wire paths for signal nets, thereby providing valuable guidance for the subsequent detailed routing stage, enhancing its efficiency. Detailed routing, on the other hand, focuses on identifying valid physical paths, primarily within the routing guides set by global routing, while taking into account design rule constraints"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2025-02-26T11:34:54+00:00"><title>Routing | Pxmmmm</title>
<link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://pxgh02.github.io/zh/docs/Digtal/Digtal/Routing/routing2/><link rel=stylesheet href=/book.min.6c8b9d2a1fc95075ed7da46ca81060b39add8fff6741ac51259f768929281e2c.css integrity="sha256-bIudKh/JUHXtfaRsqBBgs5rdj/9nQaxRJZ92iSkoHiw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/zh.search.min.8eafbac7697c4856301cceaa115ee72ef60019c2c45132b637d7543a267762ca.js integrity="sha256-jq+6x2l8SFYwHM6qEV7nLvYAGcLEUTK2N9dUOiZ3Yso=" crossorigin=anonymous></script><script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/zh/><span>Pxmmmm</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=搜索 aria-label=搜索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul class=book-languages><li><input type=checkbox id=languages class=toggle>
<label for=languages class="flex justify-between"><a role=button class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
Chinese</a></label><ul><li><a href=/>English</a></li></ul></li></ul><ul><li><input type=checkbox id=section-a7a8fb3cc34544172ff5103ce3adf7cc class=toggle>
<label for=section-a7a8fb3cc34544172ff5103ce3adf7cc class="flex justify-between"><a href=/zh/docs/Other/>Other</a></label><ul><li><input type=checkbox id=section-0f93294ac0398c75569110d47f22a323 class=toggle>
<label for=section-0f93294ac0398c75569110d47f22a323 class="flex justify-between"><a href=/zh/docs/Other/Other/>Other</a></label><ul><li><a href=/zh/docs/Other/Other/Algorithms/>Algorithms</a></li><li><a href=/zh/docs/Other/Other/Hardware/>Hardware</a></li><li><a href=/zh/docs/Other/Other/linux/>Linux</a></li><li><a href=/zh/docs/Other/Other/Literature/>Literature</a></li><li><a href=/zh/docs/Other/Other/network/>Network</a></li><li><a href=/zh/docs/Other/Other/Program/>Program</a></li><li><a href=/zh/docs/Other/Other/software/>Software</a></li><li><a href=/zh/docs/Other/Other/Tools/>Tools</a></li><li><a href=/zh/docs/Other/Other/window/>Window</a></li></ul></li><li><a href=/zh/docs/Other/Algorithms/>Algorithms</a></li><li><a href=/zh/docs/Other/git/>Git</a></li><li><a href=/zh/docs/Other/Hardware/>Hardware</a></li><li><a href=/zh/docs/Other/linux/>Linux</a></li><li><a href=/zh/docs/Other/Literature/>Literature</a></li><li><a href=/zh/docs/Other/makefile/>Makefile</a></li><li><a href=/zh/docs/Other/network/>Network</a></li><li><a href=/zh/docs/Other/Program/>Program</a></li><li><a href=/zh/docs/Other/Tools/>Tools</a></li><li><a href=/zh/docs/Other/window/>Window</a></li><li><a href=/zh/docs/Other/Writing-PPT-Presentation/>Writing Ppt Presentation</a></li></ul></li><li><input type=checkbox id=section-546194909198d851b05dc5d16088b0b9 class=toggle checked>
<label for=section-546194909198d851b05dc5d16088b0b9 class="flex justify-between"><a href=/zh/docs/Digtal/>Physical Design</a></label><ul><li><input type=checkbox id=section-50bd8d8e06f01bc507cff9ec875d9670 class=toggle checked>
<label for=section-50bd8d8e06f01bc507cff9ec875d9670 class="flex justify-between"><a href=/zh/docs/Digtal/Digtal/>Physical Design</a></label><ul><li><input type=checkbox id=section-eb886ad00a6041494cd8a2d37b9502c1 class=toggle>
<label for=section-eb886ad00a6041494cd8a2d37b9502c1 class="flex justify-between"><a href=/zh/docs/Digtal/Digtal/flow/EDA4PR/>EDA4PR</a></label></li><li><input type=checkbox id=section-56ecf627e9a5b7dcba2f2eeea116f5c8 class=toggle>
<label for=section-56ecf627e9a5b7dcba2f2eeea116f5c8 class="flex justify-between"><a href=/zh/docs/Digtal/Digtal/flow/EDA4PR-Digtal/>EDA4PR-Digtal</a></label></li><li><input type=checkbox id=section-531f953e4132641abe87a288f8c87537 class=toggle>
<label for=section-531f953e4132641abe87a288f8c87537 class="flex justify-between"><a href=/zh/docs/Digtal/Digtal/flow/flow/>Flow</a></label></li><li><input type=checkbox id=section-dd416fec3c1dfa9abc7052d958fac1fb class=toggle>
<label for=section-dd416fec3c1dfa9abc7052d958fac1fb class="flex justify-between"><a href=/zh/docs/Digtal/Digtal/Placement/placement/>Placement</a></label></li><li><input type=checkbox id=section-edb5a12c4e85a0cb8ad856bb96d3a791 class=toggle checked>
<label for=section-edb5a12c4e85a0cb8ad856bb96d3a791 class="flex justify-between"><a href=/zh/docs/Digtal/Digtal/Routing/routing2/ class=active>Routing</a></label></li><li><input type=checkbox id=section-85e7c64a7f59a04958f475e43f62710b class=toggle>
<label for=section-85e7c64a7f59a04958f475e43f62710b class="flex justify-between"><a href=/zh/docs/Digtal/Digtal/Routing/routing1/>Routing1</a></label></li></ul></li><li><input type=checkbox id=section-9bc128912acae8559e0b27b496b7779b class=toggle>
<label for=section-9bc128912acae8559e0b27b496b7779b class="flex justify-between"><a href=/zh/docs/Digtal/flow/EDA4PR/>EDA4PR</a></label></li><li><input type=checkbox id=section-50846ac4cdec99c8bd1f8b0417acad9a class=toggle>
<label for=section-50846ac4cdec99c8bd1f8b0417acad9a class="flex justify-between"><a href=/zh/docs/Digtal/flow/flow/>Flow</a></label></li><li><input type=checkbox id=section-b2241e4da59f24976e354abe344e8d4f class=toggle>
<label for=section-b2241e4da59f24976e354abe344e8d4f class="flex justify-between"><a href=/zh/docs/Digtal/Placement/placement/>Placement</a></label></li><li><input type=checkbox id=section-259735f9bf2708d778569b162c141df5 class=toggle>
<label for=section-259735f9bf2708d778569b162c141df5 class="flex justify-between"><a href=/zh/docs/Digtal/Routing/routing2/>Routing</a></label></li><li><input type=checkbox id=section-78b8f069c0c130e55062b802fff78361 class=toggle>
<label for=section-78b8f069c0c130e55062b802fff78361 class="flex justify-between"><a href=/zh/docs/Digtal/Routing/routing1/>Routing1</a></label></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>Routing</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#简介>简介</a><ul><li><a href=#gr--dr>GR & DR</a></li><li><a href=#background><strong>background</strong></a></li><li><a href=#输入><strong>输入</strong></a></li><li><a href=#输出><strong>输出</strong></a></li><li><a href=#优化指标><strong>优化指标</strong></a></li><li><a href=#约束><strong>约束</strong></a></li></ul></li><li><a href=#global-router>Global Router</a><ul><li><a href=#概念>概念</a></li><li><a href=#term>term</a></li><li><a href=#challenge>challenge</a></li><li><a href=#技术方向>技术方向</a></li><li><a href=#问题建模>问题建模</a></li><li><a href=#fasterroute41-in-openroad>FasterRoute4.1 in OpenROAD</a><ul><li><a href=#结构>结构</a></li></ul></li><li><a href=#cugr>CUGR</a><ul><li><a href=#install>install</a></li><li><a href=#run>run</a></li></ul></li><li><a href=#fastroute-1>FastRoute</a><ul><li><a href=#install-1>install</a></li></ul></li><li><a href=#cugr-20>CUGR 2.0</a></li><li><a href=#instantgr>InstantGR</a><ul><li><a href=#model>model</a></li><li><a href=#flow>flow</a></li><li><a href=#install-2>install</a></li><li><a href=#debug-1>debug</a></li></ul></li><li><a href=#contest>contest</a><ul><li><a href=#ispd-07>ISPD 07</a></li><li><a href=#ispd-08>ISPD 08</a></li><li><a href=#iccad-19-contest-problem-c--gr-use-real-world-design-and-evaluate-by-drouter>ICCAD 19 Contest Problem C: GR use Real world design and evaluate by DRouter</a></li><li><a href=#ispd24-contest-gpuml-enhanced-large-scale-global-routing-contest><strong>ISPD’24 Contest: GPU/ML-Enhanced Large Scale Global Routing Contest</strong></a></li><li><a href=#ispd25-contest-performance-driven-large-scale-global-routing><a href=https://github.com/liangrj2014/ISPD25_contest/blob/main/index.md>ISPD25 Contest: Performance-Driven Large Scale Global Routing</a></a></li></ul></li></ul></li><li><a href=#detail-router>Detail Router</a><ul><li><a href=#概念-1>概念</a></li><li><a href=#问题建模-1>问题建模</a></li><li><a href=#contest-1>Contest</a><ul><li><a href=#ispd-2018>ISPD-2018</a></li><li><a href=#ispd-2019>ISPD-2019</a></li></ul></li></ul></li><li><a href=#算法>算法</a><ul><li><a href=#最小树算法>最小树算法</a><ul><li></li><li><a href=#flute-1>FLUTE</a></li></ul></li><li><a href=#模式布线>模式布线</a></li><li><a href=#迷宫算法>迷宫算法</a><ul><li><a href=#概念-2>概念</a></li><li><a href=#李氏算法>李氏算法</a></li><li><a href=#a算法>A*算法</a></li><li><a href=#线搜索算法>线搜索算法</a></li></ul></li><li><a href=#pattern--maze>pattern + maze</a></li><li><a href=#线序选择>线序选择</a></li><li><a href=#拆线重布>拆线重布</a></li><li><a href=#层分配>层分配</a></li><li><a href=#并行布线算法>并行布线算法</a><ul><li><a href=#整数线性规划>整数线性规划</a></li><li><a href=#线性规划>线性规划</a></li></ul></li></ul></li><li><a href=#数据集>数据集</a><ul><li><a href=#文件定义>文件定义</a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=简介>简介
<a class=anchor href=#%e7%ae%80%e4%bb%8b>#</a></h1><h2 id=gr--dr>GR & DR
<a class=anchor href=#gr--dr>#</a></h2><p>Routing is a critical yet complex phase in the implementation process of integrated circuits (ICs), often necessitating considerable time and effort. Given its complexity, the routing process is typically divided into two stages: global routing and detailed routing. <code>Global routing</code>, the initial stage, establishes coarse-grained wire paths for signal nets, thereby providing valuable <strong>guidance</strong> for the subsequent detailed routing stage, enhancing its efficiency. <code>Detailed routing</code>, on the other hand, focuses on identifying valid physical paths, primarily within the routing guides set by global routing, while taking into account design rule constraints</p><p>Routing is usually divided into global routing (GR) and detailed routing (DR) –cite–>
<a href=/zh/>C. J. Alpert, D. P. Mehta, and S. S. Sapatnekar, Handbook of Algorithms for Physical Design Automation. CRC press, 2008.</a></p><p>Routing is usually divided into global routing (GR) and detailed routing (DR) [2]. Global routing serves as a fast routing planning to generate guidance for detailed routing to reduce the search space of each net. Detailed routing then takes the guidance as input and finishes the physical wiring to connect pins in each net. Global routing is also used for routability estimation at early design stages like placement [3–9]. With growing design scales and complexity, it becomes increasingly challenging for global routing to resolve routing overflow within a short time. Therefore, the quality and efficiency of global routing is critical to design closure, as it impacts both its proceeding and succeeding design stages.</p><h2 id=background><strong>background</strong>
<a class=anchor href=#background>#</a></h2><p><img src=/image-20241116100048810.png alt=image-20241116100048810></p><p><img src=/image-20241116100054863.png alt=image-20241116100054863></p><p><img src=/image-20241116100129859.png alt=image-20241116100129859></p><h2 id=输入><strong>输入</strong>
<a class=anchor href=#%e8%be%93%e5%85%a5>#</a></h2><p><img src=/image-20241116100525254.png alt=image-20241116100525254></p><h2 id=输出><strong>输出</strong>
<a class=anchor href=#%e8%be%93%e5%87%ba>#</a></h2><p><img src=/image-20241116100541024.png alt=image-20241116100541024></p><h2 id=优化指标><strong>优化指标</strong>
<a class=anchor href=#%e4%bc%98%e5%8c%96%e6%8c%87%e6%a0%87>#</a></h2><p><img src=/image-20241116100640337.png alt=image-20241116100640337></p><h2 id=约束><strong>约束</strong>
<a class=anchor href=#%e7%ba%a6%e6%9d%9f>#</a></h2><ul><li>线网连接正确性</li><li>布线障碍</li><li>版图设计规则 ：金属线的最小宽度（min-width）；金属线间及金属线与布线障碍间的最小线间距（min-spacing）；一条金属线的最小面积（min-area），当金属线的宽度固定为最小宽度时 ，最小面积约束也被称作最小长度约束</li></ul><h1 id=global-router>Global Router
<a class=anchor href=#global-router>#</a></h1><h2 id=概念>概念
<a class=anchor href=#%e6%a6%82%e5%bf%b5>#</a></h2><p><img src=C:%5cUsers%5cuser%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20241115114352393.png alt=image-20241115114352393></p><p>甚至不需要考虑大部分几何级问题 ，其布线模型的建模较为简单 ，即使在具有数以万计的区域的芯片版图上布线，也只产生较低的时间开销</p><p><img src=/image-20250209213828915.png alt=image-20250209213828915></p><p>routes every net with only two pins under design constraints turns out to be an NP-complete problem –cite–>
<a href=/zh/>M. Kramer and J. Van Leeuwen. The complexity of wirerouting and finding minimum area layouts for arbitrary vlsi circuits. Adv. Comput. Res, 2:129–146, 1984</a></p><h2 id=term>term
<a class=anchor href=#term>#</a></h2><p>net order: 串行</p><p>OF: over flow</p><p>conjointly： 并行</p><p>guide: 在 GR 中就是布线通路，GR 最终的输出结果</p><p>preferred routing direction : 比如第一层水平优先，第二层垂直优先</p><h2 id=challenge>challenge
<a class=anchor href=#challenge>#</a></h2><p>advance GR are GPU-Accelerate-based now，main challenge are:</p><ul><li>GPU memory is limited</li><li>This requires memory-efficient solutions that can minimize CPU-GPU communication while maximizing GPU utilization</li><li>large designs have more nets with bigger routing graphs, providing many new parallelization opportunities that are not yet explored</li><li></li></ul><h2 id=技术方向>技术方向
<a class=anchor href=#%e6%8a%80%e6%9c%af%e6%96%b9%e5%90%91>#</a></h2><ul><li><p>DP base-layer assignment</p><ul><li>CUGR, InstantGR</li><li>start use GPU accelarate</li></ul></li><li><p>RL-based</p><ul><li>slow</li><li>理论上 DRV 会很小</li></ul></li><li><p>generative model</p><ul><li>such as: CNN-based, PRNet, Hub Router</li><li>Actually, global routing is a combinatorial problem and can be formulated as a 0-1 integer linear programming (0-1 ILP) problem</li><li>it is still NP-complete</li></ul></li></ul><p>另一种分类：来自
<a href=/zh/>HeLEM-GR</a></p><ul><li><p>grid models</p><ul><li><p>2D</p><p>Many routers such as FastRoute 4.0 [10], BoxRouter 2.0 [11], NCTU-GR 2.0 [12], and SPRoute 2.0 [13] are based on 2D grids (a.k.a 2D routers), which perform layer assignment after routing all nets on the 2D space</p></li><li><p>3D</p><p>Other routers such as FGR [14] and CUGR [15] try to directly route on 3D grids to simultaneously determine the routing paths and layers for each net</p></li><li><p>hybrid</p><ol><li>generates initial routing results on 2D grids and then refines it on 3D grids.</li><li>TritonRoute-WXL</li></ol></li></ul></li><li><p>routing kernels</p><ul><li>Lee’s algorithm [17] is the basic maze routing kernel in many routers, but it is very time-consuming.</li></ul></li><li><p>routing schemes</p></li></ul><h2 id=问题建模>问题建模
<a class=anchor href=#%e9%97%ae%e9%a2%98%e5%bb%ba%e6%a8%a1>#</a></h2><p><img src=/image-20250212173059226.png alt=image-20250212173059226></p><p><img src=/image-20250212173122897.png alt=image-20250212173122897></p><p>3d method:</p><img src=assets/image-20250208201225846.png alt=image-20250208201225846 style=zoom:50%><p>2D method:</p><p><img src=/image-20250208202244752.png alt=image-20250208202244752></p><p><img src=C:%5cUsers%5cuser%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20241114211744479.png alt=image-20241114211744479></p><p>gcell 定义在.def 文件中</p><p><img src=C:%5cUsers%5cuser%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20241115120224885.png alt=image-20241115120224885></p><p><img src=C:%5cUsers%5cuser%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20241115135527816.png alt=image-20241115135527816></p><p><img src=/image-20241116103827437.png alt=image-20241116103827437></p><p><img src=/image-20241116170317528.png alt=image-20241116170317528></p><p><img src=/image-20250207191313771.png alt=image-20250207191313771></p><p><img src=/image-20250207191256535.png alt=image-20250207191256535></p><p><strong>输入</strong></p><p><strong>输出</strong></p><p><strong>约束</strong></p><p><strong>优化指标</strong></p><p>全局布线要在给定布线资源的情况下 ，优化线长、通孔数及关键线网时延等目标函数</p><p>线长、通孔数、溢出数量、运行时间</p><h2 id=fasterroute41-in-openroad>FasterRoute4.1 in OpenROAD
<a class=anchor href=#fasterroute41-in-openroad>#</a></h2><p><img src=/image-20241204174743919.png alt=image-20241204174743919></p><p><img src=/image-20241204174840007.png alt=image-20241204174840007></p><h3 id=结构>结构
<a class=anchor href=#%e7%bb%93%e6%9e%84>#</a></h3><h4 id=fastroute>fastroute
<a class=anchor href=#fastroute>#</a></h4><h5 id=fastroutecore>FastRouteCore
<a class=anchor href=#fastroutecore>#</a></h5><ul><li><code>vector&lt;FrNet*> nets_</code>;</li><li><code>vector&lt;StTree> sttrees_</code>; // <strong>the Steiner trees</strong></li><li><code>run</code>()<ul><li><code>gen_brk_RSMT()</code><ul><li>for (const int& netID : net_ids_)</li><li><code>rsmt</code> = stt_builder_-> <code>makeSteinerTree(…)</code><ul><li>Tree <code>tree </code>= pdr:: <code>primDijkstra</code>(x, y, drvr_index, alpha, logger_);</li><li>flute_-> <code>flutes</code>(x, y, s, accuracy)</li></ul></li><li><code>steinerTreeVisualization</code></li></ul></li><li><code>getOverflow2Dmaze()</code></li><li><code>getOverflow2Dmaze</code></li><li><code>fluteNormal</code>(<code>rsmt</code>)</li><li><code>layerAssignment()</code></li><li><code>StTreeVisualization</code>()//2d or 3d</li></ul></li><li><code>getOverflow2D</code></li><li><code>routeLAll</code></li><li><code>convertToMazeroute</code></li><li>// debug mode Rectilinear Steiner Tree before overflow iterations</li></ul><h4 id=steinertreebuilder>SteinerTreeBuilder
<a class=anchor href=#steinertreebuilder>#</a></h4><h5 id=frnet>FrNet
<a class=anchor href=#frnet>#</a></h5><ul><li><p><code>odb::dbNet* db_net_;</code></p></li><li><p><code>vector&lt;int> pin_x_</code>;</p></li><li><p><code>vector&lt;int> pin_y_</code>;</p></li><li><p><code>vector&lt;int> pin_l_</code>;//layer</p></li><li><p><code>float slack_</code>;</p></li><li><p><code>std::unique_ptr&lt;std::vector&lt;int>> edge_cost_per_layer_</code>;</p></li><li><p><code>void addPin(int x, int y, int layer)</code></p></li></ul><h5 id=sttree>StTree
<a class=anchor href=#sttree>#</a></h5><ul><li><code>vector&lt;TreeNode> nodes</code> // The nodes (pin and Steiner nodes) in the tree.</li><li><code>vector&lt;TreeEdge> edges</code></li></ul><h5 id=treenode>TreeNode
<a class=anchor href=#treenode>#</a></h5><ul><li><code>int16_t x, y; // position in the grid graph</code></li><li>int <code>nbr[3]</code>; // three neighbors</li><li>int <code>edge[3]</code>; // three adjacent edges</li></ul><h5 id=treeedge>TreeEdge
<a class=anchor href=#treeedge>#</a></h5><h4 id=stt>stt
<a class=anchor href=#stt>#</a></h4><h5 id=flute>Flute
<a class=anchor href=#flute>#</a></h5><ul><li></li><li><p><code>initLUT（）</code></p><ul><li>主要是读取.dat 文件</li></ul></li><li><p><code>flute()</code></p></li><li><p><code>flutes()</code></p><ul><li><code>flutes_RDP</code></li><li><code>flutes_ALLD</code></li></ul></li></ul><h5 id=steinertreebuilder-1>SteinerTreeBuilder
<a class=anchor href=#steinertreebuilder-1>#</a></h5><ul><li><code>unique_ptr&lt;flt::Flute> flute_</code></li></ul><h5 id=tree>Tree
<a class=anchor href=#tree>#</a></h5><ul><li><code>int deg</code>; // degreeStTree</li><li><code>int length</code>; // total wirelength</li><li><code>vector&lt;Branch> branch</code>; // array of tree branches</li><li><code>void printTree(utl::Logger* logger)</code> const;</li><li><code>int branchCount()</code> const { return branch.size(); }</li></ul><h5 id=branch>Branch
<a class=anchor href=#branch>#</a></h5><ul><li><code>int x, y</code>; // starting point of the branch</li><li><code>int n</code>; // index of <strong>neighbor</strong></li></ul><h4 id=odb>odb
<a class=anchor href=#odb>#</a></h4><ul><li><code>dbNet</code></li></ul><h4 id=pdr>pdr
<a class=anchor href=#pdr>#</a></h4><ul><li>Tree <code>primDijkstra</code>(const vector <int>& x, const vector <int>& y, const int driver_index, const float alpha, Logger* logger)<ul><li>ListGraph <code>graph</code></li><li><code>get_nearest_neighbors</code></li><li><code>buildSpanningTree</code></li><li><code>steinerize</code></li><li><code>makeTree</code><ul><li><code>makeTreeRecursive</code></li></ul></li></ul></li></ul><h4 id=lemon>lemon
<a class=anchor href=#lemon>#</a></h4><h5 id=listgraph>ListGraph
<a class=anchor href=#listgraph>#</a></h5><h2 id=cugr>CUGR
<a class=anchor href=#cugr>#</a></h2><p><a href=https://github.com/cuhk-eda/cu-gr>cuhk-eda/cu-gr: CUGR, VLSI Global Routing Tool Developed by CUHK</a></p><h3 id=install>install
<a class=anchor href=#install>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-markdown data-lang=markdown><span style=display:flex><span>#还是在docker跑把，服务器上的boost版本总是搞不好。。。
</span></span><span style=display:flex><span>apt update
</span></span><span style=display:flex><span>apt install git
</span></span><span style=display:flex><span>apt install vim
</span></span><span style=display:flex><span>apt install build-essential
</span></span><span style=display:flex><span>apt install -y build-essential gcc g++
</span></span><span style=display:flex><span>apt install cmake
</span></span><span style=display:flex><span>apt install -y libboost-all-dev
</span></span><span style=display:flex><span>curl -O https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh
</span></span><span style=display:flex><span>#yes, opt/miniconda3, yes
</span></span><span style=display:flex><span>source ~/.bashrc
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>git clone https://github.com/cuhk-eda/cu-gr
</span></span><span style=display:flex><span>cd cu-gr
</span></span><span style=display:flex><span>scripts/build.py -o release
</span></span></code></pre></div><p>报错：</p><blockquote><p>CMake Error at /usr/local/lib/cmake/Boost-1.80.0/BoostConfig.cmake: 141 (find_package):
Could not find a configuration file for package &ldquo;boost_filesystem&rdquo; that
exactly matches requested version &ldquo;1.80.0&rdquo;.</p><p>The following configuration files were considered but not accepted:</p><p>/usr/lib/x86_64-linux-gnu/cmake/boost_filesystem-1.74.0/boost_filesystem-config.cmake, version: 1.74.0
/lib/x86_64-linux-gnu/cmake/boost_filesystem-1.74.0/boost_filesystem-config.cmake, version: 1.74.0</p><p>Call Stack (most recent call first):
/usr/local/lib/cmake/Boost-1.80.0/BoostConfig.cmake: 262 (boost_find_component)
/usr/local/share/cmake-3.24/Modules/FindBoost.cmake: 594 (find_package)
CMakeLists.txt: 39 (find_package)</p></blockquote><p>fix:</p><p>可以使用以下命令来查看系统上安装的 Boost 版本：</p><pre tabindex=0><code>dpkg-query -s libboost-all-dev | grep Version   # 对于 Debian/Ubuntu 系统
#如果您已经安装了 Boost 1.74.0，则需要升级到 Boost 1.80.0 版本。
tar -xvf boost_1_80_0.tar.bz2
cd boost_1_80_0
./bootstrap.sh
./b2
sudo ./b2 install
cmake -DBOOST_ROOT =/usr/local/
</code></pre><p>报错：</p><blockquote><p>CMake Error: Invalid value used with &ndash;target
Usage: cmake &ndash;build<dir>[options] [&ndash; [native-options]]
cmake &ndash;build &ndash;preset <preset>[options] [&ndash; [native-options]]
Options:</p><dir>= Project binary directory to be built.
--preset <preset>, --preset = <preset>= Specify a build preset.
--list-presets
= List available build presets.
--parallel [<jobs>], -j [<jobs>]
= Build in parallel using the given number of jobs.
If <jobs>is omitted the native build tool's
default number is used.
The CMAKE_BUILD_PARALLEL_LEVEL environment variable
specifies a default parallel level when this option
is not given.
--target <tgt>..., -t <tgt>...
= Build <tgt>instead of default targets.
--config <cfg>= For multi-configuration tools, choose <cfg>.
--clean-first = Build target 'clean' first, then build.
(To clean only, use --target 'clean'.)
--resolve-package-references ={on|only|off}
= Restore/resolve package references during build.
--verbose, -v = Enable verbose output - if supported - including
the build commands to be executed.
-- = Pass remaining options to the native tool.
cmake --build build --target -- -j 6</blockquote><p>fix:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>scripts/build.py -o release -t iccad19gr#cu-gr, github 写的有问题
</span></span><span style=display:flex><span>scripts/build.py -o release -t route#cu-gr2
</span></span></code></pre></div><h3 id=run>run
<a class=anchor href=#run>#</a></h3><blockquote><p>按照他说的，不过要自己把 iccad19 的 benchmark 放到 toys/iccad2019c/下</p></blockquote><h2 id=fastroute-1>FastRoute
<a class=anchor href=#fastroute-1>#</a></h2><h3 id=install-1>install
<a class=anchor href=#install-1>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e>#in a new ubuntu:22.04 container</span>
</span></span><span style=display:flex><span>apt install build-essential
</span></span><span style=display:flex><span>apt install gcc
</span></span><span style=display:flex><span>apt install libboost-all-dev
</span></span><span style=display:flex><span>apt install cmake
</span></span><span style=display:flex><span>apt install tcl-dev
</span></span><span style=display:flex><span>apt install swig
</span></span><span style=display:flex><span>apt install git
</span></span><span style=display:flex><span>apt install bison
</span></span><span style=display:flex><span>apt install flex
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>git clone --recursive https://github.com/The-OpenROAD-Project/FastRoute4-lefdef
</span></span><span style=display:flex><span>cd FastRoute/
</span></span><span style=display:flex><span>cmake .
</span></span><span style=display:flex><span>make PARALLEL<span style=color:#f92672>=</span>nthreads
</span></span></code></pre></div><h4 id=debug>debug
<a class=anchor href=#debug>#</a></h4><blockquote><p>/root/FastRoute-master/third_party/OpenDB/include/opendb/ZInterface.h:38:10: fatal error: tcl.h: No such file or directory
38 | #include &lt;tcl.h>
| ^~~~~~~
compilation terminated.</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmake data-lang=cmake><span style=display:flex><span><span style=color:#75715e>#cmake 中加上以下两句
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>include_directories(<span style=color:#e6db74>/usr/include/tcl8.6</span>)<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>link_directories(<span style=color:#e6db74>/usr/lib</span>)<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><h2 id=cugr-20>CUGR 2.0
<a class=anchor href=#cugr-20>#</a></h2><h2 id=instantgr>InstantGR
<a class=anchor href=#instantgr>#</a></h2><h3 id=model>model
<a class=anchor href=#model>#</a></h3><h4 id=database>database
<a class=anchor href=#database>#</a></h4><ul><li>layer</li><li>db:: net</li></ul><h4 id=database_cuda>database_cuda
<a class=anchor href=#database_cuda>#</a></h4><ul><li>cudb:: net</li><li></li></ul><h4 id=flutehpp>flute.hpp
<a class=anchor href=#flutehpp>#</a></h4><ul><li>readLUT</li></ul><h4 id=robin_hoodh>robin_hood.h
<a class=anchor href=#robin_hoodh>#</a></h4><ul><li>一个高性能的哈希表实现库</li><li>开源</li><li>这个库在高性能计算场景（如本项目的集成电路布线）中特别有用，因为它能提供更快的查找和插入操作，同时保持较低的内存占用。</li><li>主要优势：<ul><li>比标准库的 std:: unordered_map 性能更好</li><li>内存使用更高效</li><li>缓存友好的设计</li><li>开放寻址法解决冲突</li><li>支持异构查找</li></ul></li></ul><h3 id=flow>flow
<a class=anchor href=#flow>#</a></h3><ol><li><p>开启时钟</p><p><code>program_start = std::chrono::high_resolution_clock::now();</code></p></li><li><p>read input files</p><p><code>read()</code></p><ul><li>输入：</li></ul><p>cap_file_name []: 容量文件的路径</p><p>net_file_name []: 网络文件的路径</p><ul><li>输出：</li></ul><p>代码将读取的数据存储在类的成员变量中：</p><p>layers []: 存储每层的信息</p><p>capacity [][] []: 3D数组存储容量信息</p><p>nets: 存储所有网络信息</p><p>其他相关的网格和坐标映射信息</p></li><li><p><code>readLUT("POWV9.dat", "POST9.dat")</code></p></li><li><p><code>build_cuda_database()</code> cuda 相关变量初始化</p></li><li><p>先处理单 pin 的 net（有一些两个 pin 重叠，二维变成单个 pin）</p></li><li><p>设置两个核函数 cuda 共享内存大小</p><p><code>cudaFuncSetAttribute</code></p><p>具体有什么用？</p></li><li><p>对非单 Pin 的 net(<code>nets2route</code>)进行 FLUTE 建立 MSRT</p><p>FLUTE:</p><ul><li>net.<code>construct_rsmt()</code><ul><li>my_flute(unordered_set <int>&amp;pos)`<ul><li>flute:: <code>flute(cnt, x.data(), y.data(), 3);</code></li></ul></li></ul></li></ul><p>最后处理得到水平和垂直 segments</p></li><li><p><code>sort</code>, 对非单 Pin 的 net(<code>nets2route</code>)进行根据 hpwl 从小到大排序</p></li><li><p><code>generate_batches_rsmt(nets2route)</code></p></li><li><p><code>sort</code>, 对每个 batch 根据 net 数量从小到大排序 //这个有什么用？</p></li></ol><p>可以问问</p><ol start=11><li><p>根据 <code>sort</code> 后的 <code>batches</code>，重新对每个 net 依次排列到 <code>nets2route</code></p></li><li><p>DFS 获取 DAG 图：<code>Routing DAG</code>,</p><p>得到一个 segment 排序</p></li><li><p>对每一个 batch, 开启 L_shape</p><ul><li>update_cost: via/wire</li><li>presum() 对wire_cost进行累加</li><li><code>Lshape_route_cuda&lt;&lt;&lt;>>>()</code><ul><li>grid_dim = batches[i].size() / block_dim + 1</li><li>block_dim = 512</li><li>输入参数：<ol><li>batches[i].size()：<ul><li>当前批次的网表数量</li><li>范围：单个值，表示这批要处理的网表数量</li></ul></li><li>batch_cnt_sum[i]：<ul><li>当前批次的网表偏移量</li><li>范围：单个值，表示之前所有批次的网表数量之和</li><li>用作offset</li></ul></li><li>node_cnt_sum：<ul><li>每个net的node个数累加</li><li>索引：net_id</li></ul></li><li>nodes：<ul><li>节点坐标数组</li><li>每个节点坐标的编码方式：l * X * Y + x * Y + y</li></ul></li><li>par_nodes<ul><li>父节点索引数组</li></ul></li><li>dist、from、layer_range<ul><li>距离/代价数组</li></ul></li><li></li></ol></li></ul></li><li><code>Lshape_route_cuda&lt;&lt;&lt;BLOCK_NUM(batches[i].size()), THREAD_NUM>>> (batches[i].size(), batch_cnt_sum[i], node_cnt_sum, nodes, par_nodes, dist, from, layer_range, global_timestamp);</code></li></ul></li></ol><h3 id=install-2>install
<a class=anchor href=#install-2>#</a></h3><p>compile directly</p><h3 id=debug-1>debug
<a class=anchor href=#debug-1>#</a></h3><h2 id=contest>contest
<a class=anchor href=#contest>#</a></h2><h3 id=ispd-07>ISPD 07
<a class=anchor href=#ispd-07>#</a></h3><h3 id=ispd-08>ISPD 08
<a class=anchor href=#ispd-08>#</a></h3><h3 id=iccad-19-contest-problem-c--gr-use-real-world-design-and-evaluate-by-drouter>ICCAD 19 Contest Problem C: GR use Real world design and evaluate by DRouter
<a class=anchor href=#iccad-19-contest-problem-c--gr-use-real-world-design-and-evaluate-by-drouter>#</a></h3><p><a href=https://www.iccad-contest.org/2019/problems.html>2019 CAD Contest @ ICCAD</a></p><p>也给了后端详细布线器 DrCu, 和用于评估结果的脚本</p><p>用的 ISPD2018/19 的数据</p><p><img src=/image-20241116165907427.png alt=image-20241116165907427></p><p><img src=/image-20241116170139876.png alt=image-20241116170139876></p><p><strong>输入：</strong></p><p><img src=/image-20241118230249711.png alt=image-20241118230249711></p><p><strong>输出</strong>：</p><p><img src=/image-20241118230341478.png alt=image-20241118134249207></p><p>ispd24 的比赛是要 via 的</p><p><img src=/image-20241116170452085.png alt=image-20241116170452085></p><p><strong>evaluate</strong>:</p><p><img src=/image-20241118134652606.png alt=image-20241118134652606></p><h3 id=ispd24-contest-gpuml-enhanced-large-scale-global-routing-contest><strong>ISPD’24 Contest: GPU/ML-Enhanced Large Scale Global Routing Contest</strong>
<a class=anchor href=#ispd24-contest-gpuml-enhanced-large-scale-global-routing-contest>#</a></h3><p><strong>background:</strong></p><p><img src=/image-20241115165538808.png alt=image-20241115165538808></p><p><img src=/image-20241115165636260.png alt=image-20241115165636260></p><p><img src=/image-20241115165751079.png alt=image-20241115165751079></p><p><strong>data</strong></p><p><img src=/image-20241115165954622.png alt=image-20241115165954622></p><p><img src=/image-20241115170100026.png alt=image-20241115170100026></p><p><img src=/image-20250212144750279.png alt=image-20250212144750279></p><p><strong>evaluate：</strong></p><p>和 ICCAD19 很像</p><p><img src=/image-20241115170302360.png alt=image-20241115170302360></p><p>scale 越大权重越大</p><p><img src=/image-20241115170344046.png alt=image-20241115170344046></p><p><strong>限制</strong>：</p><p><img src=/image-20241116201745363.png alt=image-20241116201745363></p><p><strong>最好结果：</strong></p><p>越小越好</p><table><thead><tr><th>design</th><th>WL cost</th><th>via cost</th><th>overflow cost</th><th>raw score</th><th>runtime /s</th><th>median runtime /s</th><th>scaled score</th></tr></thead><tbody><tr><td>Ariane133_51</td><td>9335109</td><td>3060400</td><td>10369862</td><td>22765372</td><td>4</td><td>11</td><td>22100882</td></tr><tr><td>Ariane133_68</td><td>9443754</td><td>2981836</td><td>7825647</td><td>20251238</td><td>8</td><td>12</td><td>20014313</td></tr><tr><td>BlackParrot</td><td>58347098</td><td>19740536</td><td>35450029</td><td>113537664</td><td>27</td><td>70.5</td><td>110393434</td></tr><tr><td>Nvdla</td><td>21345766</td><td>4630872</td><td>23933347</td><td>49909986</td><td>4</td><td>20</td><td>47592238</td></tr><tr><td>MemPool-Tile</td><td>8407884</td><td>3425828</td><td>3569040</td><td>15402753</td><td>3</td><td>10</td><td>14867672</td></tr><tr><td>MemPool-Group</td><td>262817992</td><td>76146200</td><td>70345580</td><td>409309772</td><td>81</td><td>375</td><td>391210938</td></tr><tr><td>MemPool-Cluster</td><td>1094650057</td><td>268335040</td><td>300359611</td><td>1663344708</td><td>478</td><td>2048</td><td>1593513066</td></tr><tr><td>Tera-Cluster</td><td>12190406272</td><td>1542639724</td><td>6705414754</td><td>20438460750</td><td>4310</td><td>4584</td><td>20402113329</td></tr></tbody></table><p><strong>issue:</strong></p><p><img src=/image-20250214155938627.png alt=image-20250214155938627></p><h3 id=ispd25-contest-performance-driven-large-scale-global-routing><a href=https://github.com/liangrj2014/ISPD25_contest/blob/main/index.md>ISPD25 Contest: Performance-Driven Large Scale Global Routing</a>
<a class=anchor href=#ispd25-contest-performance-driven-large-scale-global-routing>#</a></h3><p><img src=/image-20241115175008142.png alt=image-20241115175008142></p><h4 id=background-1>Background
<a class=anchor href=#background-1>#</a></h4><p>ISPD2024 竞赛虽然简化的输入/输出格式和评估指标提高了来自不同背景的参与者对比赛的可访问性，但它们可能会在性能建模中引入不准确性。ISPD2024 竞赛中使用的输入文件 <strong>缺少时序和功率信息</strong>。仅基于带宽和路由溢出的指标不能准确地模拟定时性能和功耗。例如，最小化总长度并不一定会减少时间关键路径上的延迟。<strong>Wires on different metal layers exhibit varying resistance, resulting in different delays and power consumption. Additionally, the impact of vias on delays is difficult to model with simple metrics. Inter-wire coupling capacitance can also cause significant discrepancies between actual and nominal timing responses and power consumption</strong></p><p><img src=/image-20241115175617355.png alt=image-20241115175617355></p><h4 id=problem-formulation>Problem Formulation
<a class=anchor href=#problem-formulation>#</a></h4><p>In global routing, a 3D routing space is defined using global routing cells (GCells), created by a regular grid of horizontal and vertical lines. This configuration results in the formation of a grid graph where each GCell is treated as a vertex and edges connect adjacent GCells within the same layer (GCell edges) or between GCells in neighboring layers (via edges). The global router needs to establish a concrete path for each net within the grid graph and optimize the routability, timing and power.</p><p>For each testcase, the global router starts with a placed design, and generates a global routing solution. The global routing solution is evaluated by OpenROAD, which reports timing, power, and routing congestion. Additionally, the runtime and memory efficiency of the global router are critical factors.</p><h4 id=文件>文件
<a class=anchor href=#%e6%96%87%e4%bb%b6>#</a></h4><p><img src=/image-20241115180014864.png alt=image-20241115180014864></p><p><img src=/image-20241115174556593.png alt=image-20241115174556593></p><p><strong>输入</strong></p><p>For each testcase, two sets of input files are provided: <code>industry-standard files</code> and <code>simplified files</code>.</p><p>The <code>industry-standard files</code> include <code>DEF</code>, <code>LEF</code>, <code>LIB</code>, and <code>SDC</code> files. The <code>DEF</code> file contains definitions for CORE, ROW, TRACKS, and GCELLGRID, along with placed COMPONENTS and unrouted NETS. Similar to the
<a href=https://www.iccad-contest.org/2019/problems.html>ICCAD2019 global routing contest</a>, GCells are specified using the definition from the DEF GCELLGRID section. The <code>LEF</code> file includes MACRO definitions and technology information. The <code>LIB</code> files offer timing and power data for library cells, while the <code>SDC </code>files provide timing constraints. These files serve as the raw input, allowing contestants to perform the most accurate routing resource and performance modeling.</p><p>For each circuit, we also provide a set of <code>simplified input files</code>, which include a routing <code>resource file (with a .cap extension)</code> and a <code>net information file (with a .net extension)</code>. The routing resource file follows the same format as used in the ISPD2024 contest, while the net information file is an extended version of the one used in ISPD2024. The routing resource file offers a detailed representation of the GCell grid graph and its available routing resources. The net information file provides the access points for all the pins within each net, along with the pin names and pre-routing stage slack estimates. These slack estimates provide a rough timing view of the circuit and enable contestants to perform net-based timing optimization. The simplified input files enable contestants to quickly engage with the contest and facilitate framing global routing challenges as <strong>mathematical optimization problems</strong>.</p><p><strong>输出</strong>
<img src=/image-20241117103531193.png alt=image-20241117103531193></p><p><strong>镜像使用：</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker run -it ispd25:latest /bin/bash	<span style=color:#75715e>#启动</span>
</span></span></code></pre></div><h1 id=detail-router>Detail Router
<a class=anchor href=#detail-router>#</a></h1><h2 id=概念-1>概念
<a class=anchor href=#%e6%a6%82%e5%bf%b5-1>#</a></h2><p><img src=/image-20241116101049648.png alt=image-20241116101049648></p><p><img src=/image-20241116131559622.png alt=image-20241116131559622></p><p><img src=/image-20241116132005853.png alt=image-20241116132005853></p><p><img src=/image-20241116132016453.png alt=image-20241116132016453></p><h2 id=问题建模-1>问题建模
<a class=anchor href=#%e9%97%ae%e9%a2%98%e5%bb%ba%e6%a8%a1-1>#</a></h2><p><img src=/image-20241116131635197.png alt=image-20241116131635197></p><p><img src=/image-20241116131822252.png alt=image-20241116131822252></p><p><img src=/image-20241116131809817.png alt=image-20241116131809817></p><h2 id=contest-1>Contest
<a class=anchor href=#contest-1>#</a></h2><h3 id=ispd-2018>ISPD-2018
<a class=anchor href=#ispd-2018>#</a></h3><p><img src=/image-20241116173555799.png alt=image-20241116173555799></p><h3 id=ispd-2019>ISPD-2019
<a class=anchor href=#ispd-2019>#</a></h3><p><img src=/image-20241116173535248.png alt=image-20241116173535248></p><h1 id=算法>算法
<a class=anchor href=#%e7%ae%97%e6%b3%95>#</a></h1><h2 id=最小树算法>最小树算法
<a class=anchor href=#%e6%9c%80%e5%b0%8f%e6%a0%91%e7%ae%97%e6%b3%95>#</a></h2><p><img src=/image-20241116113941155.png alt=image-20241116113941155></p><p><img src=/image-20241116105052164.png alt=image-20241116105052164></p><ul><li>矩 形 最 小 斯 坦 纳 树（rectilinear steiner minimal tree，RSMT）</li></ul><p>一般会先基于 Pin 生成最小树，分解最小树为 2-Pin(两端口) wire 然后再进行后续处理</p><p><img src=/image-20241116114320379.png alt=image-20241116114320379></p><p><img src=/image-20241116114432776.png alt=image-20241116114432776></p><p><img src=/image-20241211111803514.png alt=image-20241211111803514></p><p><strong>RSMT 和 RMST 的区别</strong></p><blockquote><p>在图论和计算几何中，<strong>RSMT</strong>（Rectilinear Steiner Minimum Tree）和 <strong>RMST</strong>（Rectilinear Minimum Spanning Tree）是两种不同的树结构，主要用于解决不同类型的最小树问题。以下是它们之间的主要区别：</p><h4 id=1-定义>1. <strong>定义</strong>
<a class=anchor href=#1-%e5%ae%9a%e4%b9%89>#</a></h4><ul><li>RSMT（Rectilinear Steiner Minimum Tree）</li><li>RSMT 是一种最小生成树，允许在树中添加额外的点（称为 Steiner 点），以减少连接给定终端（节点）所需的总边长。RSMT 的目标是最小化连接所有终端的总路径长度，使用的是矩形距离（L1 距离或曼哈顿距离）。</li><li>RMST（Rectilinear Minimum Spanning Tree）</li><li>RMST 是一种最小生成树，连接给定的终端节点，但不允许添加额外的点。RMST 的目标是找到连接所有终端的最小边长树，同样使用矩形距离。</li></ul><h4 id=2-额外点的使用>2. <strong>额外点的使用</strong>
<a class=anchor href=#2-%e9%a2%9d%e5%a4%96%e7%82%b9%e7%9a%84%e4%bd%bf%e7%94%a8>#</a></h4><ul><li><strong>RSMT</strong> 允许在树中添加 <strong>额外的 Steiner 点</strong>，这些点可以帮助优化路径，减少总边长。</li><li><strong>RMST</strong> 仅使用给定的终端节点，不允许添加额外的点，因此可能会导致较长的连接路径。</li></ul><h4 id=3-应用场景>3. <strong>应用场景</strong>
<a class=anchor href=#3-%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af>#</a></h4><ul><li><strong>RSMT</strong> 通常用于更复杂的网络设计问题，例如 VLSI 设计和电路布局，其中需要优化连接以减少布线长度和提高效率。</li><li><strong>RMST</strong> 更常用于简单的网络连接问题，适用于需要在给定节点之间建立最小连接的场景。</li></ul><h4 id=4-计算复杂性>4. <strong>计算复杂性</strong>
<a class=anchor href=#4-%e8%ae%a1%e7%ae%97%e5%a4%8d%e6%9d%82%e6%80%a7>#</a></h4><ul><li>计算 RSMT 通常比 RMST 更复杂，因为需要考虑如何有效地选择 Steiner 点以优化树的结构。</li><li>RMST 的计算相对简单，因为只需连接给定的终端节点。</li></ul></blockquote><ul><li></li></ul><p>相关文献</p><p><img src=/image-20241116114742847.png alt=image-20241116114742847></p><h3 id=flute-1>FLUTE
<a class=anchor href=#flute-1>#</a></h3><h4 id=介绍>介绍
<a class=anchor href=#%e4%bb%8b%e7%bb%8d>#</a></h4><p><strong>问题阐述</strong></p><p><img src=/image-20241202205938246.png alt=image-20241202205938246></p><ul><li>一个常见的 steiner tree 算法</li><li>9 端最快，9 端一样也是次优解</li><li>基于查找表</li><li>诞生与 2004 ICCAD, ISPD 05 和 TCAD 07 有相关优化</li></ul><p><img src=/image-20241202205915696.png alt=image-20241202205915696></p><p><strong>版本信息</strong></p><p><img src=/image-20241202210032713.png alt=image-20241202210032713></p><h4 id=基本定义>基本定义
<a class=anchor href=#%e5%9f%ba%e6%9c%ac%e5%ae%9a%e4%b9%89>#</a></h4><p><img src=/image-20241202210129509.png alt=image-20241202210129509></p><p><strong>Degree</strong></p><p>Degree of a net is the number of pins in it</p><p><strong>Hanan grid</strong></p><p>只考虑节点是 4 个方向</p><p><strong>WL</strong></p><p><img src=/image-20241202210156447.png alt=image-20241202210156447></p><p><strong>POWV</strong></p><p><img src=/image-20241202210426248.png alt=image-20241202210426248></p><p>使用 WV 的好处</p><p><img src=/image-20241202210517516.png alt=image-20241202210517516></p><p><strong>position sequence</strong></p><p>y 方向是 1~4</p><p>position sequence 从 x = 0 开始数</p><p><img src=/image-20241202210804495.png alt=image-20241202210804495></p><h4 id=flow-1>flow
<a class=anchor href=#flow-1>#</a></h4><p><img src=/image-20241202210822417.png alt=image-20241202210822417></p><h4 id=powvs-generation--boundary-compaction>POWVs Generation ： boundary compaction
<a class=anchor href=#powvs-generation--boundary-compaction>#</a></h4><p><img src=/image-20241202211408469.png alt=image-20241202211408469></p><p><img src=/image-20241202211359522.png alt=image-20241202211359522></p><p><img src=/image-20241202211343874.png alt=image-20241202211343874></p><p><strong>Net Breaking for High degree Net</strong></p><p>For nets with degree > D, recursively break net until degree &lt;= D</p><p><img src=/image-20241202214411500.png alt=image-20241202214411500></p><p><strong>第一步</strong></p><p>查看满足 1，3 象限
或者 2，4 象限的情况</p><p><img src=/image-20241202214348930.png alt=image-20241202214348930></p><p>还不能拆成 9degree 以下的话，使用 <strong>Net Breaking Heuristic</strong>：</p><p>A <strong>score</strong> for each direction and <strong>each pin</strong>：</p><p><img src=/image-20241202214611033.png alt=image-20241202214611033></p><p>for Pin_r in Net:</p><p><img src=/image-20241202214641814.png alt=image-20241202214641814></p><p>S1:</p><p><img src=/image-20241202214728352.png alt=image-20241202214728352></p><p>S2:</p><p><img src=/image-20241202214746494.png alt=image-20241202214746494></p><p>S3:</p><p><img src=/image-20241202214803285.png alt=image-20241202214803285></p><p>S4:</p><p><img src=/image-20241202214851101.png alt=image-20241202214851101></p><h4 id=accuracy-control-scheme>Accuracy Control Scheme
<a class=anchor href=#accuracy-control-scheme>#</a></h4><p><img src=/image-20241202215422191.png alt=image-20241202215422191></p><p><img src=/image-20241202220420641.png alt=image-20241202220420641></p><h4 id=文件介绍>文件介绍
<a class=anchor href=#%e6%96%87%e4%bb%b6%e4%bb%8b%e7%bb%8d>#</a></h4><ul><li><p>flute.[ch]</p></li><li><p>查找表</p><blockquote><ul><li>POWV9.dat &ndash; The lookup-table of optimal POWVs up to degree 9.</li></ul><p><img src=/image-20241202211436906.png alt=image-20241202211436906></p><ul><li>POST9.dat &ndash; The lookup-table for optimal <strong>Steiner tree</strong> up to degree 9. (Note that it is formerly called PORT9.dat.)</li></ul></blockquote></li><li><p>TCAD 07 有相关优化（net breaking and merging techniques）</p><blockquote><ul><li>flute_mst.c &ndash; The net breaking and merging techniques described in the VLSIDAT 08 paper.</li><li>dist.[ch], dl.[ch], err.[ch], heap.[ch], mst2.[ch], neighbors.[ch], global.h &ndash; Utility functions used by flute_mst.c</li></ul></blockquote></li><li><p>evaluate</p><blockquote><ul><li>flute-net.c – A program to evaluate the wirelength of a net. It takes input from stdin as a list of points.</li><li>rand-pts.c &ndash; A program to generate a list of random points.</li></ul></blockquote></li><li><p>bookshelf</p><blockquote><ul><li>flute-ckt.c &ndash; A program to find FLUTE and half-perimeter wirelength of a circuit in <strong>bookshelf format.</strong></li><li>memAlloc.[ch] &ndash; Functions for flute-ckt.c to allocate memory.</li><li>ibm01/ibm01.* &ndash; ibm01 bookshelf files that can be read by flute-ckt.c</li></ul></blockquote></li></ul><h4 id=实验结果>实验结果
<a class=anchor href=#%e5%ae%9e%e9%aa%8c%e7%bb%93%e6%9e%9c>#</a></h4><p><img src=/image-20241202220545686.png alt=image-20241202220545686></p><h4 id=模型>模型
<a class=anchor href=#%e6%a8%a1%e5%9e%8b>#</a></h4><p><strong>输入</strong></p><p><strong>结构</strong></p><p><strong>输出</strong></p><h4 id=参考>参考
<a class=anchor href=#%e5%8f%82%e8%80%83>#</a></h4><ul><li><a href=https://pdfs.semanticscholar.org/01a6/716144fcd0b88f607e718b78c909bfca415e.pdf>pdfs.semanticscholar.org/01a6/716144fcd0b88f607e718b78c909bfca415e.pdf</a></li><li><a href=https://home.engineering.iastate.edu/~cnchu/flute.html#Source_Code>FLUTE</a></li></ul><h2 id=模式布线>模式布线
<a class=anchor href=#%e6%a8%a1%e5%bc%8f%e5%b8%83%e7%ba%bf>#</a></h2><p><img src=/image-20241116104253227.png alt=image-20241116104253227></p><p><img src=/image-20241116104312714.png alt=image-20241116104312714></p><p><img src=C:%5cUsers%5cuser%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20241114211505856.png alt=image-20241114211505856></p><p>单调</p><p><img src=/image-20241116104539591.png alt=image-20241116104539591></p><p><img src=/image-20241116104758295.png alt=image-20241116104758295></p><p><img src=/image-20241116121551882.png alt=image-20241116121551882></p><p>FastRoute 4.0 的 <strong>3-bend Routing</strong></p><p><img src=/image-20241116122814565.png alt=image-20241116122814565></p><p><img src=/image-20241116122951917.png alt=image-20241116122951917></p><h2 id=迷宫算法>迷宫算法
<a class=anchor href=#%e8%bf%b7%e5%ae%ab%e7%ae%97%e6%b3%95>#</a></h2><h3 id=概念-2>概念
<a class=anchor href=#%e6%a6%82%e5%bf%b5-2>#</a></h3><p><img src=/image-20241116101300127.png alt=image-20241116101300127></p><h3 id=李氏算法>李氏算法
<a class=anchor href=#%e6%9d%8e%e6%b0%8f%e7%ae%97%e6%b3%95>#</a></h3><p>有点像 BFS</p><h3 id=a算法>A*算法
<a class=anchor href=#a%e7%ae%97%e6%b3%95>#</a></h3><p><img src=/image-20241116101757326.png alt=image-20241116101757326></p><p><img src=/image-20241116102003529.png alt=image-20241116102003529></p><p><img src=/image-20241116102229648.png alt=image-20241116102229648></p><p><img src=/image-20241116104054786.png alt=image-20241116104054786></p><p>往往是串行的，慢</p><p>往往需要多个 pin 的连线拆成一对一对，导致：</p><p><img src=C:%5cUsers%5cuser%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20241114211832214.png alt=image-20241114211832214></p><h3 id=线搜索算法>线搜索算法
<a class=anchor href=#%e7%ba%bf%e6%90%9c%e7%b4%a2%e7%ae%97%e6%b3%95>#</a></h3><p><img src=/image-20241116102852946.png alt=image-20241116102852946></p><p>Hetzel 算法</p><h2 id=pattern--maze>pattern + maze
<a class=anchor href=#pattern--maze>#</a></h2><p><img src=C:%5cUsers%5cuser%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20241114224403067.png alt=image-20241114224403067></p><h2 id=线序选择>线序选择
<a class=anchor href=#%e7%ba%bf%e5%ba%8f%e9%80%89%e6%8b%a9>#</a></h2><p>对于串行布线算法, 布线顺序对最终布线质量的影响很大</p><p><img src=/image-20241116125950327.png alt=image-20241116125950327></p><p><img src=/image-20241116125957916.png alt=image-20241116125957916></p><p>以上几种启发式的线序选择策略往往不能完全避免溢出。<strong>拆线重布（rip-up and reroute）</strong> 策略在初次布线完成后 ，对发生溢出的拥塞区域的线网进行拆除 ，并迭代地 <strong>调整线序多次重新布线</strong> ，直到溢出不再减少 ，或达到运行时间限制为止。</p><h2 id=拆线重布>拆线重布
<a class=anchor href=#%e6%8b%86%e7%ba%bf%e9%87%8d%e5%b8%83>#</a></h2><p><strong>rip-up and reroute</strong></p><p><img src=/image-20241116130243564.png alt=image-20241116130243564></p><p><img src=/image-20241116130255733.png alt=image-20241116130255733></p><p><img src=/image-20241116130311159.png alt=image-20241116130311159></p><p><img src=/image-20241116130321763.png alt=image-20241116130321763></p><h2 id=层分配>层分配
<a class=anchor href=#%e5%b1%82%e5%88%86%e9%85%8d>#</a></h2><h2 id=并行布线算法>并行布线算法
<a class=anchor href=#%e5%b9%b6%e8%a1%8c%e5%b8%83%e7%ba%bf%e7%ae%97%e6%b3%95>#</a></h2><h3 id=整数线性规划>整数线性规划
<a class=anchor href=#%e6%95%b4%e6%95%b0%e7%ba%bf%e6%80%a7%e8%a7%84%e5%88%92>#</a></h3><p><img src=/image-20241116103222298.png alt=image-20241116103222298></p><p><img src=/image-20241116103043878.png alt=image-20241116103043878></p><p><img src=/image-20241116103547635.png alt=image-20241116103547635></p><h3 id=线性规划>线性规划
<a class=anchor href=#%e7%ba%bf%e6%80%a7%e8%a7%84%e5%88%92>#</a></h3><p><img src=/image-20241116131219874.png alt=image-20241116131219874></p><h1 id=数据集>数据集
<a class=anchor href=#%e6%95%b0%e6%8d%ae%e9%9b%86>#</a></h1><h2 id=文件定义>文件定义
<a class=anchor href=#%e6%96%87%e4%bb%b6%e5%ae%9a%e4%b9%89>#</a></h2><p><img src=C:%5cUsers%5cuser%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20241115115752329.png alt=image-20241115115752329></p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/alex-shpak/hugo-book/commit/558fe9e6a91fcab8fceb5cf8e0e72df4b2de59b9 title='最后修改者 pxhg02 | 二月 26, 2025' target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt>
<span>二月 26, 2025</span></a></div><div><a class="flex align-center" href=https://github.com/alex-shpak/hugo-book/edit/main/exampleSite/content.zh/docs/Digtal/Digtal/Routing/routing2.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt>
<span>编辑本页</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#简介>简介</a><ul><li><a href=#gr--dr>GR & DR</a></li><li><a href=#background><strong>background</strong></a></li><li><a href=#输入><strong>输入</strong></a></li><li><a href=#输出><strong>输出</strong></a></li><li><a href=#优化指标><strong>优化指标</strong></a></li><li><a href=#约束><strong>约束</strong></a></li></ul></li><li><a href=#global-router>Global Router</a><ul><li><a href=#概念>概念</a></li><li><a href=#term>term</a></li><li><a href=#challenge>challenge</a></li><li><a href=#技术方向>技术方向</a></li><li><a href=#问题建模>问题建模</a></li><li><a href=#fasterroute41-in-openroad>FasterRoute4.1 in OpenROAD</a><ul><li><a href=#结构>结构</a></li></ul></li><li><a href=#cugr>CUGR</a><ul><li><a href=#install>install</a></li><li><a href=#run>run</a></li></ul></li><li><a href=#fastroute-1>FastRoute</a><ul><li><a href=#install-1>install</a></li></ul></li><li><a href=#cugr-20>CUGR 2.0</a></li><li><a href=#instantgr>InstantGR</a><ul><li><a href=#model>model</a></li><li><a href=#flow>flow</a></li><li><a href=#install-2>install</a></li><li><a href=#debug-1>debug</a></li></ul></li><li><a href=#contest>contest</a><ul><li><a href=#ispd-07>ISPD 07</a></li><li><a href=#ispd-08>ISPD 08</a></li><li><a href=#iccad-19-contest-problem-c--gr-use-real-world-design-and-evaluate-by-drouter>ICCAD 19 Contest Problem C: GR use Real world design and evaluate by DRouter</a></li><li><a href=#ispd24-contest-gpuml-enhanced-large-scale-global-routing-contest><strong>ISPD’24 Contest: GPU/ML-Enhanced Large Scale Global Routing Contest</strong></a></li><li><a href=#ispd25-contest-performance-driven-large-scale-global-routing><a href=https://github.com/liangrj2014/ISPD25_contest/blob/main/index.md>ISPD25 Contest: Performance-Driven Large Scale Global Routing</a></a></li></ul></li></ul></li><li><a href=#detail-router>Detail Router</a><ul><li><a href=#概念-1>概念</a></li><li><a href=#问题建模-1>问题建模</a></li><li><a href=#contest-1>Contest</a><ul><li><a href=#ispd-2018>ISPD-2018</a></li><li><a href=#ispd-2019>ISPD-2019</a></li></ul></li></ul></li><li><a href=#算法>算法</a><ul><li><a href=#最小树算法>最小树算法</a><ul><li></li><li><a href=#flute-1>FLUTE</a></li></ul></li><li><a href=#模式布线>模式布线</a></li><li><a href=#迷宫算法>迷宫算法</a><ul><li><a href=#概念-2>概念</a></li><li><a href=#李氏算法>李氏算法</a></li><li><a href=#a算法>A*算法</a></li><li><a href=#线搜索算法>线搜索算法</a></li></ul></li><li><a href=#pattern--maze>pattern + maze</a></li><li><a href=#线序选择>线序选择</a></li><li><a href=#拆线重布>拆线重布</a></li><li><a href=#层分配>层分配</a></li><li><a href=#并行布线算法>并行布线算法</a><ul><li><a href=#整数线性规划>整数线性规划</a></li><li><a href=#线性规划>线性规划</a></li></ul></li></ul></li><li><a href=#数据集>数据集</a><ul><li><a href=#文件定义>文件定义</a></li></ul></li></ul></nav></div></aside></main></body></html>