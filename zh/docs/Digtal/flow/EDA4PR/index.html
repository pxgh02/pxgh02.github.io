<!doctype html><html lang=zh dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="
  研究背景
  #

**典型的芯片设计流程是先做前端、后端设计，再去验证性能、功耗和面积。**但由于流程太长，在前端设计的时候，无法保证后端设计的效果，所以很多时候需要进行跨环节建模，在早期设计环节预测后续环节的求解质量，这当中就很适合AI算法来进行辅助。
除了建模之外，另外一个关键问题是优化。EDA中经常要求解各种各样的组合优化问题。这些问题往往是 NP难题，比如经典的旅行商问题。传统上，我们会通过一些启发探索的方法来求解。但随着规模不断增大、设计约束越来越多，这种探索往往遇到效率瓶颈，所以我们需要通过机器学习技术进行辅助，寻找有效策略，提高效率。

  

  难点
  #


  

大图&ndash;>
数据集&ndash;>
泛化能力&ndash;>
非DAG?
route: 3D，45°，30°
先进的工艺：7nm
很多Placer and Router还是有很多人工定义的超参数？（不general）
现在真的还有必要把Router分成Global 和Detail 吗？
GR: total maze routing
GR: Consider timing and power consumption


  研究方向
  #


  Cross-Stage Prediction
  #


  routing congestion prediction
  #


  background
  #



Routing congestion can overwhelm routing resources and lead to low cell utilization and routing detours


congestion is not known accurately until late in the design cycle, after placement and routing."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://pxgh02.github.io/zh/docs/Digtal/flow/EDA4PR/"><meta property="og:site_name" content="Pxmmmm"><meta property="og:title" content="EDA4PR"><meta property="og:description" content="研究背景 # **典型的芯片设计流程是先做前端、后端设计，再去验证性能、功耗和面积。**但由于流程太长，在前端设计的时候，无法保证后端设计的效果，所以很多时候需要进行跨环节建模，在早期设计环节预测后续环节的求解质量，这当中就很适合AI算法来进行辅助。
除了建模之外，另外一个关键问题是优化。EDA中经常要求解各种各样的组合优化问题。这些问题往往是 NP难题，比如经典的旅行商问题。传统上，我们会通过一些启发探索的方法来求解。但随着规模不断增大、设计约束越来越多，这种探索往往遇到效率瓶颈，所以我们需要通过机器学习技术进行辅助，寻找有效策略，提高效率。
难点 # 大图–> 数据集–> 泛化能力–> 非DAG? route: 3D，45°，30° 先进的工艺：7nm 很多Placer and Router还是有很多人工定义的超参数？（不general） 现在真的还有必要把Router分成Global 和Detail 吗？ GR: total maze routing GR: Consider timing and power consumption 研究方向 # Cross-Stage Prediction # routing congestion prediction # background # Routing congestion can overwhelm routing resources and lead to low cell utilization and routing detours
congestion is not known accurately until late in the design cycle, after placement and routing."><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2025-02-20T08:46:41+00:00"><title>EDA4PR | Pxmmmm</title>
<link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://pxgh02.github.io/zh/docs/Digtal/flow/EDA4PR/><link rel=stylesheet href=/book.min.6c8b9d2a1fc95075ed7da46ca81060b39add8fff6741ac51259f768929281e2c.css integrity="sha256-bIudKh/JUHXtfaRsqBBgs5rdj/9nQaxRJZ92iSkoHiw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/zh.search.min.e55985c3c7a597425e225a95aa27795684bb1e15895b2e76889075965d30b630.js integrity="sha256-5VmFw8ell0JeIlqVqid5VoS7HhWJWy52iJB1ll0wtjA=" crossorigin=anonymous></script><script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/zh/><span>Pxmmmm</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=搜索 aria-label=搜索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul class=book-languages><li><input type=checkbox id=languages class=toggle>
<label for=languages class="flex justify-between"><a role=button class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
Chinese</a></label><ul><li><a href=/>English</a></li></ul></li></ul><ul><li><input type=checkbox id=section-a7a8fb3cc34544172ff5103ce3adf7cc class=toggle>
<label for=section-a7a8fb3cc34544172ff5103ce3adf7cc class="flex justify-between"><a href=/zh/docs/Other/>Other</a></label><ul><li><a href=/zh/docs/Other/Algorithms/>Algorithms</a></li><li><a href=/zh/docs/Other/git/>Git</a></li><li><a href=/zh/docs/Other/Hardware/>Hardware</a></li><li><a href=/zh/docs/Other/linux/>Linux</a></li><li><a href=/zh/docs/Other/Literature/>Literature</a></li><li><a href=/zh/docs/Other/makefile/>Makefile</a></li><li><a href=/zh/docs/Other/network/>Network</a></li><li><a href=/zh/docs/Other/Program/>Program</a></li><li><a href=/zh/docs/Other/Tools/>Tools</a></li><li><a href=/zh/docs/Other/window/>Window</a></li><li><a href=/zh/docs/Other/Writing-PPT-Presentation/>Writing Ppt Presentation</a></li></ul></li><li><input type=checkbox id=section-546194909198d851b05dc5d16088b0b9 class=toggle checked>
<label for=section-546194909198d851b05dc5d16088b0b9 class="flex justify-between"><a href=/zh/docs/Digtal/>Physical Design</a></label><ul><li><input type=checkbox id=section-9bc128912acae8559e0b27b496b7779b class=toggle checked>
<label for=section-9bc128912acae8559e0b27b496b7779b class="flex justify-between"><a href=/zh/docs/Digtal/flow/EDA4PR/ class=active>EDA4PR</a></label></li><li><input type=checkbox id=section-50846ac4cdec99c8bd1f8b0417acad9a class=toggle>
<label for=section-50846ac4cdec99c8bd1f8b0417acad9a class="flex justify-between"><a href=/zh/docs/Digtal/flow/flow/>Flow</a></label></li><li><input type=checkbox id=section-b2241e4da59f24976e354abe344e8d4f class=toggle>
<label for=section-b2241e4da59f24976e354abe344e8d4f class="flex justify-between"><a href=/zh/docs/Digtal/Placement/placement/>Placement</a></label></li><li><input type=checkbox id=section-259735f9bf2708d778569b162c141df5 class=toggle>
<label for=section-259735f9bf2708d778569b162c141df5 class="flex justify-between"><a href=/zh/docs/Digtal/Routing/routing2/>Routing</a></label></li><li><input type=checkbox id=section-78b8f069c0c130e55062b802fff78361 class=toggle>
<label for=section-78b8f069c0c130e55062b802fff78361 class="flex justify-between"><a href=/zh/docs/Digtal/Routing/routing1/>Routing1</a></label></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>EDA4PR</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#研究背景>研究背景</a></li><li><a href=#难点>难点</a></li><li><a href=#研究方向>研究方向</a><ul><li><a href=#cross-stage-prediction>Cross-Stage Prediction</a><ul><li><a href=#routing-congestion-prediction>routing congestion prediction</a></li><li><a href=#timing-prediction>Timing Prediction</a></li></ul></li><li><a href=#optimization>Optimization</a><ul><li><a href=#timing>Timing</a></li><li><a href=#marco-placement>Marco Placement</a></li><li><a href=#placement>Placement</a></li><li><a href=#routing>Routing</a></li></ul></li><li><a href=#pr-tools>PR Tools</a><ul><li><a href=#placer>Placer</a></li><li><a href=#router>Router</a></li></ul></li></ul></li><li><a href=#综述>综述</a><ul><li><a href=#ml4pr>ML4PR</a></li><li><a href=#超大规模集成电路布线算法综述>超大规模集成电路布线算法综述</a></li><li><a href=#edagnn>EDA+GNN</a></li></ul></li><li><a href=#参考>参考</a></li><li><a href=#bak>bak</a></li><li><a href=#相关数据集>相关数据集</a><ul><li><a href=#only-rtl>only rtl</a><ul><li><a href=#home--opencores><a href=https://opencores.org/>Home :: OpenCores</a></a></li><li><a href=#iwls-2005-benchmarks><a href=https://iwls.org/iwls2005/benchmarks.html>IWLS 2005 Benchmarks</a></a></li><li><a href=#openlane-examples-examples-from-the-openlane-repository><a href=https://github.com/klasnordmark/openlane-examples>openlane-examples: Examples from the Openlane repository</a></a></li></ul></li><li><a href=#global-route>Global route</a><ul><li><a href=#ispd-2007>ISPD-2007</a></li><li><a href=#ispd-2008>ISPD-2008</a></li><li><a href=#iccad-2019>ICCAD-2019</a></li><li><a href=#ispd-2024>ISPD-2024</a></li><li><a href=#ispd-2025>ISPD-2025</a></li></ul></li><li><a href=#detail-route>Detail Route</a><ul><li><a href=#ispd-20182019>ISPD-2018/2019</a></li></ul></li><li><a href=#congestiondrcir-droptiming>congestion/DRC/IR drop/timing</a></li></ul></li><li><a href=#相关会议期刊>相关会议/期刊</a><ul><li><a href=#会议>会议</a></li><li><a href=#期刊>期刊</a></li><li><a href=#参考-1>参考</a></li></ul></li><li><a href=#相关科研实验室>相关科研实验室</a><ul><li><a href=#清华>清华</a></li><li><a href=#北大-无锡eda研究院>北大-无锡EDA研究院</a></li><li><a href=#复旦>复旦</a></li><li><a href=#北航>北航</a></li><li><a href=#港中文-eda-center>港中文-EDA Center</a></li><li><a href=#chen-tinghuan>CHEN, Tinghuan</a></li><li><a href=#福大>福大</a></li><li><a href=#上海交大>上海交大</a></li><li><a href=#东南大学-国家asic工程中心>东南大学-国家ASIC工程中心</a></li><li><a href=#华中科技大学>华中科技大学</a></li><li><a href=#西安电子科技大学>西安电子科技大学</a></li><li><a href=#广东工业大学>广东工业大学</a></li><li><a href=#国立清华大学>国立清华大学</a></li><li><a href=#university-of-california>University of California</a></li></ul></li><li><a href=#相关企业机构>相关企业/机构</a><ul><li><a href=#华为诺亚方舟--海思>华为诺亚方舟 & 海思</a></li><li><a href=#eda国创中心>EDA国创中心</a></li><li><a href=#芯行纪><a href=https://www.xtimes-da.com/>芯行纪</a></a><ul><li><a href=#amazesys>AmazeSys</a></li><li><a href=#amazefp>AmazeFP</a></li><li><a href=#amazefp-me>AmazeFP-ME</a></li><li><a href=#amazedrclite>AmazeDRCLite</a></li><li><a href=#云>云</a></li></ul></li><li><a href=#华大九天>华大九天</a><ul><li><a href=#pyaether>PyAether</a></li></ul></li><li><a href=#概伦电子>概伦电子</a></li><li><a href=#鸿芯微纳>鸿芯微纳</a></li><li><a href=#华芯巨数>华芯巨数</a></li><li><a href=#嘉立创>嘉立创</a></li></ul></li><li><a href=#相关竞赛>相关竞赛</a><ul><li><a href=#cadathloniccad>CADathlon@ICCAD</a></li><li><a href=#contestispd>Contest@ISPD</a></li><li><a href=#cad-contesticcad>CAD Contest@ICCAD</a><ul><li><a href=#历年相关赛题>历年相关赛题</a></li></ul></li><li><a href=#侠客岛>侠客岛</a></li><li><a href=#eda精英挑战赛>EDA精英挑战赛</a></li><li><a href=#tau-contest>TAU Contest</a></li><li><a href=#programming-contestiwls><a href=https://www.iwls.org/contest/>Programming Contest@IWLS</a></a></li><li><a href=#全国大学生集成电路创新创业大赛的华大九天赛道>“全国大学生集成电路创新创业大赛”的华大九天赛道</a></li><li><a href=#llm4hwdesign-contest>LLM4HWDesign Contest</a></li><li><a href=#dac-system-design-contest><a href=https://pku-sec-lab.github.io/dac-sdc-2024/><strong>DAC System Design Contest</strong></a></a></li><li><a href=#参考-2>参考</a></li></ul></li><li><a href=#相关pdk>相关PDK</a></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=研究背景>研究背景
<a class=anchor href=#%e7%a0%94%e7%a9%b6%e8%83%8c%e6%99%af>#</a></h1><p>**典型的芯片设计流程是先做前端、后端设计，再去验证性能、功耗和面积。**但由于流程太长，在前端设计的时候，无法保证后端设计的效果，所以很多时候需要进行跨环节建模，在早期设计环节预测后续环节的求解质量，这当中就很适合AI算法来进行辅助。</p><p>除了建模之外，另外一个关键问题是优化。EDA中经常要求解各种各样的组合优化问题。这些问题往往是 NP难题，比如经典的旅行商问题。传统上，我们会通过一些启发探索的方法来求解。但随着规模不断增大、设计约束越来越多，这种探索往往遇到效率瓶颈，所以我们需要通过机器学习技术进行辅助，寻找有效策略，提高效率。</p><p><img src=/image-20250105141458960.png alt=image-20250105141458960></p><h1 id=难点>难点
<a class=anchor href=#%e9%9a%be%e7%82%b9>#</a></h1><p><img src=/image-20241013184936794.png alt=image-20241013184936794></p><ol><li>大图&ndash;></li><li>数据集&ndash;></li><li>泛化能力&ndash;></li><li>非DAG?</li><li>route: 3D，45°，30°</li><li>先进的工艺：7nm</li><li>很多Placer and Router还是有很多人工定义的超参数？（不general）</li><li>现在真的还有必要把Router分成Global 和Detail 吗？</li><li>GR: total maze routing</li><li>GR: Consider timing and power consumption</li></ol><h1 id=研究方向>研究方向
<a class=anchor href=#%e7%a0%94%e7%a9%b6%e6%96%b9%e5%90%91>#</a></h1><h2 id=cross-stage-prediction>Cross-Stage Prediction
<a class=anchor href=#cross-stage-prediction>#</a></h2><h3 id=routing-congestion-prediction>routing congestion prediction
<a class=anchor href=#routing-congestion-prediction>#</a></h3><h4 id=background>background
<a class=anchor href=#background>#</a></h4><ul><li><p>Routing congestion can overwhelm routing resources and lead to low cell utilization and routing detours</p></li><li><p>congestion is not known accurately until late in the design cycle, after placement and routing.</p></li><li><p>Many modern placement and synthesis tools leverage congestion estimation in their cost analysis in order to minimize the effects of congestion in the final physical design</p></li><li><p><img src=/image-20241101193119582.png alt=image-20241101193119582></p></li><li><p>It is known that the total net length can be a good proxy for congestion</p></li><li><p>A simple approximation for congestion prediction is to use the size of the local neighborhood</p></li><li><p><img src=/image-20241102170308031.png alt=image-20241102170308031></p></li><li><p>和fan-in, fan-out强相关</p></li><li><p>Precise congestion prediction from a placement solution plays a crucial role in circuit placement</p></li><li><p>Multiple <strong>previous works</strong> have attempted to predict detailed routing congestion in the <strong>placement step</strong> in an effort to optimize routability of the placement solution: RUDY, POLAR 2.0. All these techniques are implemented in the placement step and need the position information of cells .</p></li><li><p>To avoid the high computation cost of placement, it is more useful to be able to predict congestion in the logic synthesis phase.</p></li><li><p>congestion prediction problem can be frame as <strong>node regression problem</strong></p></li><li><p>with the growth of circuit scale and complexity, time consumption
tends to be unacceptable when utilizing a <strong>global router</strong> in the placement cycle to obtain the <strong>congestion map</strong>.</p></li><li><p>Current machine learning models commonly follow a two-phase workflow. First, based on domain knowledge, human experts generate various local features on the circuit using predefined functions on netlist. Then, based on the generated features, a specific model, e.g. convolution neural network (CNN) model is designed to predict either the routing demand map or the congestion map</p></li><li><p>the emergence of <strong>Graph Neural Network (GNN)</strong> triggered applications of undirected homogeneous graphs models on routing congestion prediction, since a VLSI circuit can be naturally represented by a graph</p></li><li></li></ul><h4 id=routenet-drc-hotspot-prediction-iccad-2018-cnn><a href=https://zhiyaoxie.com/files/ICCAD18_RouteNet.pdf>RouteNet-DRC Hotspot Prediction-ICCAD-2018-CNN</a>
<a class=anchor href=#routenet-drc-hotspot-prediction-iccad-2018-cnn>#</a></h4><p><strong>background:</strong></p><ul><li><p>Every chip design project must complete routing <strong>without design rule violation</strong> before tapeout. However, this basic requirement is often difficult to be satisfied especially when routability is not adequately considered in early design stages.</p></li><li><p>In light of this fact, routability prediction has received serious attention in both academic research and industrial tool development. Moreover, routability is widely recognized as a main objective for <strong>cell placement</strong></p></li><li><p>CNN and Transfer Learning</p><ul><li>CNN learns more abstract patterns from images</li><li>Our RouteNet transfers such state-of-the-art ability in image pattern recognition to circuits for capturing the patterns about routability. RouteNet predicts routability based on a pretrained ResNet architecture</li><li>Fully Convolutional Network (FCN): outputs an image with size equal to or smaller than input. many FCNs have both deep and shallow paths in one network.</li></ul></li><li><p>RUDY(Rectangular Uniform wire DensitY)</p><ul><li>它被用作我们RouteNet的输入特征，因为它与路由拥塞部分相关，获取速度快，可以直接表示为与RouteNet相吻合的图像</li></ul></li><li><p>challenge of macros</p><p><img src=/image-20250205214716706.png alt=image-20250205214716706></p><ul><li>The orange circles in Figure 3 indicate a strong tendency for hotspots to aggregate at the small gap between neighboring macros</li><li>Blue dashed circles indicate the remaining sparsely distributed hotspots</li><li><img src=/image-20250205220737891.png alt=image-20250205220737891></li><li>有macro，线性程度低</li></ul></li></ul><p><strong>task:</strong></p><ul><li>predict overall routability (DRC count), 分类任务，预测总的#DRV</li><li>predict <code>DRC hotspot</code> locations.DRC hotspots mean the specific locations with high density of DRVs. like an end-to-end object detection task, which is more difficult to solve. GCell内#DRV超过设定值则为<code>DRC hotspot</code></li></ul><p><strong>contribution</strong>:</p><p><img src=/image-20250205210214325.png alt=image-20250205210214325></p><ul><li>mixed-size macros</li><li>first systematic study on CNN-based routability prediction</li><li>high accuracy and high speed</li><li></li></ul><p><strong>flow:</strong></p><p><img src=/image-20250205222502598.png alt=image-20250205222502598></p><p><strong>model</strong></p><ul><li><p>#DRV prediction</p><p>ResNet18-based</p><p><img src=/image-20250205223554347.png alt=image-20250205223554347></p><p>preprocess</p><ul><li><p><img src=/image-20250205223153166.png alt=image-20250205223153166></p></li><li><p><img src=/image-20250205223742770.png alt=image-20250205223742770></p><p>ResNet是一个固定输入（224*224）的模型，为了使用知识迁移，将输入
<img src=/image-20250205223907748.png alt=image-20250205223849469>。具体怎么插？</p></li></ul></li><li><p>hotspot prediction</p></li></ul><p><img src=/image-20250205224325007.png alt=image-20250205224325007></p><p><strong>data:</strong></p><p>dataset:</p><p>ISPD 2015 benchmarks</p><p><img src=/image-20250205225007139.png alt=image-20250205225007139></p><p>different placement made by “obstacle-aware macro placement" algorithm [5].</p><p>each floorplan is placed and routed by Cadence Encounter v14.20 [2]</p><p><strong>experiment:</strong></p><p><img src=/image-20250205230614878.png alt=image-20250205230614878></p><p><img src=/image-20250205230628088.png alt=image-20250205230628088></p><p><img src=/image-20250205230725019.png alt=image-20250205230725019></p><p>we compare the TPR of all methods under the same FPR (error under 1%)</p><p><img src=/image-20250205230816030.png alt=image-20250205230816030></p><h4 id=congestionnet-predict-congestion-hotspots-ifip-2019-gnngat-nvidia><a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=8920342&amp;tag=1">CongestionNet-predict congestion hotspots-IFIP-2019-GNN(GAT)-nvidia</a>
<a class=anchor href=#congestionnet-predict-congestion-hotspots-ifip-2019-gnngat-nvidia>#</a></h4><p>a <strong>graph</strong>-based deep learning method for predicting <strong>routing congestion hotspots</strong> from a <strong>netlist</strong> before placement. Predict the detail routed <strong>lower metal layer</strong> congestion values</p><p><img src=/image-20241101192745004.png alt=image-20241101192745004></p><p>why low layer? 因为较低金属层上的拥塞主要是由局部逻辑结构驱动的，而不是由无关逻辑簇之间的较长互连驱动的，后者往往在较高金属层上运行. predicting lower metal layer congestion is not only more important for the underlying task of identifying congested logic structures, but also simplifies the task for our
graph based network</p><p><strong>contribution:</strong></p><ul><li>阶段早,只使用网表</li><li>由于该模型仅基于网表的逻辑结构而不是任何特定的单元布局进行预测，因此它消除了基于布局的方法中存在的次优布局的伪影
<img src=/image-20241101192504194.png alt=image-20241101192504194></li><li>can be done without any physical information</li><li>GNN, 快</li><li>the first work exploring the use of graph based deep learning for physical design problems</li></ul><p><strong>数据:</strong></p><p><img src=/image-20241101194746768.png alt=image-20241101194746768></p><p><img src=/image-20241101195219055.png alt=image-20241101195219055></p><p>roughly 5000 distinct cell types</p><p>we project our per cell predictions back onto their respective 2D grid (using the <strong>final ground truth physical placement</strong>) and average all cells within each grid cell to come up with a predicted value that can be compared to the original ground truth grid value.</p><p><strong>模型参数:</strong></p><p>an 8 layer Graph Attention Network (GAT) with size 16 intermediate (or hidden) state</p><p>无向图, each node corresponds to a cell</p><p>节点特征: length 50 for each <strong>cell type</strong> and each cell’s <strong>logic description</strong> as well as the <strong>pin count</strong> and <strong>cell size</strong> of that cell</p><p><strong>实验:</strong></p><p>report correlation values using the <strong>Kendall ranking coefficient</strong></p><p>实际效果可视化</p><p><img src=/image-20241101211844804.png alt=image-20241101211844804></p><p><img src=/image-20241007114109425.png alt=image-20241007114109425></p><p>对比实验</p><p><img src=/image-20241101214611345.png alt=image-20241101214611345></p><p>消融实验</p><p><img src=/image-20241101214630174.png alt=image-20241101214630174></p><p>cell type or function is an essential part of our predictions.</p><p>cell type 不是没起作用吗</p><p><strong>缺点:</strong></p><ul><li>model needs to be <strong>retrained</strong> for every <strong>new process technology</strong>, since the embeddings are over cell types specific to a process technology.</li><li>it occasionally over predicts congestion in areas of <strong>low to moderate</strong> congestion, such as in most failing parts of Partition A</li><li>due to the <strong>graph based</strong> nature of the model, it sometimes makes <strong>overly soft decision</strong> boundaries</li><li><img src=/image-20241102170708557.png alt=image-20241102170708557></li><li>the CongestionNet uses informative cell attributes (cell size and pin count) alone as the input to the GAT and does not use any embedding encoding the netlist structure</li></ul><p><strong>可改进的点:</strong></p><p><img src=/image-20241101215450089.png alt=image-20241101215450089></p><h4 id=-congestion-prediction--embedding--matrix-factorization--partition-arxiv-2021-gnnsage-><a href=/zh/>-Congestion prediction + embedding + matrix factorization + partition-arXiv-2021-GNN(Sage)-</a>
<a class=anchor href=#-congestion-prediction--embedding--matrix-factorization--partition-arxiv-2021-gnnsage->#</a></h4><p><strong>background</strong></p><ul><li>predicting cell congestion due to improper logic combination can reduce the burden of subsequent physical implementations.</li><li>previous work: require informative cell features</li><li>Although the global routing result provides a good estimation of routing congestion [6], [19], an awareness of high congestion areas at an <strong>early</strong> design stage is of great importance to provide fast feedback and shorten design cycles</li><li>Multiple works have attempted to predict detailed <strong>routing congestion</strong> in the placement step in an effort to optimize <strong>routability</strong> of the placement solution</li><li></li></ul><p><strong>task</strong></p><p><img src=/image-20241102170157570.png alt=image-20241102170157570></p><ul><li><p>during the logic synthesis stage</p></li><li><p><img src=/image-20241102185917955.png alt=image-20241102185917955></p><p>到底是什么时候的congestion数据? Routing后的真实值还是预测plcament后的congestion RUDY预测值? 应该是<strong>Global Routing</strong>后的:强调了congestion value = wiring demand/routing capacity</p><p><img src=/image-20241102190757814.png alt=image-20241102190757814></p></li></ul><p><strong>contrbution</strong></p><p><strong>data</strong></p><p>DAC2012 contest benchmark</p><p><a href=http://archive.sigda.org/dac2012/contest/dac2012_contest.html>http://archive.sigda.org/dac2012/contest/dac2012_contest.html</a></p><p><img src=/image-20241102185210635.png alt=image-20241102185210635></p><p>OpenROAD dataset</p><p><img src=/image-20241102185314200.png alt=image-20241102185314200></p><ul><li><p>place via <strong>DREAMPLACE</strong></p></li><li><p><img src=/image-20241102185814366.png alt=image-20241102185814366></p></li><li><p>Macros and terminals are removed from the graph</p></li><li><p>Nets with degree more than 10 are excluded from the final graph as they introduce cliques too large to work with efficiently.</p></li><li><p>node features (pin number, cell size) , This follows the flow of CongestionNet</p></li><li><p><img src=/image-20241102190725383.png alt=image-20241102190725383></p></li><li><p><strong>flow:</strong></p><p><img src=/image-20241102193019887.png alt=image-20241102193019887></p></li><li><p>congestion value for each grid cell computed as the wiring demand divided by the routing capacity , The output along the z-axis is reduced by a max function,</p></li><li><p>Our focus is on predicting congestion due to local logic structure, which manifests itself on lower metal layers. Therefore, we use congestion labels from the lower half of the metal layers to train and evaluate the model</p></li><li><p>推理的时候取所有cell的预测平均值</p></li></ul><p><strong>principle</strong></p><ul><li><p>提出相连越近的节点相似度越高,</p></li><li><p>提出structural node similarity</p><p><img src=/image-20241102182916257.png alt=image-20241102182916257></p></li><li><p>Sub-graph partition ? METIS? ClusterGCN?</p></li><li><p>Matrix Factorization ?</p></li></ul><p><strong>model</strong></p><ul><li><p>The key <strong>difference</strong> between this approach and <strong>CongestionNet</strong> lies in <strong>embedding</strong> pipeline</p></li><li><p>graph is undirected complete circuit is too <strong>large</strong> for direct matrix factorization and must be <strong>partitioned</strong> into clusters, use <strong>METIS</strong> partitioning tool in <strong>ClusterGCN</strong></p></li><li><p>Sub-graph partition: clusters of ≈ 5000 nodes each</p></li><li><p>Matrix Factorization ?</p></li><li></li></ul><p><strong>experiment</strong></p><p>three metrics of correlation to measure performance: <strong>Pearson, Spearman, Kendall</strong></p><p>Before evaluation, both the prediction and the label have some (very low) <strong>noise</strong> added to them.</p><p><img src=/image-20241102204924004.png alt=image-20241102204924004></p><p><img src=/image-20241102204932495.png alt=image-20241102204932495></p><p><img src=/image-20241102204956720.png alt=image-20241102204956720></p><p><img src=/image-20241102205029766.png alt=image-20241102205029766></p><h4 id=pgnn-drvs-predictionpin-proximity-graph-iccad-2022-gnnunetcnn-korea><a href=/zh/>PGNN-DRVs prediction+Pin Proximity Graph-ICCAD-2022-GNN+UNet(CNN)-Korea</a>
<a class=anchor href=#pgnn-drvs-predictionpin-proximity-graph-iccad-2022-gnnunetcnn-korea>#</a></h4><p><strong>background</strong></p><ul><li><p>(1) pin accessibility and (2) routing congestion are two major causes of DRVs (design rule violations)</p></li><li><p>Particularly, the complex design rules put so much burden on physical design, demanding lots of iterations on the time-consuming process of cell placement and net routing to <strong>clean up all DRVs (design rule violations)</strong> before tapping out . Thus, at the placement stage, if we were able to identify, with high confidence, DRC (design rule check) hotspots that would be
likely to occur at the routing stage, we can pay more attention</p></li><li><p>shortcoming of <strong>image based</strong>:</p><p>local pin accessibility cannot be accurately modeled by pin pattern <strong>image</strong> alone</p><p>using high-resolution pin pattern images incur significant additional <strong>run-time</strong> as well as <strong>memory</strong> overhead to the prediction models</p></li><li><p>to optimize the placement before routing.</p></li></ul><p><strong>task</strong></p><p>a novel ML based DRC hotspot prediction technique,</p><ul><li>GNN is used to embed pin accessibility information, <strong>U-net</strong> is used to extract routing congestion information from grid-based
features</li><li><img src=/image-20241108113804178.png alt=image-20241108113804178></li><li><img src=/image-20241108100942346.png alt=image-20241108100942346></li><li>placement 分割为grid, 长宽=G-Cell</li><li>DRVs are extracted as the ground-truth after <strong>detailed routing</strong></li></ul><p><strong>contribution</strong></p><ul><li>GNN model, base pin proximity graph</li><li></li></ul><p><strong>model</strong></p><p>PGNN can adopt pin proximity graph as well as grid-based feature map as input feature</p><p>Pin Proximity Graph :</p><ul><li>无向图， 同构图</li></ul><p><img src=/image-20241108105308585.png alt=image-20241108105308585></p><p><img src=/image-20241108105400483.png alt=image-20241108105400483></p><p>U-Net:</p><p><img src=/image-20241108100615500.png alt=image-20241108100615500></p><p>featrue:</p><p><img src=/image-20241108111019050.png alt=image-20241108111019050></p><p><img src=/image-20241108111430728.png alt=image-20241108111430728></p><p>整体模型:</p><p><img src=/image-20241108110729825.png alt=image-20241108110729825></p><p><strong>数据集</strong>:</p><p><img src=/image-20241108111933323.png alt=image-20241108111933323></p><p>以后也可以这么做, 同一个benchmark不同的config参数就有不同的数据</p><p><strong>experiment</strong></p><p>Nangate 15nm library</p><p>9 groups are used for training and the remaining 1 group for test. K折验证</p><p><img src=/image-20241108112502662.png alt=image-20241108112502662></p><p>positive 和 negative是什么意思?</p><p>可视化:</p><p><img src=/image-20241108102857037.png alt=image-20241108102857037></p><p>消融实验:</p><p><img src=/image-20241108112646099.png alt=image-20241108112646099></p><p>以后也可以这样用特征消融?</p><p>对比实验(F1-score):</p><p><img src=/image-20241108112751008.png alt=image-20241108112751008></p><p><img src=/image-20241108114209199.png alt=image-20241108114209199></p><ul><li><p>注意不需要GR!</p></li><li><p><strong>GR-Cong</strong> is obtained from ICC2 after global routing stage, and grids with high routing congestion are classified as DRC hotspot. 商用</p></li><li><p>RouteNet和J-Net都是相关的学术工作</p></li></ul><p>时间对比:</p><p><img src=/image-20241108114501484.png alt=image-20241108114501484></p><h4 id=lhnn-congestionprediction-dac-2022-gnn-cuhkhuaweiyibolin><a href=/zh/>LHNN-CongestionPrediction-DAC-2022-GNN-CUHK+Huawei+YiboLin</a>
<a class=anchor href=#lhnn-congestionprediction-dac-2022-gnn-cuhkhuaweiyibolin>#</a></h4><p><strong>background</strong></p><ul><li>图的节点的设置很新颖</li><li>with the growth of circuit scale and complexity, time consumption
tends to be unacceptable when utilizing a <strong>global router</strong> in the placement cycle to obtain the <strong>congestion map</strong>.</li><li>due to the need for the <strong>&ldquo;shift-left&rdquo;</strong> in circuit design, researchers begin to seek alternative solutions in machine learning [4] [5] to achieve accurate and fast congestion map prediction</li></ul><p><strong>task</strong></p><ul><li>two related tasks, <strong>routing demand regression</strong> and <strong>congestion classification</strong></li></ul><p><strong>data</strong></p><p>regard each <strong>G-cell</strong> <strong>as a node</strong> and add an edge between two nodes if the respective two G-cells are adjacent.</p><p><strong>hypergraphs and heterogeneous graph</strong> , 两种节点：G-cell和G-net</p><p><img src=/image-20241108141650136.png alt=image-20241108141650136></p><p><img src=/image-20241108142449292.png alt=image-20241108142449292></p><ul><li><p>feature：</p><p><img src=/image-20241108142931213.png alt=image-20241108142931213></p></li></ul><p><img src=/image-20241108145640376.png alt=image-20241108145640376></p><p>ISPD 2011 [16] and DAC 2012 [17] contest benchmarks ,</p><p><strong>model</strong></p><p><img src=/image-20241219145252874.png alt=image-20241219145252874></p><p><img src=/image-20241108144617443.png alt=image-20241108144617443></p><p>他这里说congestion map是一个二值化(0/1?)的数据集， 所以是分类任务, 但是为了利用数据，同时防止routing demand的信息丢失， 还设置了一个预测routing demand的任务？</p><p><strong>experiment</strong></p><p>15benchmarks: 10 for training and 5 for testing</p><p>run <strong>DREAMPlace</strong> [18] on each of the designs to generate placement solutions</p><p><strong>NCTU-GR 2.0</strong> [2] to attain horizontal/vertical <strong>routing demand maps</strong> , and set the <strong>congestion maps</strong> as a <strong>binary</strong> indicator according to whether the horizontal/vertical routing demand of the G-cell <strong>exceeds the circuit’s capacity</strong></p><p><img src=/image-20241108150810402.png alt=image-20241108150810402></p><p><img src=/image-20241108150803029.png alt=image-20241108150803029></p><p><img src=/image-20241108150837509.png alt=image-20241108150837509></p><p>对比实验：</p><p><img src=/image-20241108151611413.png alt=image-20241108151611413></p><p><img src=/image-20241108151757751.png alt=image-20241108151757751></p><p>可视化：</p><p><img src=/image-20241108150918563.png alt=image-20241108150918563></p><p>消融实验：</p><p><img src=/image-20241108152104185.png alt=image-20241108152104185></p><h4 id=-nn-robustness-improve-arxiv-2024---uc-><a href=/zh/>-NN Robustness improve-arXiv-2024- -UC-</a>
<a class=anchor href=#-nn-robustness-improve-arxiv-2024---uc->#</a></h4><p><strong>background:</strong></p><ul><li>最近的工作已经证明神经网络通常是容易受到精心选择的输入小扰动的影响</li><li>Our definition of <strong>imperceptibility</strong> is characterized by a guarantee that a perturbation to a layout will not alter its global routing</li><li>recent work [10, 18] has demonstrated that image classifiers can be <strong>fooled</strong> by <strong>small, carefully chosen</strong> perturbations of their input</li><li><img src=/image-20250102215202387.png alt=image-20250102215202387></li></ul><p><strong>task</strong></p><ul><li>design two efficient methods for finding perturbations that demonstrate brittleness of recently proposed congestion predictors</li><li>one potential approach to address the issues by modifying the training procedure to promote robustness</li></ul><p><strong>contribution</strong></p><p><a href=https://ieeexplore.ieee.org/document/8807040>Painting on PIacement-predict the routing congestion-ACM-2019-GAN-</a></p><p><img src=/image-20241012153331855.png alt=image-20241012153331855></p><p><img src=/image-20241012153541960.png alt=image-20241012153541960></p><p><a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=9401274">-DRC Hotspot Prediction-ISCAS-2021-CNN</a></p><p><a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=9045178">-Routing Congestion Prediction-ASPDAC-2020-GAN</a></p><ul><li>slice
<a href=https://yibolin.com/publications/papers/FPGA_ASPDAC2020_Alawieh.slides.pdf>FPGACong_ASPDAC20 (yibolin.com)</a></li></ul><p><a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=8715126">-predict #DRV, a macro placer-DATE-2019-CNN</a></p><h3 id=timing-prediction>Timing Prediction
<a class=anchor href=#timing-prediction>#</a></h3><h4 id=pre-routing-timing-prediction>Pre-Routing Timing Prediction
<a class=anchor href=#pre-routing-timing-prediction>#</a></h4><h5 id=background-1>background
<a class=anchor href=#background-1>#</a></h5><p><img src=/image-20241026164128136.png alt=image-20241026164128136></p><h5 id=relate-work>relate work
<a class=anchor href=#relate-work>#</a></h5><p><a href=https://dl.acm.org/doi/abs/10.1145/3489517.3530597>TimingGCN-STA prediction-DAC-2022-GNN</a></p><ul><li>the first work！</li><li>opensource</li><li>still relies on local net/cell delay prediction as auxiliary tasks</li><li>no optimization, not fit the real-world scenario where timing <strong>optimization</strong> is taken into account</li></ul><p><a href=https://github.com/Thinklab-SJTU/EDA-AI/tree/main/PreRoutGNN>PreRoutGNN-STA prediction-AAAI-2024-GNN</a></p><ul><li>opensource</li></ul><p>[Multimodal Fusion-Restructure tolerant+CNN+Endpoint-wise Masking4Layout -DAC-2023-GNN+CNN-7nm RISCV](D:\MyNotes\EDA\Timing\Multimodal Fusion-Pre Route Timing Prediction-DAC-2023-GNN-7nm RISCV.pdf)</p><p><a href=https://www.cse.cuhk.edu.hk/~byu/papers/C167-DAC2023-PathPred-poster.pdf>slice</a></p><ul><li><p>Restructure：预测终点的延时，但是Timing Opt会改变网表结构(end point不变）。对一个Pre-routing任务来说，输入的网表和最终的网表不一样</p></li><li><p>netlist <strong>restructuring</strong> causes a mismatch between local input features and ground-truth features in the restructured sub-regions</p><p><img src=/image-20241026173420844.png alt=image-20241026173420844></p><p>As a result, prior local-view models can only be trained on the unchanged regions in a <strong>semi-supervised manner</strong>.</p><p>In other words, the better the models fit on labeled (unreplaced) net/cell delays, the worse they fit on replaced regions and eventually on endpoint arrival time</p></li><li><p>数据集：基本信息和Timing优化导致的网表变化</p><ul><li>average 40% nets and 21% cells are replaced during timing optimization</li><li>timing optimization brings an average change of 59.6% to net delays
and 33.3% to cell delays</li></ul><p><img src=/image-20241026170120254.png alt=image-20241026170120254></p></li><li><p>为什么用layout信息：Since most timing optimization techniques include gate insertion or gate sizing, placement should reserve space for subsequent timing
optimization. In other words, the timing optimizer’s efficacy is tied closely to global layout information. The layout information plays a dominant role in determining the timing optimizer’s impact since most optimization
techniques need space to be applied</p></li><li><p>整体模型</p><p><img src=/image-20241026184138343.png alt=image-20241026184138343></p><p>组成：<strong>GNN+CNN+Endpoint-wise Masking</strong></p><ul><li>Netlist(GNN):</li></ul><p><img src=/image-20241026184646854.png alt=image-20241026184646854></p><p>和
<a href=https://dl.acm.org/doi/abs/10.1145/3489517.3530597>TimingGCN-STA prediction-DAC-2022-GNN</a>很像(没发现不同)</p><ul><li><p>Layout(CNN+Endpoint-wise Masking)</p><p><img src=/image-20241026185621311.png alt=image-20241026185621311></p><p><img src=/image-20241026193815323.png alt=image-20241026193815323></p><p>三个特征：cell density, rectangular uniform wire density (RUDY), and macro cells region</p><p><img src=/image-20241026190115449.png alt=image-20241026190115449></p><p><strong>Endpoint-wise Masking</strong></p><p><img src=/image-20241026194544366.png alt=image-20241026194544366></p></li></ul></li><li><p>对比实验：</p><p><img src=/image-20241026200330616.png alt=image-20241026200330616></p><p><img src=/image-20241026200838620.png alt=image-20241026200838620></p></li><li><p>run time实验</p><p><img src=/image-20241026201203648.png alt=image-20241026201203648></p></li></ul><h4 id=other>other
<a class=anchor href=#other>#</a></h4><p><a href=file:///D:/MyNotes/EDA/Timing/aheadRCnetwork.pdf>Ahead RC network-STA prediction-DAC-2022-?</a></p><p><a href=https://ieeexplore.ieee.org/abstract/document/10247794>TSteiner-STA prediction and refinement&amp;steiner point refinement-DAC-2023-GNN-Yibo Lin</a></p><p><img src=/image-20241012155536218.png alt=image-20241012155536218></p><p><a href=https://ieeexplore.ieee.org/document/9643435>Doomed Run Prediction-TNS prediction-ACM-2021-GNN+RNN</a></p><p><img src=/image-20241007121002859.png alt=image-20241007121002859></p><h4 id=not-dl>not DL
<a class=anchor href=#not-dl>#</a></h4><p><img src=/image-20241026164603048.png alt=image-20241026164603048>The two-stage approaches [2], [3] first predict localnet/cell delays and then apply PERT traversals [5] to evaluate the global timing metrics, i.e., endpoint arrival time.</p><h2 id=optimization>Optimization
<a class=anchor href=#optimization>#</a></h2><h3 id=timing>Timing
<a class=anchor href=#timing>#</a></h3><p><a href=/zh/>TSteiner - Steiner Points Opt-DAC-2023-GNN-CUHK</a></p><p><strong>background</strong></p><p>对于multi-pin net需要构建steiner tree来进行routing，故steiner tree中steiner points也会影响routing</p><p>FLUTE[
<a href=https://www.zhihu.com/question/579615273/answer/3154651342#ref_3>3]</a>是常用的生成steiner tree的算法。在生成steiner tree后，我们可以通过近一步优化steiner point来优化timing</p><p><img src=/image-20241102112154369.png alt=image-20241102112154369></p><p>the previous early-stage timing optimization works only focus on improving
early timing metrics. 提出了诸如net加权和可微分时间目标等策略来优化时间, only focus on improving pre-routing timing metrics, which may have a considerable gap to <strong>signoff</strong> timing performance. 斯坦那点更加靠近布线阶段(和布线更加相关)</p><p>all the aforementioned works are not directly targeted at sign-off timing performance due to its high acquisition cost</p><p><strong>任务:</strong></p><p><img src=/image-20241102111709494.png alt=image-20241102111709494></p><p>In this paper, we focus on explicit sign-off timing optimization at the pre-routing stage to reduce the turnaround time</p><p>optimization framework is built to adjust Steiner point positions for better sign-off timing performance iteratively</p><p>The most popular Steiner minimum tree construction algorithms aim to <strong>minimize wirelength</strong>. Moreover, the Steiner point refinement is introduced to update the generated Steiner point positions for specific objectives, e.g., sign-off timing performance, while maintaining the two-pin net connections</p><p><strong>启发:</strong></p><p>we surprisingly find that the signoff timing performance could be significantly affected even by a <strong>random</strong> disturbance on Steiner point positions, as shown in Fig. 2.</p><p><img src=/image-20241102114842155.png alt=image-20241102114842155></p><p>Nevertheless, the impact of random moving is considerately unstable, and its average performance is slight (with a ratio close to 1.0). 所以启发找到一个好的方法来更新斯坦纳点来降低TNS</p><p>在最广泛使用的技术节点中，与<strong>路径长度</strong>最相关的定时度量——净延迟，并不能解释大部分的整体定时性能. 这里用的初始化斯泰纳树的方法的优化目标都是路径长度最短</p><p><strong>contribution</strong>:</p><ul><li>first earlystage timing optimization framework via Steiner point refinement</li><li>GNN</li><li>TSteiner framework is fully automated with an adaptive stepsize scheme and the auto-convergence scheme</li><li>improves 11.2% and 7.1% on average (up to 45.8% and 43.9%) for WNS and TNS</li></ul><p><strong>模型:</strong></p><p>Steiner tree construction decomposes each multi-pin net into <strong>a set of two-pin</strong>
<strong>nets</strong> via additional Steiner points before global routing to reduce the problem complexity</p><p>The proposed framework can be divided into two stages, <strong>sign-off timing gradient generation</strong> (Section III-A) and <strong>concurrent Steiner point refinement</strong> (Section III-B)</p><p><img src=/image-20241102123009705.png alt=image-20241102123009705></p><p><img src=/image-20241102115937138.png alt=image-20241102115937138></p><p>和TimingGCN相比就是多了Steiner 节点, 然后吧第一部分的的node embedding部分加上了steiner的部分</p><p><img src=/image-20241102121828217.png alt=image-20241102121828217></p><p>实际是:
<img src=/image-20241102122509138.png alt=image-20241102122509138></p><p><img src=/image-20241102122552273.png alt=image-20241102122552273></p><p>优化的指标, WNS和TNS的加权</p><p>根据优化指标对斯泰纳点坐标参数做梯度下降</p><p><img src=/image-20241102132825834.png alt=image-20241102132825834></p><p><img src=/image-20250102200912287.png alt=image-20250102200912287></p><p>相比简单的梯度下降，只是减小了对不同benchmark的手动学习率微调</p><p><strong>数据</strong></p><p><img src=/image-20241102132430596.png alt=image-20241102132430596></p><p><strong>实验</strong></p><p><img src=/image-20241102132506821.png alt=image-20241102132506821></p><p><img src=/image-20241102132555409.png alt=image-20241102132555409></p><p><img src=/image-20241102132646602.png alt=image-20241102132646602></p><p><img src=/image-20241102132734827.png alt=image-20241102132734827></p><h3 id=marco-placement>Marco Placement
<a class=anchor href=#marco-placement>#</a></h3><p><a href=https://www.nature.com/articles/s41586-021-03544-w>-marco placement-nature-2021-RL+GNN-google</a></p><p><img src=/image-20241012160915238.png alt=image-20241012160915238></p><p><img src=/image-20241012160933145.png alt=image-20241012160933145></p><h3 id=placement>Placement
<a class=anchor href=#placement>#</a></h3><h5 id=-pin-accessibilitydrv-prediction-dac-2019-cnn-ntu><a href=/zh/>-Pin Accessibility+DRV prediction-DAC-2019-CNN-NTU</a>
<a class=anchor href=#-pin-accessibilitydrv-prediction-dac-2019-cnn-ntu>#</a></h5><p><strong>background:</strong></p><ul><li><p>Standard cells on the lower metal layers severely suffer from low routability due to high pin density, low pin accessibility, and limited routing resources.</p></li><li><p><img src=/image-20250206153002501.png alt=image-20250206153002501></p><p>It can be observed that the access points of pin B are blocked by the metal 2 (M2) routing segments routed from Pin A and Pin C, so an M2 short design rule violation (DRV) will be induced when dropping a via12 on Pin B. pin accessibility is not only determined by cell layout design but also strongly affected by adjacent cells</p></li><li><p>对于传统方法，两个缺点：</p><ul><li>Cell libraries provided by foundries should not be considerably redesigned because the optimized cell performance and manufacturability may be highly sensitive to cell layouts</li><li>Deterministic approaches based on <strong>human knowledge have been shown to be less effective in advanced nodes</strong> for optimization problems such as DRV prediction and minimization because of the extremely high complexity through the overall design flow</li></ul></li><li><p><img src=/image-20250206154744610.png alt=image-20250206154744610></p><p>It can be observed that most of the congested regions in the layout do not have DRVs, while some regions with DRVs are not so congested. 但是我感觉还是有相关性的。他是想说明congestion出现的地方不一定有DRV，但是没congestion的地方可能因为poor pin accessibility导致DRV</p></li><li><p><img src=/image-20250206154811206.png alt=image-20250206154811206></p><ul><li>也是说明：congestion出现的地方不一定有DRV，但是没congestion的地方可能因为poor pin accessibility导致DRV</li><li>the two M2 shorts occur at the locations having <strong>the same pin pattern</strong> in the top cell-row and mid cell-row</li></ul></li></ul><p><strong>task:</strong></p><ul><li><p>DRV prediction, 二分类</p><p><img src=/image-20250206190055066.png alt=image-20250206190055066></p></li><li><p>pin accessibility optimization, 给一个合法化后的布局结构，通过算法进行减少bad pin accessibility的detailed placement</p><p><img src=/image-20250206190225309.png alt=image-20250206190225309></p></li><li><p>其实也是一个预测模型，一个优化模型</p></li></ul><p><strong>contribution:</strong></p><ul><li>first work to apply pin pattern as the input features of <code>DRV prediction models</code>.</li><li></li></ul><p><strong>flow:</strong></p><p><img src=/image-20250206191224771.png alt=image-20250206191224771></p><p><strong>model:</strong></p><p>PPR&amp;DFPPR:</p><p><img src=/image-20250206192506245.png alt=image-20250206192506245></p><p>Model-guided Detailed Placement :</p><p><img src=/image-20250206195817013.png alt=image-20250206195817013></p><p><img src=/image-20250206202610856.png alt=image-20250206202610856></p><p>Dynamic Programming-based Placement Blockage Insertion</p><p><img src=/image-20250206202803548.png alt=image-20250206202803548></p><ul><li>还会改方向？</li></ul><p>Cell Displacement Refinement</p><p><strong>data:</strong></p><p><img src=/image-20250206192552413.png alt=image-20250206192552413></p><p>Both the width and height of each pixel are set as the <strong>minimum spacing of the M1 layer</strong> in order to prevent a pixel from being occupied by two different pins.</p><p>没看见关于benchmark的描述</p><p><strong>experiment:</strong></p><p><img src=/image-20250206204743555.png alt=image-20250206204743555></p><p><img src=/image-20250206205223899.png alt=image-20250206205223899></p><p><strong>shortcoming:</strong></p><ul><li>flow need routed designs to train, time</li><li>The trained model is not necessarily applicable to other designs using different cells or different reference cell libraries</li><li>对于VLSI，一行一行，一对一对进行，很慢？</li><li></li></ul><h5 id=-pin-accessibilityactiv-ispd-2020---ntusynopsys><a href=https://pdfs.semanticscholar.org/47f1/5e9fa283faddb8a6853398145d33e2ba9ae1.pdf>-Pin Accessibility+activ-ISPD-2020- -NTU+Synopsys</a>
<a class=anchor href=#-pin-accessibilityactiv-ispd-2020---ntusynopsys>#</a></h5><p><strong>background:</strong></p><ul><li><p>With the development of advanced process nodes of semiconductor, the problem of<code>pin access</code>has become one of the major factors to impact the occurrences of design rule violations (DRVs) due to complex design rules and limited routing resource</p></li><li><p><code>supervised learning</code> approaches extract the labels of training data by generating a great number of routed designs in advance, giving rise to large effort on training data preparation. the pre-trained model could hardly predict unseen data</p></li><li><p>Unlike most of existing studies that aim at <code>design-specific</code> training, we propose a <code>library-based</code> model which can be applied to all designs referencing to the same standard cell library set.</p></li><li><p>Due to the shrinking of modern process nodes of semiconductor, the <strong>pin access problem</strong> of standard cells has become more harder to be coped with, especially on the <strong>lower metal layers</strong>.</p></li><li><p><img src=/image-20250206150405665.png alt=image-20250206150405665></p><p>在这种placement下，Metal1 pin A/B由于各自左右两边在Metal2有pin，而且只能在黄色track下横向绕线，（Metal1不能绕线？），那么Pin A/B通过Via12后必定会短路</p></li><li><p>19年工作[5]的两个缺点</p><ul><li>flow need routed designs to train, time</li><li>The trained model is not necessarily applicable to other designs using different cells or different reference cell libraries</li></ul></li><li></li></ul><p><strong>contribution:</strong></p><ul><li>first work of<code> cell library-based</code>pin accessibility prediction (PAP), which can be applied to predict other designs referencing to the same cell library set</li><li>applies <strong>active learning</strong> to train a PAP model</li><li>the proposed cell library-based PAP model <strong>can be trained at the earlier stage</strong> in a process development flow: once the cell libraries are provided.</li><li></li></ul><h5 id=placement-optimization-with-deep-reinforcement-learning---ispd-2020-rlgnn-google><a href=[dl.acm.org/doi/pdf/10.1145/3372780.3378174]%28https://dl.acm.org/doi/pdf/10.1145/3372780.3378174%29>Placement Optimization with Deep Reinforcement Learning- -ISPD-2020-RL+GNN-Google</a>
<a class=anchor href=#placement-optimization-with-deep-reinforcement-learning---ispd-2020-rlgnn-google>#</a></h5><h5 id=pl-gnn-affinity-aware-for-icc2--ispd-2021-gnn-atlanta><a href=https://dl.acm.org/doi/pdf/10.1145/3439706.3447045>PL GNN-Affinity Aware for ICC2- ISPD-2021-GNN-Atlanta</a>
<a class=anchor href=#pl-gnn-affinity-aware-for-icc2--ispd-2021-gnn-atlanta>#</a></h5><p><strong>background</strong>:</p><ul><li><p>Placement is one of the most <strong>crucial problems</strong>, placement directly impacts the final quality of a full-chip design</p></li><li><p>multiple placement <strong>iterations</strong> to optimize key metrics(WL, timing), which is <strong>time-consuming</strong> and computationally inefficient, VLSI</p></li><li><p>the<code> logical affinity</code> among design instancesdominates the quality of the placement</p><p><img src=/image-20241224115010379.png alt=image-20241224115010379></p><p><code>logical affinity</code> 源于这篇文章？</p></li><li><p>performing <strong>placement guidance</strong> requires in-depth design-specific knowledge,which is only achievable by <strong>experienced designers</strong> who knows the underlying data flows in Register-Transistor Level (RTL) well</p></li><li><p><img src=/image-20241224114254672.png alt=image-20241224114254672></p></li><li><p>K-means基础：</p><ul><li><p><img src=/image-20241224172053839.png alt=image-20241224172053839></p></li><li><p><img src=/image-20241224172022162.png alt=image-20241224172022162></p></li></ul></li></ul><p><strong>task:</strong></p><ul><li>基于网表数据，和floorplan结果（marco已经放好）</li><li><code>placement guidance</code>(grouping information) for commercial placers <code>ICC2</code>, by generating <strong>cell clusters</strong> based on <strong>logical affinity</strong> and manually defined attributes of design instances</li><li>our framework will determine the<code> cell clusters</code> in an <strong>unsupervised</strong> manner which serve as placement guidance in order to guide commercial placers to optimize the key metrics such as <strong>wirelength, power, and timing</strong> by placing cells with a common <strong>cluster</strong> together</li></ul><p><strong>flow:</strong></p><p><img src=/image-20241224111801884.png alt=image-20241224111801884></p><p><strong>Two stages:</strong></p><ol><li><p>GNN do unsupervised node representation learning, (it is generalizable to any design)</p></li><li><p><code>weighted K-means clustering algorithm [3]</code> to group instances into different clusters。To find the optimal number of groups for clustering, we introduce the <code>Silhouette score [19]</code> and perform sweeping experiments to find the sweet spot</p><p>K-means算法的基本思想是：通过迭代的方式，将数据划分为<strong>K个不同的簇</strong>，并使得每个数据点与其所属簇的质心（或称为中心点、均值点）之间的<strong>距离之和最小</strong>。</p></li></ol><p><img src=/image-20241007102413593.png alt=image-20241007102413593></p><p><strong>data</strong></p><p>two multi-core CPU designs：</p><p><img src=/image-20241224181733657.png alt=image-20241224181733657></p><p><strong>nf</strong></p><ul><li><p><strong>design hierarchy</strong> : 根据网表层级. top/inst1/sky130_INV/A. (同时zero-padding)</p><p><img src=/image-20241224160726962.png alt=image-20241224160726962></p></li><li><p><strong>logical affinity of memory macros</strong> ：logical levels to memory macros 𝑀 as features. because the logic to memory paths are often the critical timing paths</p></li></ul><p><img src=/image-20241224161329678.png alt=image-20241224161329678></p><p><strong>ef:</strong></p><p><img src=/image-20241224171228803.png alt=image-20241224171228803></p><p><strong>model</strong></p><ul><li><p>GraphSAGE-based， two layers</p><p><img src=/image-20241224161923488.png alt=image-20241224161923488></p><p><img src=/image-20241224162351812.png alt=image-20241224162351812></p></li><li><p>Loss Function:</p><p><img src=/image-20241224170359079.png alt=image-20241224170359079></p><p><img src=/image-20241224170818328.png alt=image-20241224170818328></p><p><img src=/image-20241224170824860.png alt=image-20241224170824860></p></li></ul><p><strong>Silhouette score</strong></p><p>用于评估分类结果，扫描分类数目，选择最高的分的</p><p><img src=/image-20241224181023453.png alt=image-20241224181002019></p><p><img src=/image-20241224181044251.png alt=image-20241224181044251></p><p><img src=/image-20241224181052309.png alt=image-20241224181052309></p><p><img src=/image-20241224181116187.png alt=image-20241224181116187></p><p><strong>experiment:</strong></p><p><strong>env</strong>:</p><ul><li>2.40𝐺𝐻𝑍 CPU</li><li>NVIDIA RTX 2070</li><li>16𝐺𝐵 memory.</li><li>PyTorch Geometric</li></ul><p><strong>setting:</strong></p><ul><li>the placement of memory macros is achieved manually based on design manuals provided by the design-house</li><li>Adam</li></ul><p><strong>result</strong></p><p>Louvain：比较实验对比模型</p><p><img src=/image-20241224181627782.png alt=image-20241224181627782></p><p><strong>Question</strong>:</p><p>benchmark少</p><p>扫描到的就适用所有？</p><p>开环？</p><h5 id=-innovus-ppa-placement-optimize-neurips-2021-rl><a href=https://www.semanticscholar.org/paper/A-General-Framework-For-VLSI-Tool-Parameter-with-Agnesina-Pentapati/30c644ffa213418182e795ea5e8132cb15e891c2>-Innovus PPA placement optimize-Neurips-2021-RL </a><a class=anchor href=#-innovus-ppa-placement-optimize-neurips-2021-rl>#</a></h5><p><img src=/image-20241007103637165.png alt=image-20241007103637165></p><p><img src=/image-20241007105134964.png alt=image-20241007105134964></p><p><strong>contribution</strong>:</p><p><img src=/image-20241224114117771.png alt=image-20241224114117771></p><h5 id=-gp-routability-opt-dac-2021-fcn-cuhksitingliu-beiyuyibo-lin><a href=/zh/>-GP Routability Opt-DAC-2021-FCN-CUHK(SitingLiu BeiYu)+Yibo Lin</a>
<a class=anchor href=#-gp-routability-opt-dac-2021-fcn-cuhksitingliu-beiyuyibo-lin>#</a></h5><p><strong>background</strong></p><p><strong>flow</strong></p><p><img src=/image-20241226160945080.png alt=image-20241226160945080></p><ol><li>three input features are extracted from the cell placement solution</li><li>Through the inference of the pre-trained routability prediction model, we get the predicted congestion map.</li><li>take <code>mean squared Frobenius norm</code> of this congestion map as the congestion penalty</li><li></li></ol><p><img src=/image-20241226161200384.png alt=image-20241226161200384></p><p><strong>data</strong></p><p><strong>model</strong></p><p><img src=/image-20241226161132128.png alt=image-20241226161132128></p><h3 id=routing>Routing
<a class=anchor href=#routing>#</a></h3><h4 id=global-routing>global routing
<a class=anchor href=#global-routing>#</a></h4><h5 id=backeground>backeground
<a class=anchor href=#backeground>#</a></h5><p><strong>gr</strong></p><p><img src=/image-20241128091217724.png alt=image-20241128091217724></p><p><img src=/image-20241128091245240.png alt=image-20241128091245240></p><p><strong>drc</strong></p><p><img src=/image-20241128093047653.png alt=image-20241128093047653></p><p><img src=/image-20241128093058137.png alt=image-20241128093058137></p><h5 id=pros-routability-optimization-iccad-2020-fcn-cnhkcadence><a href=/zh/>PROS-Routability Optimization-ICCAD-2020-FCN-CNHK+Cadence</a>
<a class=anchor href=#pros-routability-optimization-iccad-2020-fcn-cnhkcadence>#</a></h5><p><strong>background</strong></p><p><img src=/image-20241128091405687.png alt=image-20241128091405687></p><p><img src=/image-20241128091759855.png alt=image-20241128091759855></p><p><strong>task</strong></p><ul><li>congestion <strong>predictor</strong> and parameter <strong>optimizer</strong></li><li>only the data from the placement</li><li>it can optimize the cost parameters before the first routing iteration of GR and thus can give a better GR solution with less congestion.</li></ul><p><strong>contribution</strong></p><ul><li>with negligible runtime overhead</li><li>plug-in</li><li>can be embedded into the state-of-the-art commercial EDA tool (Cadence Innovus v20.1)</li></ul><p><strong>model</strong></p><p><img src=/image-20241219171627049.png alt=image-20241219171627049></p><p><strong>data</strong></p><p>19 different industrial designs</p><p><img src=/image-20241219165446998.png alt=image-20241219165446998></p><p>通过<strong>不同的placement参数和旋转</strong>（CNN原理），一共有1664 design cases in total.</p><p><strong>Feature Extraction</strong></p><ul><li><p>Horizontal/Vertical track capacity map</p></li><li><p>Cell density map</p></li><li><p>Flip-flop cell density map</p></li><li><p>Fixed cell density map</p></li><li><p>Cell pin density map</p></li><li><p>Pin accessibility map</p><p><img src=/image-20241219161307835.png alt=image-20241219161307835></p><ul><li><p>Horizontal/Vertical net density map</p></li><li><p>Small/Large-net RUDY map</p></li></ul><p><img src=/image-20241219161336920.png alt=image-20241219161336920></p></li><li><p>Pin RUDY map</p><p>a combination of cell pin density map and large-net RUDY
map</p></li></ul><p><strong>Label Generation</strong></p><p><img src=/image-20241219162403381.png alt=image-20241219162403381>PROS does not need very detailed congestion map</p><p>two-step smoothening process to convert raw data to desirable congestion labels</p><p>help to make the prediction task easier</p><p>if there are at least six congested G-cells out of the eight in the surrounding of a center G-cell д, д will be labeled as congested</p><p><img src=/image-20241219162837909.png alt=image-20241219162837909></p><p><strong>优化原理</strong></p><p>这两个值在cadence怎么改的? cadence企业内部自己弄的（这是cadence的文章）？</p><p><img src=/image-20241219165904742.png alt=image-20241219165904742></p><p><img src=/image-20241219165912121.png alt=image-20241219165912121></p><p><strong>model</strong></p><p><img src=/image-20241219163417043.png alt=image-20241219163417043></p><p><strong>experiment</strong></p><p><img src=/image-20241219172158774.png alt=image-20241219172158774></p><p><img src=/image-20241219172205431.png alt=image-20241219172205431></p><p><img src=/image-20241219172212018.png alt=image-20241219172212018></p><p><img src=/image-20241219172620444.png alt=image-20241219172620444></p><h5 id=pros-20---routability-optroute-wl-estimation-trans-2023-cnn-cnhkcadence><a href=/zh/>PROS 2.0 - Routability Opt+Route WL estimation-Trans-2023-CNN-CNHK+Cadence</a>
<a class=anchor href=#pros-20---routability-optroute-wl-estimation-trans-2023-cnn-cnhkcadence>#</a></h5><p><strong>background</strong></p><ul><li>the amount of routing resources on a design is limited.</li><li>The quality of a GR solution has a great impact on that of the resulted DR routing solution</li><li>Congestion in a GR solution is one of the major causes of DRC violations in the DR
solution since most of DRC violations are due to overcrowded wires and vias [1], [2]</li><li>a better GR solution with less congestion is needed to lower the probability of getting DRC violations in advance.</li><li>if the initial GR solution is not good and has a lot of congestion, the GR tool can hardly tackle the problem by rip-up and reroute.</li><li>placement engines <strong>[3]–[5]</strong> which take routing congestion into consideration are applied</li><li>FCN:FCN常用于图像中的每像素分类问题。采用<strong>任意输入大小</strong>，并产生大小完全相同的输出。GR拥塞预测也可以被视为任意大小的芯片设计上的像素二进制分类问题（拥塞与否）。因此，基于FCN的预测器可以自然地应用于PROS。</li></ul><p><strong>task:</strong></p><ul><li>stage: post-placement, pre-route</li><li>FCN based GR congestion <code>predictor</code>, use the predicted GR congestion to optimize the <strong>cost parameters</strong> of GR.</li><li>predictor based <code>parameter optimizer</code> to generate a better GR solution. GR tools are driven by the cost parameters stored in each G-cell. When arriving at a G-cell g, the tool will compute the cost, called <code>moving cost</code>, to move to each of its neighboring G-cells and push these costs into a heap. With optimized cost parameters in G-cells, the GR tool can find better paths and allocate the routing resources to each net more smartly. PROS optimizes two types of cost parameters <strong>based on the prediction result</strong>, including <code>overflow cost</code> and <code>wire/via cost </code>. PROS will adjust the cost parameters in the projected congestion regions on <strong>all layers</strong><ul><li>overflow cost</li><li>wire/via cost: divided into two groups (small/large) according to their BBox sizes.<ul><li>Increasing the wire/via cost for small nets may be <strong>useless</strong> for congestion reduction and it may even increase the wire length or create new congestion due to detours out of the potential congestion region.</li><li>In contrast, increasing the wire/via cost for large nets can be helpful since
they can select another route within its BBox to completely avoid the potential congestion region</li></ul></li></ul></li><li>CNN based <code>wirelength estimator </code>, By <strong>multiplying</strong> the predicted wirelength ratio and the precomputed <code>FLUTE </code>wirelength (训练一个系数). The lack of consideration of routing congestion in traditional methods is due to the dif ficulty of quickly obtaining accurate congestion estimation at the placement <strong>stage</strong></li></ul><p><strong>contribution:</strong></p><ul><li>plug-in for Innovus: it can avoid extra runtime overhead of feature preparation</li><li>industrial design suite</li><li>advanced technology node</li><li>SOTA</li><li>high accuracy</li><li>first work that</li><li>utilizes the information of GR congestion to estimate routed wirelength at the placement stage</li><li>PROS does not change a lot for the original EDA steps</li></ul><p><strong>Overall Flow</strong> :</p><p><img src=/image-20241225231457615.png alt=image-20241225231457615></p><p><img src=/image-20241225231740032.png alt=image-20241225231740032></p><p>分类和回归</p><p><img src=/image-20241225231939553.png alt=image-20241225231939553></p><ul><li>F is the feature number.</li><li>X<del>WL</del> has two features: These two features will be resized to 128 × 128 before prediction<ul><li>the <strong>predicted</strong> congestion map</li><li>the cell pin density map</li></ul></li></ul><p><strong>data</strong></p><p>feature F</p><ul><li><p>Horizontal/Vertical Track Capacity Map</p></li><li><p>Cell Density Map</p></li><li><p>Flip-Flop Cell Density Map</p></li><li><p>Fixed Cell Density Map</p></li><li><p>Cell Pin Density Map</p></li><li><p>Pin Accessibility Map</p><p><img src=/image-20241226095003879.png alt=image-20241226095003879></p></li><li><p>Horizontal/Vertical Net Density Map</p><p><img src=/image-20241226095234394.png alt=image-20241226095234394></p></li><li><p>Small/Large-Net RUDY Map</p><p><img src=/image-20241226095702886.png alt=image-20241226095702886></p></li><li><p>Pin RUDY Map ?</p></li></ul><p><strong>label</strong></p><p><strong>congestion label pre-process</strong></p><p>PROS does not need a very detailed congestion map</p><p><img src=/image-20241226100513980.png alt=image-20241226100513980></p><p>最后还是为了优化服务的</p><p><strong>model</strong></p><p><img src=/image-20241226133238155.png alt=image-20241226133238155></p><ul><li>DC: get more local information, but more GPU usage(acceptable)</li><li>SUB: w*h*4c –>2w*2h*c.<ul><li>Compared with bilinear upsampling which is not trainable, subpixel upsampling can learn to recover the local information.</li><li>Compared with deconvolution, subpixel upsampling is parameter free, so
it will not significantly increase the training difficulty.</li></ul></li></ul><p><img src=/image-20241226133719030.png alt=image-20241226133719030></p><p><strong>dataset</strong></p><p>industrial benchmark suite and DAC-2012 benchmark suite(19个 benchmark)</p><p>industrial benchmark suite 通过11种不同布局参数，翻转和旋转，制造了一共有1664个(约等于19*11*8)benchmark</p><p>DAC-2012 20 different placements</p><p>(4, 4, 4, 4, 3) 5折交叉验证</p><p><img src=/image-20241226134314062.png alt=image-20241226134314062></p><p><img src=/image-20241226134322968.png alt=image-20241226134322968></p><p><strong>experiment</strong></p><p><strong>env</strong></p><ul><li>Tensorflow</li><li>Intel Xeon CPUs at 2.2 GHz</li><li>256 GB memory</li><li>NVIDIA TITAN V GPU</li></ul><p><strong>setting</strong></p><ul><li><p>Adam</p></li><li><p>One entire training process of the congestion predictor has 25 training epochs! 这么少（收敛好快）</p><p><img src=/image-20241226135108986.png alt=image-20241226135108986></p></li></ul><p><strong>congestion classification prediction</strong></p><p><img src=/image-20241226135344696.png alt=image-20241226135344696></p><p><img src=/image-20241226135500109.png alt=image-20241226135500109></p><p>compare with PROBABILISTIC METHODS</p><p><img src=/image-20241226135607227.png alt=image-20241226135607227></p><p><img src=/image-20241226135730697.png alt=image-20241226135730697></p><p><img src=/image-20241226135756327.png alt=image-20241226135756327></p><p><strong>DR优化结果</strong></p><p><img src=/image-20241226140031433.png alt=image-20241226140031433></p><p><strong>线长估计</strong></p><p><img src=/image-20241226140057750.png alt=image-20241226140057750></p><p><img src=/image-20241226142425570.png alt=image-20241226142425570></p><p><img src=/image-20241226142433618.png alt=image-20241226142433618></p><p><strong>Runtime</strong></p><p><img src=/image-20241226142533340.png alt=image-20241226142533340></p><p><img src=/image-20241226142539173.png alt=image-20241226142539173></p><h4 id=detail-routing>detail routing
<a class=anchor href=#detail-routing>#</a></h4><h5 id=background-2>background
<a class=anchor href=#background-2>#</a></h5><p><img src=/image-20241028220857482.png alt=image-20241028220857482></p><p><img src=/image-20241028221200277.png alt=image-20241028221200277></p><h5 id=-detailed-router-date-2021-rl><a href=https://ieeexplore.ieee.org/document/9474007>-Detailed Router-DATE-2021-RL</a>
<a class=anchor href=#-detailed-router-date-2021-rl>#</a></h5><p><img src=/image-20241012161419196.png alt=image-20241012161419196></p><h5 id=dprouter-detail-routingpackage-design-optnet-order-decision-aspadc-2023-rlmarl-diagonally-routedmynotesedaroutingdprouter-detail-routingpackage-design-optnet-order-decision-aspadc-2023-rlmarl-diagonally-routepdf>[DPRouter-Detail Routing(package design) Opt+net order decision-ASPADC-2023-RL(MARL)-diagonally route](&ldquo;D:\MyNotes\EDA\Routing\DPRouter-Detail Routing(package design) Opt+net order decision-ASPADC-2023-RL(MARL)-diagonally route.pdf&rdquo;)
<a class=anchor href=#dprouter-detail-routingpackage-design-optnet-order-decision-aspadc-2023-rlmarl-diagonally-routedmynotesedaroutingdprouter-detail-routingpackage-design-optnet-order-decision-aspadc-2023-rlmarl-diagonally-routepdf>#</a></h5><p><img src=/image-20241027101634534.png alt=image-20241027101634534></p><ul><li><p>BackGround</p><ul><li>most time-consuming stages in the <strong>package design</strong> flow</li><li>package designs have fewer layers; thus, we need to prevent net crashing cautiously</li></ul></li><li><p>contrbution:</p><ul><li>redefine the routing area and shrink the routing problem by dividing the entire design into <strong>non-overlapping boxes</strong></li><li>use DRL, not heuristic</li><li>prove the number of design rule violations (DRVs), wirelength and layout pattern.</li></ul></li><li><p>task</p><ul><li>2-pin nets</li></ul><p><img src=/image-20241027104527603.png alt=image-20241027104527603></p><p>Initial routing: ignores the number of bends and allows design rule violations</p><p><img src=/image-20241027104906544.png alt=image-20241027104906544></p></li><li><p>Model</p><p>multi-agent deep reinforcement learning (<strong>MARL</strong>) task [15] for <strong>asynchronous</strong> routing planning between nets. We regard each net as an agent, which needs to consider the actions of other agents while making pathing decisions to avoid routing conflict</p><p><img src=/image-20241027104558097.png alt=image-20241027104558097></p><p><img src=/image-20241027105909572.png alt=image-20241027105909572></p><p>route and slide the window repeatedly. advantage of box:process every box independently</p><ul><li><p>sequential routing</p><p><img src=/image-20241027134657161.png alt=image-20241027134657161></p><p><img src=/image-20241027133917659.png alt=image-20241027133917659></p><p><img src=/image-20241027133231542.png alt=image-20241027133231542></p><p><img src=/image-20241027133826865.png alt=image-20241027133826865></p><p>the repulsion point will be moved from the inner ring to the outer one until the box is successfully routed.</p><p>具体算法：</p><p><img src=/image-20241027141238708.png alt=image-20241027141238708></p></li><li><p>sequential routing</p><p><img src=/image-20241027142631796.png alt=image-20241027142631796></p><ul><li><img src=/image-20241027143243104.png alt=image-20241027143243104></li><li><img src=/image-20241027144931328.png alt=image-20241027144931328></li></ul></li><li><p>Refinement</p><p><img src=/image-20241027144108460.png alt=image-20241027144108460></p></li></ul></li></ul><h5 id=-detail-routingmatchopt-ispd-2023-rlgnn-finfet><a href=/zh/>-Detail routing+match+Opt-ISPD-2023-RL+GNN-FinFET </a><a class=anchor href=#-detail-routingmatchopt-ispd-2023-rlgnn-finfet>#</a></h5><p><strong>background</strong>:</p><ul><li><p>cutom circuits: a custom detailed router cannot adopt specialized layout strategies for specific circuit classes like human layout experts</p></li><li><p><img src=/image-20241028221540078.png alt=image-20241028221540078></p></li><li><p><img src=/image-20241028224206180.png alt=image-20241028224206180></p></li><li><p><img src=/image-20241028222447134.png alt=image-20241028222447134></p></li><li><p>一直在强调match的问题：</p><p><img src=/image-20241028224639124.png alt=image-20241028224639124></p></li></ul><p><strong>contribution</strong></p><ul><li>opt roouting, FinFET, sign-off solution</li><li>异构图</li><li>A rip-up and re-routing scheme</li><li>can easily adapt to future design constraints</li></ul><p><strong>three categories of routing methodologies</strong></p><ol><li>Template-based methods<ul><li>manual design</li><li>suffers from scalability issues</li></ul></li><li>Simulation-based techniques<ul><li>provide accurate performance feedback and can be generalized to consider various performance metrics (e.g., phase
margin, power dissipation) across circuit classes</li><li>long execution time and resource-hungry computations</li></ul></li><li>Constraint-based approaches<ul><li>widely adopted in existing custom routing studies</li></ul></li></ol><h2 id=pr-tools>PR Tools
<a class=anchor href=#pr-tools>#</a></h2><p><a href=https://www.cse.cuhk.edu.hk/~byu/papers/C112-DATE2021-DREAMPlace-Cong.pdf>Placement and routing (PnR) is the most time-consuming part of the physical design flow</a></p><p><img src=/image-20241114120146641.png alt=image-20241114120146641></p><h3 id=placer>Placer
<a class=anchor href=#placer>#</a></h3><h5 id=chip-placement-with-deep-reinforcement-learning-marcro-arxiv-2020-rl><a href=https://arxiv.org/pdf/2004.10746>Chip Placement with Deep Reinforcement Learning-marcro-arXiv-2020-RL</a>
<a class=anchor href=#chip-placement-with-deep-reinforcement-learning-marcro-arxiv-2020-rl>#</a></h5><h5 id=differentiable-timing-driven-global-placement-global-placement-dac-2022-gnn-><a href=https://dl.acm.org/doi/pdf/10.1145/3489517.3530486>Differentiable-Timing-Driven Global Placement-global placement-DAC-2022-GNN-</a>
<a class=anchor href=#differentiable-timing-driven-global-placement-global-placement-dac-2022-gnn->#</a></h5><h5 id=polar-20><a href=https://ieeexplore.ieee.org/document/6881450>Polar 2.0</a>
<a class=anchor href=#polar-20>#</a></h5><p>An effective <strong>routability-driven</strong> placer</p><p>cells that are estimated to have high congestion are spread out and inflated to distribute routing demand more evenly.</p><h5 id=ntuplace3><strong>NTUPlace3</strong>
<a class=anchor href=#ntuplace3>#</a></h5><h5 id=deepplace><a href=https://github.com/PKUterran/DeepPlace>DeepPlace</a>
<a class=anchor href=#deepplace>#</a></h5><p><strong>flow</strong></p><h5 id=replace><a href=https://ieeexplore.ieee.org/abstract/document/8418790>RePlAce&ndash;TCAD-2018-</a>
<a class=anchor href=#replace>#</a></h5><h5 id=dreamplace-gp-dactcadiccaddate-2019><a href=https://github.com/limbo018/DREAMPlace>DREAMPlace-GP-DAC+TCAD+ICCAD+DATE-2019~2023</a>
<a class=anchor href=#dreamplace-gp-dactcadiccaddate-2019>#</a></h5><p><strong>introduction</strong></p><p>Over <code>30X</code> speedup over the CPU implementation (
<a href=https://doi.org/10.1109/TCAD.2018.2859220>RePlAce</a>) is achieved in global placement and legalization on ISPD 2005 contest benchmarks</p><p>DREAMPlace runs on both CPU and GPU. If it is installed on a machine without GPU, only CPU support will be enabled with multi-threading.</p><p>DREAMPlace also integrates a GPU-accelerated detailed placer,<code> ABCDPlace</code>, which can achieve around <code>16X</code> speedup on million-size benchmarks over the widely-adopted sequential placer
<a href=https://doi.org/10.1109/TCAD.2008.923063>NTUPlace3</a> on CPU.</p><p><strong>Publications</strong></p><ul><li><a href=http://yibolin.com/>Yibo Lin</a>, Shounak Dhar,
<a href=http://wuxili.net/>Wuxi Li</a>, Haoxing Ren, Brucek Khailany and
<a href=http://users.ece.utexas.edu/~dpan>David Z. Pan</a>, &ldquo;<strong>DREAMPlace: Deep Learning Toolkit-Enabled GPU Acceleration for Modern VLSI Placement</strong>&rdquo;, ACM/IEEE Design Automation Conference (DAC), Las Vegas, NV, Jun 2-6, 2019 (
<a href=http://yibolin.com/publications/papers/PLACE_DAC2019_Lin.pdf>preprint</a>) (
<a href=http://yibolin.com/publications/papers/PLACE_DAC2019_Lin.slides.pptx>slides</a>)</li><li><a href=http://yibolin.com/>Yibo Lin</a>, Zixuan Jiang,
<a href=https://jeremiemelo.github.io/>Jiaqi Gu</a>,
<a href=http://wuxili.net/>Wuxi Li</a>, Shounak Dhar, Haoxing Ren, Brucek Khailany and
<a href=http://users.ece.utexas.edu/~dpan>David Z. Pan</a>, &ldquo;<strong>DREAMPlace: Deep Learning Toolkit-Enabled GPU Acceleration for Modern VLSI Placement</strong>&rdquo;, IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems (TCAD), 2020</li><li><a href=http://yibolin.com/>Yibo Lin</a>,
<a href=http://wuxili.net/>Wuxi Li</a>,
<a href=https://jeremiemelo.github.io/>Jiaqi Gu</a>, Haoxing Ren, Brucek Khailany and
<a href=http://users.ece.utexas.edu/~dpan>David Z. Pan</a>, &ldquo;<strong>ABCDPlace: Accelerated Batch-based Concurrent Detailed Placement on Multi-threaded CPUs and GPUs</strong>&rdquo;, IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems (TCAD), 2020 (
<a href=http://yibolin.com/publications/papers/ABCDPLACE_TCAD2020_Lin.pdf>preprint</a>)</li><li><a href=http://yibolin.com/>Yibo Lin</a>,
<a href=http://users.ece.utexas.edu/~dpan>David Z. Pan</a>, Haoxing Ren and Brucek Khailany, &ldquo;<strong>DREAMPlace 2.0: Open-Source GPU-Accelerated Global and Detailed Placement for Large-Scale VLSI Designs</strong>&rdquo;, China Semiconductor Technology International Conference (CSTIC), Shanghai, China, Jun, 2020 (
<a href=http://yibolin.com/publications/papers/PLACE_CSTIC2020_Lin.pdf>preprint</a>)(Invited Paper)</li><li><a href=https://jeremiemelo.github.io/>Jiaqi Gu</a>, Zixuan Jiang,
<a href=http://yibolin.com/>Yibo Lin</a> and
<a href=http://users.ece.utexas.edu/~dpan>David Z. Pan</a>, &ldquo;<strong>DREAMPlace 3.0: Multi-Electrostatics Based Robust VLSI Placement with Region Constraints</strong>&rdquo;, IEEE/ACM International Conference on Computer-Aided Design (ICCAD), Nov 2-5, 2020 (
<a href=http://yibolin.com/publications/papers/PLACE_ICCAD2020_Gu.pdf>preprint</a>)</li><li><a href=https://enzoleo.github.io/>Peiyu Liao</a>,
<a href=https://lusica1031.github.io/>Siting Liu</a>, Zhitang Chen, Wenlong Lv,
<a href=http://yibolin.com/>Yibo Lin</a> and
<a href=https://www.cse.cuhk.edu.hk/~byu/>Bei Yu</a>, &ldquo;<strong>DREAMPlace 4.0: Timing-driven Global Placement with Momentum-based Net Weighting</strong>&rdquo;, IEEE/ACM Proceedings Design, Automation and Test in Eurpoe (DATE), Antwerp, Belgium, Mar 14-23, 2022 (
<a href=https://yibolin.com/publications/papers/PLACE_DATE2022_Liao.pdf>preprint</a>)</li><li>Yifan Chen,
<a href=http://faculty.bicmr.pku.edu.cn/~wenzw/>Zaiwen Wen</a>,
<a href=https://ericlyun.github.io/>Yun Liang</a>,
<a href=http://yibolin.com/>Yibo Lin</a>, &ldquo;<strong>Stronger Mixed-Size Placement Backbone Considering Second-Order Information</strong>&rdquo;, IEEE/ACM International Conference on Computer-Aided Design (ICCAD), San Francisco, CA, Oct, 2023 (
<a href=https://yibolin.com/publications/papers/PLACE_ICCAD2023_Chen.pdf>preprint</a>)</li></ul><p><strong>Architecture</strong></p><p><img src=/image-20241211185233352.png alt=image-20241211185233352></p><p><img src=/image-20241211185244415.png alt=image-20241211185244415></p><p><strong>flow</strong></p><h3 id=router>Router
<a class=anchor href=#router>#</a></h3><h4 id=background-3>background
<a class=anchor href=#background-3>#</a></h4><p><img src=/image-20241114151714903.png alt=image-20241114151714903></p><p>Global routing plays a crucial role in electronic design automation (EDA), serving not only as a means of optimizing routing but also as a tool for estimating routability in earlier stages such as logic synthesis and physical planning.</p><p>Optimal(最优) global routing is a <strong>NP-complete</strong> problem.</p><p><img src=/image-20241114155408683.png alt=image-20241114155408683></p><p>DRL：</p><p><img src=/image-20241114163851523.png alt=image-20241114163851523></p><p><img src=/image-20241114164422672.png alt=image-20241114164422672></p><p><img src=/image-20241114164432478.png alt=image-20241114164432478></p><p><img src=/image-20241114164629770.png alt=image-20241114164629770></p><p><img src=/image-20241114171359019.png alt=image-20241114171359019></p><p><strong>传统2dGR flow</strong></p><p><img src=/image-20241122111320412.png alt=image-20241122111320412></p><p><img src=/image-20241122111224572.png alt=image-20241122111224572></p><p><img src=/image-20241122111232778.png alt=image-20241122111232778></p><p><img src=/image-20241122113559774.png alt=image-20241122113559774></p><p><strong>3dGR flow</strong></p><h4 id=gr_outdated>GR_outdated
<a class=anchor href=#gr_outdated>#</a></h4><h5 id=flute><a href=/zh/>FLUTE</a>
<a class=anchor href=#flute>#</a></h5><p>FLUTE is an RSMT construction algorithm adopting a look-up table approach, which is both fast and optimal for low-degree nets. However, FLUTE is unaware of routing <strong>congestion</strong>.</p><p><img src=/image-20241116114652698.png alt=image-20241116114652698></p><p>下面是一系列FLUTE和基于FLUTE的改进</p><p><img src=/image-20241116114634422.png alt=image-20241116114634422></p><h5 id=fastroute102006><a href=/zh/>FastRoute1.0—2006</a>
<a class=anchor href=#fastroute102006>#</a></h5><ul><li>roposed a simple way to construct <strong>congestion driven Steiner tree</strong> and an edge shifting technique to further refine it</li></ul><h5 id=fastroute-20-monotonic2007><a href=/zh/>fastroute 2.0-Monotonic–2007</a>
<a class=anchor href=#fastroute-20-monotonic2007>#</a></h5><ul><li>monotonic routing to explore all shortest routing paths for two-pin connections.</li></ul><p><strong>task</strong></p><p><img src=/image-20241114191327215.png alt=image-20241114191327215></p><p><strong>flow</strong></p><p><strong><img src=/image-20241114205659503.png alt=image-20241114205659503></strong></p><p><img src=/image-20241115160208134.png alt=image-20241115160208134></p><h5 id=fastroute-30-virtual-capacity-iccad-2008-><a href=/zh/>fastroute 3.0-virtual capacity-ICCAD-2008-</a>
<a class=anchor href=#fastroute-30-virtual-capacity-iccad-2008->#</a></h5><h5 id=fastroute-40-via-min-tree3-bending-aspdac-2009-><a href=/zh/>fastroute 4.0-via min tree+3 bending-ASPDAC-2009-</a>
<a class=anchor href=#fastroute-40-via-min-tree3-bending-aspdac-2009->#</a></h5><p><img src=/image-20241116121010565.png alt=image-20241116121010565></p><p><img src=/image-20241115160433890.png alt=image-20241115160433890></p><p><img src=/image-20241115160445784.png alt=image-20241115160445784></p><p><img src=/image-20241116105606149.png alt=image-20241116105606149></p><p><img src=/image-20241116121317660.png alt=image-20241116121317660></p><p><img src=/image-20241116121311506.png alt=image-20241116121311506></p><p><strong>层分配</strong></p><p><img src=/image-20241116124343911.png alt=image-20241116124343911></p><p>?</p><p><img src=/image-20241116125839541.png alt=image-20241116125839541></p><p><img src=/image-20241116125830996.png alt=image-20241116125830996></p><h5 id=maizerouter-><a href=/zh/>MaizeRouter-</a>
<a class=anchor href=#maizerouter->#</a></h5><ul><li>2nd place of ISPD 2007 contest 2D GR</li><li>1st place of ISPD 2007 contest 3D GR</li></ul><h5 id=boxrouter-10><a href=/zh/>BoxRouter 1.0</a>
<a class=anchor href=#boxrouter-10>#</a></h5><ul><li>3rd place of ISPD 2007 contest 2D GR</li><li>2nd place of ISPD 2007 contest 3D GR</li><li>integer linear programming (ILP) based</li></ul><h5 id=fgr-3d-tcad-2008-><a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=4526750">FGR-3d-TCAD-2008-</a>
<a class=anchor href=#fgr-3d-tcad-2008->#</a></h5><ul><li>1st place of ISPD 2007 contest 2D GR</li><li>3rd place of ISPD 2007 contest 3D GR</li></ul><h5 id=-layer-assignmentvia-minization-trans-2008-dp-nthu><a href=https://ieeexplore-ieee-org-443.webvpn.scut.edu.cn/document/4603083>-Layer assignment+Via minization-Trans-2008-DP-NTHU</a>
<a class=anchor href=#-layer-assignmentvia-minization-trans-2008-dp-nthu>#</a></h5><ul><li>Congestion-Constrained Layer Assignment for Via Minimization in Global Routing</li><li>CUGR’s rely work</li><li>ISPD07 contest后的一个跟进工作</li><li>也没提到maze routing</li><li>没定义wire cost, 在每一对GCell之间layer assignment, 慢？</li><li>第一次用DP?</li></ul><p><strong>background:</strong></p><ul><li><p>there are two main approaches</p><p><img src=/image-20250208202630352.png alt=image-20250208202630352></p><ul><li><p><code>3D</code>: route all nets directly on the multilayer solution space. Because this approach directly generates a multilayer global routing result, <strong>it can take the via cost into account during construction</strong>. However, this method may cost <strong>too much CPU time</strong> with a large problem size. (现在都用GPU做并行了，这种方法就变多了)</p><ol><li><p>such as</p><p><img src=/image-20250208201732440.png alt=image-20250208201732440></p></li></ol></li><li><p><code>2D + layer assigment</code>: The other approach is to first <strong>compress</strong> a multilayer grid graph into a one-layer grid graph, then use a <strong>one-layer router</strong> to solve the one-layer global routing problem, and finally perform <strong>layer assignment</strong> to assign each wire in the multilayer grid graph</p><p><img src=/image-20250208202642473.png alt=image-20250208202642473></p><p>The edges corresponding to <strong>vias disappear</strong> in the one-layer grid graph. The capacity of each edge in the one-layer grid graph is obtained by <strong>accumulating</strong> the corresponding edge capacities in the three-layer grid graph</p><p>This approach can take advantage of many current full-fledged one-layer routers, e.g., [2]–[4], and use an affordable run time to generate an initial one-layer routing result. 本文主要针对layer assignment. 注意layer assignment 是对二维的所有边进行层分配。</p></li></ul></li><li><p>vias not only degrade the reliability and the performance of a design but also increase the manufacturing cost.</p></li><li><p>previous work’s layer assignment use greedy heuristics [8] or time-consuming integer linear programming methods [9] to minimize the via cost.</p></li><li><p>像这种串行的还是要考虑net order, 越早布线的net越不会拥塞，net order很重要</p></li></ul><p><strong>task and contribution:</strong></p><ul><li>这篇没有考虑优先方向（To simplify the presentation of our algorithm, we do not make any assumption about the preferred routing direction for each layer in the layer assignment problem.）不过也说明了这个工作能够很简单引用到考虑优先方向的情况</li><li>follow ISPD07 contest, 假设via的capacity是无限的（CUGR中明确了不进行这种假设）</li><li>based on a one-layer routing result</li><li>minimize <code>via cost</code>, <code>WL</code> and <code>congestion overflow</code></li><li>propose a polynomial-time algorithm: first generate <code>net order</code> , then solves the layer assignment problem</li><li>can improve 3 winner of ISPD07 contest</li></ul><p><strong>model</strong></p><ul><li><p>COngestion-constrained Layer Assignment (COLA)’s submodule</p><ul><li><p>Net order generation</p><ol><li><p>The net order has a direct influence on the utilization of routing resources, so it is one of the key parts of COLA.</p></li><li><p>对net进行打分决定order</p><p><img src=/image-20250208220017618.png alt=image-20250208220017618></p><p>注意，线长越短，分数越高，net越应该先布线。解释：</p><p><img src=/image-20250208221143998.png alt=image-20250208221143998></p></li></ol></li><li><p>Eemove Cycles</p><ol><li><p>Arbitrarily remove.</p></li><li><p>（为什么映射到第一层会有cycles？初始是怎么连起来的？没说？FLUTE算法是08年才出来，可能当时还没用上）</p><p><img src=/image-20250208222041475.png alt=image-20250208222041475></p></li></ol></li><li><p>Single-net layer assignment （SOLA+APEC）</p><p><strong>SOLA</strong>(Singlenet Optimal Layer Assignment)</p><ol><li><p>determines an optimal layer assignment result <strong>without considering congestion constraints</strong> for a given net</p></li><li><p><strong>dynamic programming</strong> technique</p></li><li><p>不考虑拥塞，这个方法能得到最好质量</p></li><li><p>step:</p><blockquote><p>01: for tree in layer 1, <strong>random</strong> select a pin as root, then use DFS or DFS to get a <strong>queue</strong>, so get the edge <strong>order</strong>. It become a <strong>DAG</strong></p><p><img src=/image-20250208223956201.png alt=image-20250208223956201></p><p>02: 定义图5(c)中, a的父节点是p2，定义mvc(v, r)（minimum via cost）</p><p><img src=/image-20250209140741895.png alt=image-20250209140741895></p><p>03:</p><p>​ for pins who have not child, mvc:</p><p><img src=/image-20250209143711603.png alt=image-20250209143711603></p><p>​ for pins who have child and not root:</p><p>​ 这个公式其实就是为了确定下每个点下一步的layer在哪里。比如算出最小是mvc(v, 1), 那么e_(v, ch(e))就在第r层</p><p><img src=/image-20250209143753884.png alt=image-20250209143753884></p><p>​ for root:</p><p><img src=/image-20250209145157487.png alt=image-20250209145157487></p><ul><li><p>the difference is excluding r in ∆</p></li><li><p>because mvc(v, r) does not depend on the value of r when v</p><p>is the root, we have mvc (v, 1) = mvc(v, 2) = · · · = mvc(v, k)</p></li></ul></blockquote></li></ol><p><strong>APEC</strong>(Accurate and Predictable Examination for Congestion constraints)</p><ol><li><p>can detect and prevent any <strong>congestion</strong> constraint violation in advance</p></li><li><p>prevention condition:</p><p><img src=/image-20250209153339230.png alt=image-20250209153339230></p><p>如果存在一个在layer1上压缩的边不满足这两个condition，那么这条边的layer assignment（SOLA）结果就不可能满足congesion</p></li></ol></li><li><p>SOLA+APEC always finds a layer assignment result satisfying both <strong>prevention conditions</strong> for each net</p></li></ul></li><li><p>COLA</p><p><img src=/image-20250209153812734.png alt=image-20250209153812734></p></li></ul><p>​</p><p><strong>data:</strong></p><p>six-layer benchmarks from ISPD’07</p><h5 id=grip-3dip-dac-2009><a href=https://dl.acm.org/doi/pdf/10.1145/1629911.1629999>GRIP-3d+IP-DAC-2009</a>
<a class=anchor href=#grip-3dip-dac-2009>#</a></h5><p>基于整数规划</p><p>3d: solve the 3D problem directly on the 3D routing grids,</p><p>slow: Although theoretically the direct 3D technique should produce better solutions, in practice it is less successful in both solution quality and runtime than 2D routing with layer assignment –cite–> [Fastroute4.1]</p><p>slow: Although we see solutions with shorter wirelength generated by full-3D concurrent approach like GRIP [21], that solution quality is achieved by impractically long runtime –cite–> [Fastroute4.1]</p><p><a href=https://ieeexplore.ieee.org/abstract/document/6105336>MGR–ICCAD-2011</a></p><p>multi-level （coarsened and fine-gained）</p><h5 id=fastroute41-an-efficient-and-high-quality-global-router-2012><a href=https://home.engineering.iastate.edu/~cnchu/pubs/j52.pdf>FastRoute4.1-an efficient and high-quality global router-2012</a>
<a class=anchor href=#fastroute41-an-efficient-and-high-quality-global-router-2012>#</a></h5><p><a href=https://dl.acm.org/doi/abs/10.1155/2012/608362>https://dl.acm.org/doi/abs/10.1155/2012/608362</a></p><p><strong>background</strong></p><p>FastRoute is a global routing tool for VLSI back-end design. It is based on sequential rip-up and re-route (RRR) and a lot of novel techniques.
<a href=http://home.engineering.iastate.edu/~cnchu/pubs/c36.pdf>FastRoute 1.0</a> first uses <strong>FLUTE</strong> to construct <strong>congestion-driven Steiner trees</strong>, which will later undergo the <strong>edge shifting</strong> process to optimize tree structure to reduce congestion. It then uses <strong>pattern routing and maze routing</strong> with <strong>logistic function</strong> based cost function to solve the congestion problem.
<a href=http://home.engineering.iastate.edu/~cnchu/pubs/c40.pdf>FastRoute 2.0</a> proposed <strong>monotonic routing</strong> and <strong>multi-source multi-sink maze routing</strong> techniques to enhance the capability to reduce congestion.
<a href=http://home.engineering.iastate.edu/~cnchu/pubs/c51.pdf>FastRoute 3.0</a> introduced the <strong>virtual capacity</strong> technique to adaptively change the capacity associated with each global edge to divert wire usage from highly congested regions to less congested regions.
<a href=http://home.engineering.iastate.edu/~cnchu/pubs/c52.pdf>FastRoute 4.0</a> proposed <strong>via-aware Steiner tree</strong>, <strong>3-bend routing</strong> and a <strong>delicate layer assignment algorithm</strong> to effectively reduce via count while maintaining outstanding congestion reduction capability.
<a href=http://home.engineering.iastate.edu/~cnchu/pubs/j52.pdf>FastRoute 4.1</a> simplifies the way the <strong>virtual capacities</strong> are updated and applies a single set of tuning parameters to all benchmark circuits.</p><p><strong>model</strong></p><p><img src=/image-20241211103407310.png alt=image-20241211103407310></p><p><strong>flow</strong></p><p><img src=/image-20241211103347856.png alt=image-20241211103347856></p><h5 id=nthu-route-10---tvlsi-2010-><a href=https://ieeexplore.ieee.org/document/5703167>NTHU Route 1.0- -TVLSI-2010-</a>
<a class=anchor href=#nthu-route-10---tvlsi-2010->#</a></h5><p><img src=/image-20241115155033412.png alt=image-20241115155033412></p><h5 id=nthu-route-20---tcad-2013><a href=https://ieeexplore.ieee.org/document/6504553>NTHU Route 2.0- -TCAD-2013</a>
<a class=anchor href=#nthu-route-20---tcad-2013>#</a></h5><p>2D</p><h5 id=nctu-gr-10-3d-congestion-relaxed-layer-assignment--2011-><a href=https://ieeexplore.ieee.org/document/5703167>NCTU GR 1.0-3D-congestion relaxed layer assignment- 2011-</a>
<a class=anchor href=#nctu-gr-10-3d-congestion-relaxed-layer-assignment--2011->#</a></h5><ul><li>it improved the scheme to estimate the realtime congestion more accurately by using a history term that will gradually wear off as the number of iterations increases if the overflow disappears.</li><li></li></ul><h5 id=nctu-gr-20-multithreaded-collision-aware--cad-2013-><a href=https://ieeexplore.ieee.org/document/6504553>NCTU GR 2.0-Multithreaded Collision Aware- CAD-2013-</a>
<a class=anchor href=#nctu-gr-20-multithreaded-collision-aware--cad-2013->#</a></h5><p><a href=https://people.cs.nycu.edu.tw/~whliu/NCTU-GR.htm>people.cs.nycu.edu.tw/~whliu/NCTU-GR.htm</a></p><p><a href=https://github.com/PengjuY/NCTU-GR2>PengjuY/NCTU-GR2: This is a binary file of NCTUgr2, which is a global router</a></p><ul><li>net-level parallel method</li><li>2D</li></ul><h5 id=boxrouter-20><a href=/zh/>BoxRouter 2.0</a>
<a class=anchor href=#boxrouter-20>#</a></h5><p><strong>background</strong></p><p><strong>task</strong></p><p>是一个2d的</p><p>整数规划</p><p><img src=/image-20241115155857782.png alt=image-20241115155857782></p><h5 id=ogre--new-cost-function---2019---><a href=https://woset-workshop.github.io/PDFs/2019/a18.pdf>OGRE- new cost function- -2019- -</a>
<a class=anchor href=#ogre--new-cost-function---2019--->#</a></h5><ul><li><a href=https://github.com/AUCOHL/OGRE>Open source!</a></li><li><strong>LEF/DEF-based</strong></li><li>3D</li><li>用的是老方法，不过解释的挺清楚的</li><li>components by a group of undergraduate students as a course project.</li></ul><h4 id=gr_adv>GR_Adv
<a class=anchor href=#gr_adv>#</a></h4><h5 id=-drl-method-2019-drl-><a href=https://arxiv.org/pdf/1906.08809>-DRL method-2019-DRL-</a>
<a class=anchor href=#-drl-method-2019-drl->#</a></h5><p><strong>task</strong></p><ul><li>DRL(DQN) for global route</li><li>have not use real world design</li></ul><p>example:</p><p>​ from A to B</p><p>​ read means over flow</p><p><img src=/image-20241114192638647.png alt=image-20241114192638647></p><p><img src=/image-20241114193438871.png alt=image-20241114193438871></p><p><strong>pipeline</strong></p><p><img src=/image-20241114192055104.png alt=image-20241114192055104></p><p><strong>model</strong></p><p>state:</p><ul><li>(pos_x/y/z, distance_x/y/z, 周围的capacity, )这种编码方案可以被视为当前状态、导航和本地容量信息的混合</li></ul><p>action: 上下左右前后</p><p>reward：</p><p><img src=/image-20241114200225347.png alt=image-20241114200225347></p><p><img src=/image-20241114200512353.png alt=image-20241114200512353></p><p><strong>contribution</strong></p><p>first deep learning model for global routing</p><h5 id=-only-cnn-dac-2020-cnnvae-><a href="https://ieeexplore-ieee-org-443.webvpn.scut.edu.cn/stamp/stamp.jsp?tp=&amp;arnumber=9218598">-only CNN-DAC-2020-CNN(VAE)-</a>
<a class=anchor href=#-only-cnn-dac-2020-cnnvae->#</a></h5><ul><li>no experiment!</li><li>只用CNN分类结果不会好吧</li><li>不知道是什么类型的文章，只用了两页</li></ul><p><strong>background</strong></p><p>is approach treats the global routing problem as an <strong>image processing</strong> problem and solves it with a deep learning system</p><p><img src=/image-20241114161657070.png alt=image-20241114161657070></p><p><strong>dataset</strong></p><p>ISPD’98 ibm01 64x64 circuit</p><p><strong>model</strong></p><p><img src=/image-20241114162111775.png alt=image-20241114162111775></p><h5 id=-drl-arxiv-2021-jp><a href=https://arxiv.org/pdf/2010.09465>-DRL-arxiv-2021-JP</a>
<a class=anchor href=#-drl-arxiv-2021-jp>#</a></h5><h5 id=sproute-10-a-scalable-parallel-negotiation-based-global-router-iccad-2019ieee-xplore-full-text-pdf>[SPRoute 1.0: A Scalable Parallel Negotiation-based Global Router-ICCAD-2019](
<a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=8942105">IEEE Xplore Full-Text PDF:</a>)
<a class=anchor href=#sproute-10-a-scalable-parallel-negotiation-based-global-router-iccad-2019ieee-xplore-full-text-pdf>#</a></h5><p><strong>task</strong></p><p>基于net-level多线程的并行加速迷宫算法</p><p>negotiation-based rip-up and reroute two-phase maze routing</p><p>resolves livelock issue</p><p>open source</p><ul><li>introduced a concept called <code>soft capacity</code> to reserve routing space for detailed routing and explored <code>several parallelization strategies</code> to speed up global routing.</li></ul><p><strong>background</strong></p><p>总体</p><p><img src=/image-20241118140649906.png alt=image-20241118140649906></p><p>In many global routers, maze routing is the most time-consuming stage.</p><p><img src=/image-20241118141048410.png alt=image-20241118141048410></p><p><strong>challenge</strong></p><p><img src=/image-20241118144548718.png alt=image-20241118144548718></p><p><img src=/image-20241118144701004.png alt=image-20241118144701004></p><p>因为这个现象，多线程反而慢了</p><p><img src=/image-20241118144924768.png alt=image-20241118144924768></p><p><strong>原理</strong></p><ul><li><p>Galois system</p><p><img src=/image-20241118150854386.png alt=image-20241118150854386></p></li><li><p>Net-level Parallelism</p></li><li><p>Fine-grain Parallelism</p></li></ul><p><strong>data</strong></p><p>ISPD 2008 contest</p><h5 id=sproute-20--detailed-routability-driven-asp-dac-2019-><a href=https://ieeexplore.ieee.org/abstract/document/9712557>SPRoute 2.0- detailed routability driven-ASP DAC-2019-</a>
<a class=anchor href=#sproute-20--detailed-routability-driven-asp-dac-2019->#</a></h5><p><strong>特点</strong></p><p>基于多线程的并行加速</p><p>2D</p><p>开源：
<a href=https://github.com/asyncvlsi/SPRoute/tree/master>asyncvlsi/SPRoute: A parallel global router using the Galois framework</a></p><h5 id=cugr-3d-patternmulti-level-maze-routingpatching-dac-2020-cuhk><a href=https://github.com/cuhk-eda/cu-gr>CUGR-3D pattern+Multi level maze routing+patching-DAC-2020-CUHK</a>
<a class=anchor href=#cugr-3d-patternmulti-level-maze-routingpatching-dac-2020-cuhk>#</a></h5><ul><li><p>ICCAD 2019 Contest First Place</p></li><li><p><a href=https://github.com/cuhk-eda/cu-gr>open source!</a></p></li><li><p>3d+多线程+</p></li><li><p>这个文章没有讨论prefer direction</p></li><li><p>多线程体现在哪里？</p></li><li><p>注意：这种格式的GR输出可以适配Innovus</p></li><li><p>time-complexity of 3D pattern routing is $\mathcal{O}(L^4|V|)$</p><p>compare with [Trans-2008](#
<a href=https://ieeexplore-ieee-org-443.webvpn.scut.edu.cn/document/4603083>-Layer assignment+Via minization-Trans-2008-DP-NTHU</a>), CUGR reduces the complexity to $\mathcal{O}(L^4|V|)$ by selecting the root carefully so that each vertex will have at most three preceding vertices instead of four. <del>注意，这里说 相比[Trans-2008](#
<a href=https://ieeexplore-ieee-org-443.webvpn.scut.edu.cn/document/4603083>-Layer assignment+Via minization-Trans-2008-DP-NTHU</a>)的$\mathcal{O}(L^5|V|)$ ，它的复杂度是$\mathcal{O}(L^4|V|)$ ，感觉是放在了[Trans-2008](#
<a href=https://ieeexplore-ieee-org-443.webvpn.scut.edu.cn/document/4603083>-Layer assignment+Via minization-Trans-2008-DP-NTHU</a>)进行不转弯的DP-based layer assignment方法上了，实际上按照本文说的方法，理论上是$L * L^{2<em>3}|V|$，因为CUGR每次是对一个L pattern为单位计算<code>mvc</code>,时间复杂度是$2</em>L*L$</del>.确实是$L^4$, CUGR对一个L pattern分了两部分计算<code>mvc</code>没一部分时间复杂度是$L*2$</p></li></ul><p><strong>background</strong></p><p><img src=/image-20241122110742970.png alt=image-20241122110742970></p><ul><li>A common strategy of doing 3D global routing, as adopted by NCTU-GR 2.0 [5], NTHU-Route 2.0 [6], NTUgr [7] and FastRoute 4.0 [8], is to <strong>first compress the 3D grid graph into a 2D grid graph and perform 2D global routing</strong>.</li><li>directly route the nets in a 3D grid graph：FGR [10] , GRIP [11] , MGR [12]</li><li>Traditional pattern routing generates 2D topologies only, while <strong>our</strong> proposed 3D pattern routing directly generates 3D topologies without the need of an extra layer assignment stage</li><li>使用DR结果进行多角度metrics 评估：</li></ul><p><img src=/image-20241122113634633.png alt=image-20241122113634633></p><p><strong>task</strong></p><ul><li>detailed-routability-driven directly-3d multi thread GR</li></ul><p><strong>contibution</strong></p><ul><li>probability-based cost scheme<ul><li>minimizing the possibility of overflow after detailed routing</li></ul></li><li><code>3D pattern routing</code> technique (2D pattern routing + layer assignment)(前面又说directly in the 3D space?)<ul><li>without overflow even only L shape patten routing</li><li>pre-work[15] 是先在2d上进行pattern routing, 然后进行layer assignment, 这里是直接在3d进行pattern routing. 3d pattern routing can avoid loss of accuracy caused by compressing 3D grid graph to 2D</li></ul></li><li><code>multi-level maze routing</code>:<ul><li>coarsened level –> searches for a region with the <strong>best routability</strong>. <strong>first</strong> narrows the search space to a smaller region</li><li>fine-grained level –> searches for a <strong>lowest cost</strong> solution within the region</li></ul></li><li>patching mechanism<ul><li>further improve the detailed routability</li></ul></li></ul><p><strong>flow</strong></p><p><img src=/image-20241122123825463.png alt=image-20241122123825463></p><p>In <code>3D pattern routing</code> (<code>inital routing</code>), the nets are broken down into two-pin nets, and a <code>dynamic programming</code> based algorithm will route the two pin nets sequentially using Lshape patterns and <code>stacking vias</code> at the turns.</p><p>In the <code>multi-level 3D maze routing</code> phase, the grid graph is <code>coarsened</code> to shrink the routing space, and maze routing is first performed in the coarsened space with an objective to find a routing region with the <strong>highest routability</strong>. A <code>fine-grained maze routing</code> will then search for a lowest cost path within the region. use its <code>patching</code> mechanism here.</p><p><strong>model</strong></p><ul><li><p>Gcell之间的容量等于track，一般GR表征via的容量是无限的，但是在本文中不是</p></li><li><p><strong>three base definition:</strong></p><ul><li>resource = capacity - demand</li><li>这三个变量在GCell和wire_edge上都有特征，也就是说有6个值</li><li>resource 能够直接表示拥程度</li><li><img src=/image-20241122130729921.png alt=image-20241122130729921></li><li><img src=/image-20241122130736928.png alt=image-20241122130736928></li></ul></li><li><p><strong>cost scheme</strong></p><ul><li><p>主要分成wire和via两部分：</p><p><img src=/image-20241122130626631.png alt=image-20241122130626631></p></li><li><p>wire cost:</p><p><img src=/image-20241122130653693.png alt=image-20241122130653693></p><ol><li><p>*<code>wl</code>*is wire lenght cost</p></li><li><p><em><code>eo</code></em> is expected overflow cost, where <em><code>uoc</code></em> is hyper parameter, The larger <em><code>d(u, v)</code></em> is, the more likely it is to be congested. is accurate if the <strong>DR</strong> adopts the simplest strategy of picking a track <strong>randomly</strong> to route. However, most well designed detailed routers will do much better than random selection.</p></li><li><p><em><code>lg(u,v)</code></em> is a variable to refine <em><code>d(u, v)</code></em>. “+1” 是为了值域在（0，1）表示概率。 <em><code>slope</code></em> is hyper parameter. When the resources are abundant, there is almost <strong>no congestion cost</strong>, but the cost will increase rapidly as the resources are being used up and will keep increasing almost <strong>linearly</strong> after all the resources are used</p><p><img src=/image-20241122130807532.png alt=image-20241122130807532></p></li></ol></li><li><p>via cost:</p><ol><li>thanks to our <strong>3D pattern routing strategy</strong>, a via cost scheme can be embedded to reflect the impact.</li><li><img src=/image-20241122130701652.png alt=image-20241122130701652></li><li><em><code>uvc</code></em> is hyper parameter.</li><li>公式（5a）为什么要“+1”</li></ol></li></ul></li><li><p>Initial Routing / 3D Pattern Routing</p><ol><li><p>use <code>FLUTE</code> first (not congestion awared)</p></li><li><p>use <code>edge shifting</code> (described in
<a href=/zh/#[FastRoute1.0%e2%80%942006]%28%29>FastRoute</a>) to alleviate congestion.</p></li><li><p><strong>randomly</strong> choose one node in net, use DFS to get a queue and then get a DAG</p></li><li><p>类似[15]，动态规划选择cost最小的3d L pattern，每个L pattern有(2 * L * L)种可能</p><p><img src=/image-20250209165125803.png alt=image-20250209165125803></p><p>最后在root处得到最终的结果</p></li></ol></li><li><p>Multi-level 3D Maze Routing</p><ul><li><p>maze route planing</p><p>aims at finding a smaller but highly routable search space</p><ol><li><p>compress a block of G-cells (5x5 in our implementation), use avg to descripe <code>capacity, demand, resource</code></p></li><li><p>cost function:</p><p><img src=/image-20250209172954350.png alt=image-20250209172954350></p></li><li><p>得到灰色粗网格：</p><p><img src=/image-20250209173822187.png alt=image-20250209173822187></p></li><li><p>之后会在这几个BBox中分别进行计算<code>cost scheme</code>，得到上图黑色实线</p></li></ol></li><li><p>fine-grained maze routing within guides</p></li></ul></li><li><p>Postprocessing / Guide Patching</p><ul><li><p>we can add new guides to improve detailed routability. adding new stand-alone guides to alleviate routing hot spots.</p></li><li><p>three kind of patching:</p><ol><li><p>Pin Region Patching</p><ul><li><p>most effective</p></li><li><p>the ideal way of improving pin accessibility is to identify those hard-to-access pins and assign more resources to them</p><p><img src=/image-20250209191227014.png alt=image-20250209191227014></p></li><li><p>Our global router will check the upper (or lower) two layers of a pin, which are vital for accessing the pin. use 3 × 3 patching guides.</p></li><li><p>没写判断<code>hard-to-access pins </code>的具体的方法</p></li></ul></li><li><p>Long Segment Patching:</p><ul><li>a longer routing segment often means more wrong way wires and causing more congestion.</li><li>If a guide is longer than a specified length I, we’ll consider long segment patching.</li></ul><p><img src=/image-20250209191725644.png alt=image-20250209191725644></p><ul><li>if a G-cell with resource below a threshold T is encountered, a single G-cell route guide will be patched above or below it, depending on which of them has sufficient resource</li></ul></li><li><p>Violation Patching:</p><ul><li><p>For G-cell with inevitable violations, patching will be used again to enable the detailed router to search with more flexibility.</p><p><img src=/image-20250209192310471.png alt=image-20250209192310471></p></li><li></li></ul></li></ol></li></ul></li></ul><p><strong>data</strong></p><p>iccad 2019 dataset</p><p><strong>experiment</strong></p><p><img src=/image-20241122113716242.png alt=image-20241122113716242></p><p><img src=/image-20250209192916035.png alt=image-20250209192916035></p><ul><li><p>他自己又比赛后改进了</p></li><li><p><img src=/image-20250209195431218.png alt=image-20250209195431218></p></li><li><p>our algorithm’s peak memory is close to the first place and is 1.83 times of that of the second place on average (ours is 8.22 GB on average and is <strong>19.8 GB</strong> for</p><p>the biggest design)</p></li></ul><h5 id=fastgr-gpu-pattern-routing-multi-thread-mazedate-2022-pkucuhkhnal><a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=9774606">FastGR-GPU pattern routing+ multi thread maze–DATE-2022-PKU+CUHK+HNAL</a>
<a class=anchor href=#fastgr-gpu-pattern-routing-multi-thread-mazedate-2022-pkucuhkhnal>#</a></h5><ul><li>GPU-accelerated</li><li>accelerated the 3D pattern routing algorithm of [CUGR](#
<a href=https://github.com/cuhk-eda/cu-gr>CUGR-3D pattern+Multi level maze routing+patching-DAC-2020-CUHK</a>) for initial routing by both <code>net-level</code> and <code>path-level</code> parallelization on GPU</li></ul><h5 id=gamer---trans-2022---><a href=/zh/>Gamer- -Trans-2022- -</a>
<a class=anchor href=#gamer---trans-2022--->#</a></h5><ul><li>GPU-accelerated</li><li>accelerated the two-level maze routing of [CUGR](#
<a href=https://github.com/cuhk-eda/cu-gr>CUGR-3D pattern+Multi level maze routing+patching-DAC-2020-CUHK</a>) for rip-up and reroute by updating vertical and horizontal routing costs alternatively on GPU</li></ul><h5 id=ggr-super-fast-gpu-accelerate-iccad-2022-><a href=https://github.com/cuhk-eda/Xplace/tree/main/cpp_to_py/gpugr>GGR-super fast gpu accelerate-ICCAD-2022-</a>
<a class=anchor href=#ggr-super-fast-gpu-accelerate-iccad-2022->#</a></h5><p>open source！
<a href=https://github.com/cuhk-eda/Xplace/tree/main/cpp_to_py/gpugr>Xplace/cpp_to_py/gpugr at main · cuhk-eda/Xplace</a></p><p><strong>background</strong></p><p><img src=/image-20241114223402627.png alt=image-20241114223402627></p><p><strong>Performance depends on the detail route</strong></p><p>Modern global routing problem, which was introduced at the 2019 CAD contest at ICCAD, targets at closing
the gap between global routing and detailed routing. The LEF/DEF files for detailed routing are directly used as the input for global routing.</p><p>The global routing quality is evaluated using an academic <strong>detailed router Dr. CU[8]</strong></p><p>2019 ICCAD contest on global routing did not directly evaluate global routing results based on overflows and total wirelength. The new evaluation uses the global routing results as route guides for a detailed router, and the metrics are all detailed routing related</p><p><strong>2D & 3D</strong></p><p>NCTU-GR 2.0[13], SPRoute[7] and FastRoute 4.0[14] are 2D GR</p><p>However, compressed 2D grid graphs are less accurate than 3D grid graphs in terms of routing resources, which could limit the global routing quality.</p><p>CUGR[11]. It has both 3D pattern routing and 3D maze routing</p><p><strong>multi-thread vs GPU</strong></p><p><img src=/image-20241114225533925.png alt=image-20241114225533925></p><p><img src=/image-20241114231041875.png alt=image-20241114231041875></p><p>LEF/DEF based academic global routers <strong>SPRoute 2.0[6]</strong> is the only 2D GR</p><p><strong>GAMER[10]</strong> is a novel parallel <strong>maze</strong> routing algorithm integrated in <strong>CUGR</strong>.</p><p><strong>FastGR[12]</strong> introduced <strong>GPU</strong> parallelization of <strong>L-shape pattern</strong> routing</p><p><strong>contribution</strong></p><p><img src=/image-20241114225935669.png alt=image-20241114225935669></p><p><strong>flow</strong></p><p><img src=/image-20241114230008749.png alt=image-20241114230008749></p><p><strong>data</strong></p><p><strong>model</strong></p><h5 id=cugr-20-dag-based-dac-2023---cuhk><a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=10247702">CUGR 2.0-DAG-based-DAC-2023- -CUHK</a>
<a class=anchor href=#cugr-20-dag-based-dac-2023---cuhk>#</a></h5><ul><li><a href=https://github.com/cuhk-eda/cu-gr-2>open source!</a></li></ul><p><strong>background</strong></p><ul><li>many of the aforementioned global routers is that most of them rely heavily on <strong>time-consuming path search algorithms</strong> like maze routing to resolve overflows. These approaches are not efficient enough even with parallilization and may cause lots of unnecessary detours</li></ul><p><strong>contribution:</strong></p><ul><li><p>a <strong>DAG-based</strong> generalized pattern routing algorithm</p></li><li><p>a <strong>new</strong> <code>dynamic programming-based</code> algorithm to calculate the routing cost</p><p>time complexity from $\mathcal{O}(L^4|V|)$ to $\mathcal{O}(L^2|V|)$</p></li><li><p>a DAG <code>augmentation algorithm</code> that enables the creation of <strong>alternative paths</strong> in a routing DAG. can even shift or create Steiner points. over 99% nets can be successfully routed without the need of maze routing</p></li><li><p>a new <strong>sparse</strong> graph maze routing algorithm</p><p>creation of alternative paths in a</p><p>routing DAG</p></li></ul><p><strong>flow</strong></p><ol><li><p>RSMT</p><p><img src=/image-20250210142956411.png alt=image-20250210142956411></p></li><li><p>DFS and<code> Routing DAG</code> with L pattern</p><p>注意多了节点g,f,i,h, 现在每条都是直线</p><p><img src=/image-20250210143037337.png alt=image-20250210143037337></p><p><code>Routing DAG</code> with other patterns，但是在这里没用做初始布线，初始只用了L-shape。文章也就这里提了一下，后面都和这个无关，得去源码仔细看看。</p><p><img src=/image-20250210143529434.png alt=image-20250210143529434></p></li><li><p>Dynamic Programming-based DAG routing(L-shape + Layer assignment)</p><p>没说怎么舍弃的？</p></li><li><p>DAG-based pattern routing with <strong>augmentation</strong></p></li><li><p>sparse graph <strong>maze</strong> routing algorithm</p></li></ol><p><strong>model</strong></p><ul><li><p>cost</p><ul><li><p>Dynamic Programming-based</p><p><img src=/image-20250210203428984.png alt=image-20250210203428984></p></li><li><p>DAG Augmentation for Congestion</p><p><img src=/image-20250210203818643.png alt=image-20250210203818643></p><ol><li><p>create alternative paths</p><p><img src=/image-20250210204123847.png alt=image-20250210204123847></p></li><li><p>Steiner point movement</p><p>具体怎么移动的文章也没说</p></li></ol></li></ul></li></ul><p><strong>experiment:</strong></p><ul><li><p>compare with CUGR [12] and SPRoute 2.0 [13]</p><p><img src=/image-20250210211951988.png alt=image-20250210211951988></p><p><img src=/image-20250210212311337.png alt=image-20250210212311337></p><p>only one thread for run time</p></li><li><p><img src=/image-20250210212636193.png alt=image-20250210212636193></p></li><li><p>Effectiveness of steiner point augmentation</p></li><li><p><img src=/image-20250210212920933.png alt=image-20250210212920933></p></li><li><p>run time compare with GPU-accelerated GR</p><ul><li><p>compare with FastGR [14] and GAMER [15]</p></li><li><p>GPU的好坏也有关系吧。本实验用的RTX 3090</p></li><li><p>slightly faster than FastGR for initial routing</p><p><img src=/image-20250210213728850.png alt=image-20250210213728850></p></li><li><p>around 5.2× as fast as GAMER</p><p><img src=/image-20250210215926150.png alt=image-20250210215926150></p></li></ul></li></ul><h5 id=instantgr-scalable-gpu-parallelization-iccad-2024-cuhk><a href=https://shijulin.github.io/files/1239_Final_Manuscript.pdf>InstantGR-Scalable GPU Parallelization-ICCAD-2024-CUHK</a>
<a class=anchor href=#instantgr-scalable-gpu-parallelization-iccad-2024-cuhk>#</a></h5><ul><li><a href=https://github.com/cuhk-eda/InstantGR>open source!</a></li><li>second place of ISPD25 contest</li><li>GPU Parallelization</li><li>parallel algorithm is mainly based on the DAG-based global routing algorithm in [CUGR2](#
<a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=10247702">CUGR2.0 EDGE- -DAC-2023-</a>). 应该是3D pattern routing DP的部分和maze routing的部分</li><li>parallel while do initial routing and RRR</li><li>提高了并行度，但是还是有串行的部分</li><li>也用了FLUTE</li><li>一定要以net为单元吗？是为了用DP</li><li></li></ul><p><strong>background</strong></p><ul><li>GPU memory is limited</li><li>This requires memory-efficient solutions that can minimize CPU-GPU communication while maximizing GPU utilization</li><li>large designs have more nets with bigger routing graphs, providing many new parallelization opportunities that are not yet explored</li><li>nets in a batch can be routed in parallel</li></ul><p><strong>task:</strong></p><ul><li>parallelism for large-scale</li><li>partitioned design</li></ul><p><strong>contribution</strong></p><ul><li>a new method for <code>net-level batch generation</code>. based on 3D fine-grained overlap checking and explores more parallelism by increasing the number of nets per batch</li><li><code>node-level</code> parallel routing approach. achieves much higher parallelism compared to traditional net-level parallel routing.</li></ul><p><strong>flow</strong></p><ul><li>In initial routing, we construct a basic <code>routing DAG</code> to perform <strong>L-shape pattern routing</strong>.</li></ul><p><strong>key points</strong></p><p>specific explanation show in
<a href=/zh/docs/Digtal/Routing/routing2/>routing2</a></p><ul><li><p>NET-LEVEL PARALLELISM</p><ul><li><p>simultaneous routing of a <code>batch</code> of nets that do not “<code>overlap</code>”</p></li><li><p>[2, 3, 14, 19, 20, 22, 26] 19年开始的，cugr2和fastgr都用了</p></li><li><p><strong>Typical</strong> Batch Generation Algorithm</p><p>used in [2, 3, 14, 19, 20]</p><p><img src=/image-20250212100127751.png alt=image-20250212100127751></p><p><code>R-trees </code>是实现<code>line 4</code>的常用做法</p><p><code>pessimistically approximates</code> significantly lowers the degree of parallelism</p></li><li><p>define and graph model</p><p><img src=/image-20250212111440550.png alt=image-20250212111440550></p><p><img src=/image-20250212100930831.png alt=image-20250212100930831></p><p>以<code>segment</code>为单位，同时分开了水平和垂直两个部分，假设全部为L-shape，同时对于不在一条线上的两个节点，有两个L</p><p>These four nets will be divided into just <code>one batch</code> based on our exact representation of routing graphs for overlap checking, while into <code>four batches</code> by the traditional bounding box-based pessimistic approximation</p><p>via model:</p><p><img src=/image-20250212110626674.png alt=image-20250212110626674></p><p><img src=/image-20250212104214378.png alt=image-20250212104214378></p><p>via用一个十字表示</p></li><li><p>Overlap Checking Algorithms</p><ol><li><p>以水平子图进行展示，垂直同理</p></li><li><p>以水平segment为单位进行checking</p></li><li><p>首先判断是不是y坐标相等：group the segments with the same 𝑦</p></li><li><p>tradictional algorithm:</p><p>This is a classical computational geometry problem that can be efficiently solved by <code>segment trees</code> [1] in 𝑂(log𝑛) time for both operations,</p><p><img src=/image-20250212114550426.png alt=image-20250212114550426></p></li><li><p>new algorithm motivation:</p><p><img src=/image-20250212114611742.png alt=image-20250212114611742></p><p>segments are very short</p></li><li><p>new algorithm: <code>Point Exhaustion</code></p><p>simply use a Boolean array to record whether each point in [1, 𝑛] is covered by some segment 𝑠 ∈ 𝑆. We mark every point 𝑥 ∈ [𝑙, 𝑟] when a segment [𝑙, 𝑟] is inserted, and check every point 𝑥 ∈ [𝑙𝑞, 𝑟𝑞] for overlap query of a segment [𝑙𝑞, 𝑟𝑞].</p><p>further improve the efficiency of this point exhaustion by using bit arrays</p></li><li><p>another improvement: <code>representative point exhaustion</code></p><ul><li>allowing a little bit of overlap.</li><li>it only checks the two end points of a query segment. ??什么意思</li><li>covering most overlap scenarios in practice.</li><li>The only scenario that this algorithm fails to find the overlap of two overlapping segments is when the query segment [𝑙𝑞,𝑟𝑞] contains the overlapping segment [𝑙,𝑟], [𝑙,𝑟] ⊂ [𝑙𝑞,𝑟𝑞]</li></ul></li></ol></li></ul></li><li><p>NODE-LEVEL PARALLELISM</p><p><img src=/image-20250212142040816.png alt=image-20250212142040816></p><ul><li><p>还是以net为单位分到不同的batch？</p></li><li><p>routing nodes of the same depth in parallel</p><p><img src=/image-20250212143816082.png alt=image-20250212143816082></p><p>Suppose we have 4 nets, Net A, B, C and D in our grid graph. Since nets with overlap cannot be routed together, Net A and B are distributed to batch 0, as shown in Figure 7a, and nets C and D are distributed to batch 1.</p><p><img src=/image-20250212143140834.png alt=image-20250212143140834></p></li></ul></li></ul><p><strong>experiment:</strong></p><ul><li><p>4 NVIDIA A800 GPUs and 8 CPU threads.</p></li><li><p>compare different overlap checking methods</p></li></ul><p><img src=/image-20250212145328644.png alt=image-20250212145328644></p><p>The number of nets per batch is limited to 1000</p><ul><li><p>compare 2 largest benchmark</p><p><img src=/image-20250212154458440.png alt=image-20250212154458440></p></li><li><p>compare with Top-3 Global Routers of ISPD2024 Contest</p><p><img src=/image-20250212161238221.png alt=image-20250212161238221></p></li><li><p>Runtime (s) of DAG-Based Augmented Routing with and without Node-Level Parallelism</p><p><img src=/image-20250212161314333.png alt=image-20250212161314333></p><p>acceleration 那一行好像是加速倍率才对</p></li></ul><h5 id=helem-gr-heterogeneouslinearized-exponential-multiplier-method-iccad-2024---pek><a href=/zh/>HeLEM-GR-Heterogeneous+Linearized Exponential Multiplier Method-ICCAD-2024- -PEK</a>
<a class=anchor href=#helem-gr-heterogeneouslinearized-exponential-multiplier-method-iccad-2024---pek>#</a></h5><ul><li>first place of ISPD25 contest</li><li>not open source 2025/2/6</li><li>2D routing algorithm</li></ul><p>background</p><h5 id=prnet---neurips-2022---sjtunoahs-ark><a href=/zh/>PRNet- -NeurIPS-2022- -SJTU+Noah’s Ark</a>
<a class=anchor href=#prnet---neurips-2022---sjtunoahs-ark>#</a></h5><ul><li>PRNet can generate each route in <code>one-shot</code> but <strong>cannot guarantee connectivity</strong> which requires considerable<code> post-processing</code> for failed routes</li><li>HubRouter 是两阶段框架，PRNet 是端到端框架。</li></ul><h5 id=hubrouter-generative-model-neurips-2023-ganrl-sjtu><a href=/zh/>HubRouter-generative model-NeurIPS-2023-GAN+RL-SJTU</a>
<a class=anchor href=#hubrouter-generative-model-neurips-2023-ganrl-sjtu>#</a></h5><ul><li><a href=https://github.com/Thinklab-SJTU/EDA-AI/tree/main/HubRouter>open source!</a></li><li><a href=https://picrew.github.io/2024/03/10/HubRouter/>a chinese interpretation</a></li><li>a global routing solver that includes a two-phase learning framework</li><li>HubRouter 是两阶段框架，PRNet 是端到端框架。</li><li>对比 PRNet 生成模型，PRNet 在 CGAN 中使用双向映射将连接约束注入训练目标，将准确率提高了 10%，但在复杂情况下几乎无效。</li></ul><p><strong>background</strong></p><p><img src=/image-20250210234157942.png alt=image-20250210234157942></p><ul><li><p>全局布线(Global Routing - GR)是 VLSI 设计中最复杂且最耗时的组合问题之一。GR 目标是总线长最小，同时避免拥塞(Congestion)，是个 NP 问题。</p><p>传统采用启发式算法，多样性和规模问题对传统算法有了挑战，机器学习(ML)已经用于全局布线，在芯片设计中从逻辑合成到布局</p></li><li><p>深度强化学习(Deep Reinforcement Learning - DRL )和生成式模型(Generative model)已经被用来解决全局布线。问题在于，<strong>DRL很受状态空间(State Space)影响，随着网格空间增大，需要花费大量时间生成</strong>。However, DRL methods suffer from large state space and often need to spend enormous time on generating routes as the scale of grids increases on the test instance, i.e., the netlist, which is practically intimidating for real-world global routing</p></li><li><p>相反，生成式模型有<strong>一次性生成能力</strong>，在计算上更容易处理。</p></li><li><p>生成式方法在训练时候考虑连通性限制，确保布线满足电路连通性要求。但是问题在于，如果初始生成路径不满足连通性要求时候，后处理阶段会变成一种穷举搜索过程。</p></li><li><p><img src=/image-20250210231714841.png alt=image-20250210231714841></p></li><li><p>图一这里上图表示原始布线，下图表示算法生成的布线，生成布线没有正确连接所有应该连接的点(pin)，对于这样的情况，平均连通率很低，低于20%，意味着超过80%的生成布线需要经过耗时的后处理才能达到要求。显著的缺点。其实就和[CNN-based](#
<a href="https://ieeexplore-ieee-org-443.webvpn.scut.edu.cn/stamp/stamp.jsp?tp=&amp;arnumber=9218598">-only CNN-DAC-2020-CNN(VAE)-</a>)这篇一样</p></li><li><p><img src=/image-20250210233812834.png alt=image-20250210233812834></p></li></ul><p><strong>contribution:</strong></p><ul><li><p>为了解决上述问题，定义了一个新的概念，叫<code>hub</code>。将pin - pin问题 &ndash;> hub - pin问题 。</p></li><li><p>提出了一种新的两阶段全局布线方法 &ndash;> HubRouter</p></li><li><p>generation phase（生成阶段）</p><p><code>hubs</code>, <code>routes</code>, and <code>stripe masks</code> are together generated under a multi-task framework by generative models</p><p>可以在多个框架下生成，比如 GAN (Generative Adversarial Nets) , VAE (Variational Auto-Encoder) , DPM (Diffusion Probabilistic Models) 。虽然hub是生成阶段的主要输出，但为了提升生成质量和准确性，发现生成附加信息是非常有用的。比如感知和掩码(<code>local perception</code> and <code>stripe masks</code>)，能够去除噪声点。引入<code>多任务学习</code>，布线和掩码一起生成，提高 hub 生成质量</p></li><li><p>pin-hub-connection phase（hub和pin连接阶段）</p><p>将连接视为<code>最小斯坦纳树(RSMT)</code>问题，使用 <code>actor-critic </code>模型网络策略。</p><p>is hub generate correcttly, reconstruction time complexity can be reduced to <strong>O(n log n)</strong></p></li><li><p>SOTA generative global routing models</p></li></ul><p><strong>model:</strong></p><p><img src=/image-20250210234537382.png alt=image-20250210234537382></p><ul><li><p>Hub</p><p><img src=/image-20250212194312475.png alt=image-20250212194312475></p><ul><li>(virtual) key point in the route</li><li>transferring the pin-pin connection problem to the hub-pin connection problem</li><li>斯坦纳点(Rectilinear Steiner Point &ndash;> RSP)是搜索全局最小总距离，但是 hub 是来确定路径。RSPs are special cases of hubs</li><li>RSP是Hub的特例，Hub可以随意生成不同形状的路径(不仅是最短的)</li><li>这里的 <code>c</code> 和 <code>x</code> 分别代表条件图像和输入图像。条件图像可能包括引脚位置、已经提取的中心点以及条带掩模（stripe mask）。条带掩模是用来指示布线区域的一种方式，它可以帮助模型更好地理解哪些区域可以用于布线</li><li></li></ul></li></ul><p><strong>flow</strong></p><p><img src=/image-20250212201906601.png alt=image-20250212201906601></p><ul><li><p>hub生成阶段</p><ul><li><p>Hub 生成可以表示为图像到图像的<code>multi-task learning framework</code> 任务, address the impact of sensitive <strong>noise</strong> points with stripe <code>mask learning</code></p></li><li><p><code>附录 B </code>介绍了将 GAN，VAE，EAN 纳入到生成框架</p></li><li><p>在这个阶段，模型旨在逼近条件分布 <code>pθ(x|z, c)</code> 使其接近先验分布 <code>p(x|c)</code>。给定条件 <code>c</code> 和从先验分布 <code>pz(z)</code> 中采样得到的潜在变量 <code>z</code>（通常假设为<strong>高斯分布</strong>），模型会生成一些“中心点（hubs）”. 这里的 <code>c</code> 和 <code>x</code> 分别代表条件图像和输入图像。z is a latent variable from a prior distribution</p></li><li><p>The main objective of hub generation is to minimize the difference between probability distributions <code>p(x|c) </code>and <code>pθ(x|z, c)</code></p></li><li><p>a noise hub, especially the outermost one, can largely harm the wirelength of routing. Use <code>stripe mask</code> to focus on bad cases for hub generation</p><p><img src=/image-20250212202848907.png alt=image-20250212202848907></p></li></ul></li><li><p>hub和pin连接阶段</p><ul><li>模型连接第一阶段生成的<strong>中心点</strong>，以获得最终的布线路由。这个过程可以被视为构建矩形稳定最小生成树（Rectilinear Steiner Minimum Tree，RSMT）的一部分。为了完成布线，模型遵循了一个基于强化学习（Reinforcement Learning，RL）的算法 <code>REST</code>。</li><li>在两阶段的过程中，作者还提出了一个<code>多任务学习框架</code>来提高生成中心点的质量。特别是，提出了一种新颖的<code>条带掩模学习方法</code>，旨在减轻噪声点案例可能造成的负面影响。算法的具体细节在<code>附录 B </code>中给出。</li></ul></li></ul><h4 id=detail-router>detail router
<a class=anchor href=#detail-router>#</a></h4><p><a href=/zh/>DRCU</a></p><p>academic detailed</p><h1 id=综述>综述
<a class=anchor href=#%e7%bb%bc%e8%bf%b0>#</a></h1><h2 id=ml4pr>ML4PR
<a class=anchor href=#ml4pr>#</a></h2><p><a href=https://blog.csdn.net/SP_FA/article/details/134063224>Towards Machine Learning for Placement and Routing in Chip Design: a Methodological Overview</a></p><p><img src=/image-20241101173512416.png alt=image-20241101173512416></p><p>放置和布线是两个不可或缺且具有挑战性的 NP-hard 问题</p><p>机器学习凭借其数据驱动的性质显示出了广阔的前景，它可以减少对知识和先验的依赖，并且通过其先进的计算范式具有更大的可扩展性 (例如 GPU 加速的深度网络)</p><p><strong>挑战:</strong></p><p>placement:</p><ul><li>在路由完成之前，无法评估诸如可达性之类的放置目标；因此，在优化循环中可能需要花费数小时才能获得反馈，这对于进行数千次查询来说是负担不起的</li><li>现代的放置器需要在几个小时内处理数万个宏和数百万个标准单元。这种可扩展性的要求仍然超出了现有 ML 方法的能力</li></ul><p>routing:</p><ul><li>在公平的比较下，现有技术很难在效率和求解质量上系统地优于经典布线算法</li><li>大多数基于学习的技术在具有数千个网络的小型电路上工作得很好，而实际的布线引擎需要在超大型 3D 网格图 ( > 1000 × 1000 × 10 ) (> 1000 × 1000 × 10)(>1000×1000×10) 上有效地处理数百万个网络并产生高质量的解决方案</li></ul><p>相关工作</p><ul><li><p>placement</p><ul><li><img src=/image-20241101175552665.png alt=image-20241101175552665></li><li><img src=/image-20241101175600184.png alt=image-20241101175600184></li><li><img src=/image-20241101175612168.png alt=image-20241101175612168></li></ul></li><li><p>Routing</p><ul><li><p><img src=/image-20241101175915691.png alt=image-20241101175915691></p><p><img src=/image-20241101175922593.png alt=image-20241101175922593></p><p><img src=/image-20241101175934137.png alt=image-20241101175934137></p></li><li><p><img src=/image-20241101180007732.png alt=image-20241101180007732></p></li><li><p><img src=/image-20241101180029509.png alt=image-20241101180029509></p></li></ul></li></ul><h2 id=超大规模集成电路布线算法综述>超大规模集成电路布线算法综述
<a class=anchor href=#%e8%b6%85%e5%a4%a7%e8%a7%84%e6%a8%a1%e9%9b%86%e6%88%90%e7%94%b5%e8%b7%af%e5%b8%83%e7%ba%bf%e7%ae%97%e6%b3%95%e7%bb%bc%e8%bf%b0>#</a></h2><p><a href=https://www.sciengine.com/MNEIM/doi/10.19816/j.cnki.10-1594/TN.2021.02.086>超大规模集成电路布线算法综述</a></p><p><strong>background</strong></p><p><img src=/image-20241116095906162.png alt=image-20241116095906162></p><p><img src=/image-20241116095924293.png alt=image-20241116095924293></p><p><img src=/image-20241116095932126.png alt=image-20241116095932126></p><p>布线相关详细看routing2.md, 详细布线、面向可制造性设计的布线算法 还没记录</p><h2 id=edagnn>EDA+GNN
<a class=anchor href=#edagnn>#</a></h2><p>详细看
<a href=.%5cnotebak%5cEDA+GNN.md>A Comprehensive Survey on Electronic Design Automation and Graph Neural Networks</a></p><h1 id=参考>参考
<a class=anchor href=#%e5%8f%82%e8%80%83>#</a></h1><ol><li>[AI技术带给EDA的机遇和挑战](AI技术带给EDA的机遇和挑战-Yibo Lin.pdf)</li><li>[Towards Machine Learning for Placement and Routing in Chip Design: a Methodological Overview]([
<a href=https://blog.csdn.net/SP_FA/article/details/134063224>读论文] Towards Machine Learning for Placement and Routing in Chip Design: a Methodological Overview_toward machine learning&mldr;.lake-CSDN博客</a>)</li><li><a href=https://blog.csdn.net/sxf1061700625/article/details/127865492>【阅读】A Comprehensive Survey on Electronic Design Automation and Graph Neural Networks——EDA+GNN综述翻译_ppaml-CSDN博客</a></li></ol><h1 id=bak>bak
<a class=anchor href=#bak>#</a></h1><p><a href=/zh/>CongestionNet-Congestion Prediction-IFIP-2019-GNN</a></p><p><a href=/zh/>-placement Congestion prediction-arXiv-2021-GNN</a></p><p><img src=/image-20241101171055570.png alt=image-20241101171055570></p><p>输入：网表</p><p>输出：congestion at placement stage</p><p><a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=10528675">EDA-ML: Graph Representation LearningFramework for Digital IC Design Automation</a></p><p>德雷塞尔大学电气与计算机工程系 Pratik Shrestha和Ioannis Savidis</p><p><strong>background</strong></p><p>VLSI : traditional methodologies -> ML,Graph representation learning ability to capture complex relationships in graph-structured data</p><p>GNN：</p><p><img src=/image-20241116142013379.png alt=image-20241116142013379></p><p><img src=/image-20241116142052562.png alt=image-20241116142052562></p><p><strong>task</strong></p><p><img src=/image-20241116143449696.png alt=image-20241116143449696></p><p><strong>flow</strong></p><p><img src=/image-20241116144708326.png alt=image-20241116144708326></p><p><strong>data</strong></p><p><img src=/image-20241116155309167.png alt=image-20241116155309167></p><p><img src=/image-20241116143927933.png alt=image-20241116143927933></p><p><img src=/image-20241116155354597.png alt=image-20241116155354597></p><p><strong>模型</strong></p><p><img src=/image-20241116155947525.png alt=image-20241116155947525></p><p><img src=/image-20241116155857412.png alt=image-20241116155857412></p><p><strong>实验</strong></p><p><img src=/image-20241116160529100.png alt=image-20241116160529100></p><h1 id=相关数据集>相关数据集
<a class=anchor href=#%e7%9b%b8%e5%85%b3%e6%95%b0%e6%8d%ae%e9%9b%86>#</a></h1><h2 id=only-rtl>only rtl
<a class=anchor href=#only-rtl>#</a></h2><h3 id=home--opencores><a href=https://opencores.org/>Home :: OpenCores</a>
<a class=anchor href=#home--opencores>#</a></h3><p><img src=/image-20241116140649477.png alt=image-20241116140649477></p><h3 id=iwls-2005-benchmarks><a href=https://iwls.org/iwls2005/benchmarks.html>IWLS 2005 Benchmarks</a>
<a class=anchor href=#iwls-2005-benchmarks>#</a></h3><p><img src=/image-20241116140821429.png alt=image-20241116140821429></p><p><img src=/image-20241116140834409.png alt=image-20241116140834409></p><h3 id=openlane-examples-examples-from-the-openlane-repository><a href=https://github.com/klasnordmark/openlane-examples>openlane-examples: Examples from the Openlane repository</a>
<a class=anchor href=#openlane-examples-examples-from-the-openlane-repository>#</a></h3><p><img src=/image-20241118160109426.png alt=image-20241118160109426></p><h2 id=global-route>Global route
<a class=anchor href=#global-route>#</a></h2><h3 id=ispd-2007>ISPD-2007
<a class=anchor href=#ispd-2007>#</a></h3><p><img src=/image-20250209155834613.png alt=image-20250209155834613></p><ul><li>the first published multilayer global routing benchmarks and the sizes of these benchmarks are large enough as compared to real industry cases</li><li>has a two-layer and a six-layer version.</li><li></li></ul><h3 id=ispd-2008>ISPD-2008
<a class=anchor href=#ispd-2008>#</a></h3><h3 id=iccad-2019>ICCAD-2019
<a class=anchor href=#iccad-2019>#</a></h3><p><a href=https://www.iccad-contest.org/2019/problems.html>2019 CAD Contest @ ICCAD</a></p><p><img src=/image-20241116171011534.png alt=image-20241116171011534></p><p><img src=/image-20241116170739017.png alt=image-20241116170739017></p><p><img src=/image-20241116170857585.png alt=image-20241116170857585></p><p><img src=/image-20241116171107825.png alt=image-20241116171107825></p><h3 id=ispd-2024>ISPD-2024
<a class=anchor href=#ispd-2024>#</a></h3><p>Dockerfile无法创建镜像了，401，Github也找不到benchmarks</p><p><img src=/image-20241116211927308.png alt=image-20241116211927308></p><h3 id=ispd-2025>ISPD-2025
<a class=anchor href=#ispd-2025>#</a></h3><h2 id=detail-route>Detail Route
<a class=anchor href=#detail-route>#</a></h2><h3 id=ispd-20182019>ISPD-2018/2019
<a class=anchor href=#ispd-20182019>#</a></h3><p><a href=https://www.ispd.cc/contests/18/>Initial Detailed Routing Contest at ISPD 2018</a></p><p><a href=https://ispd.cc/contests/19/#finalfiles>Initial Detailed Routing Contest at ISPD 2019</a></p><p><a href=https://github.com/nithyashreesenguttuvan/Handling-the-ISPD19-benchmark-dataset>一个别人写的parse脚本：Handling-the-ISPD19-benchmark-dataset</a></p><p><a href=https://ispd.cc/contests/19/ispd19eval.tgz>https://ispd.cc/contests/19/ispd19eval.tgz</a>：一个结果验证工具</p><p><img src=/image-20241116172911319.png alt=image-20241116172911319></p><p><img src=/image-20241116173011828.png alt=image-20241116173011828></p><p>还可以看看被人的结果</p><p><img src=/image-20241116173156258.png alt=image-20241116173156258></p><h2 id=congestiondrcir-droptiming>congestion/DRC/IR drop/timing
<a class=anchor href=#congestiondrcir-droptiming>#</a></h2><p><a href=https://github.com/circuitnet/CircuitNet>circuitnet/CircuitNet: CircuitNet: An Open-Source Dataset for Machine Learning Applications in Electronic Design Automation (EDA)</a></p><p>背景：</p><ul><li><a href=https://f.daixianiu.cn/csdn/14209355328255857.html>f.daixianiu.cn/csdn/14209355328255857.html</a>在研究过程中，我们发现AI+EDA的研究常常受限于公开数据集，不像计算机视觉领域有ImageNet这样的大数据集可以很方便地验证算法。针对这一问题，我们近期跟黄如院士、王润声教授等合作，发布了首个致力于芯片设计AI for EDA应用的开源数据集——CircuitNet，包含1万以上的数据样本，涵盖从实际制造工艺PDK下数字设计流程不同阶段中提取到的各类特征。</li></ul><p><img src=/image-20241119154735598.png alt=image-20241119154735598></p><p><img src=/image-20241116141127587.png alt=image-20241116141127587></p><p><a href=https://github.com/TimingPredict/TimingPredict>TimingPredict/TimingPredict: Official open source repository for &ldquo;A Timing Engine Inspired Graph Neural Network Model for Pre-Routing Slack Prediction&rdquo; (DAC 2022)</a></p><p><img src=/image-20241116141000835.png alt=image-20241116141000835></p><h1 id=相关会议期刊>相关会议/期刊
<a class=anchor href=#%e7%9b%b8%e5%85%b3%e4%bc%9a%e8%ae%ae%e6%9c%9f%e5%88%8a>#</a></h1><h2 id=会议>会议
<a class=anchor href=#%e4%bc%9a%e8%ae%ae>#</a></h2><p><a href=http://www.dac.com/>DAC</a>:</p><ul><li>每年举办一次学术论坛和工业贸易展览</li><li>一般11月截止</li></ul><p><a href=http://www.iccad.com/>ICCAD</a>：</p><ul><li>International Conference on Computer-Aided Design</li><li>由电气电子工程师学会（IEEE）和美国计算机学会（ACM）共同举办的国际计算机辅助设计会议（ICCAD）被公认为EDA领域最重要的会议之一，享有很高的国际学术地位和广泛的影响力。该会议是探索EDA研究领域新挑战、展示前沿创新解决方案和识别新兴技术的重要论坛，涵盖了从器件和电路级到系统级的所有设计与自动化主题、以及后CMOS设计等新型方向。着重于学术研究，论文涉及专门的算法的研究进展。</li><li>一般4月截止</li></ul><p><a href=https://www.date-conference.com/>DATE 2025</a></p><ul><li>Design, Automation and Test in Europe Conference</li><li>欧洲设计自动化和测试会议</li><li>一般9月截止</li></ul><p><a href=https://www.aspdac.com/aspdac/>ASP-DAC</a></p><ul><li>亚洲、南太平洋设计自动化会议</li><li>一般7月截止</li></ul><p><a href=https://ispd.cc>ISPD</a>：</p><ul><li><p>International Symposium on Physical Design</p></li><li><p>国际<strong>物理设计</strong>会议。是专注集成电路<strong>物理设计</strong>的国际研讨会，主题涵盖从ASIC和FPGA的传统物理设计到新兴半导体技术的物理设计<strong>自动化方法</strong>。</p></li><li><p>CCF-C. 9月份左右</p></li><li><p>每年ISPD会议同步举办国际物理设计竞赛，通常由国际知名芯片企业命题和组织，竞赛历时3个多月，结果在ISPD会议上揭晓。</p></li></ul><p><a href=https://www.glsvlsi.org/>GLSVLSI</a></p><ul><li>CCF-C</li><li>大湖区超大规模集成电路设计国际会议</li><li>一般2月截止</li><li>25年为第35届</li></ul><p><img src=/image-20250209205712219.png alt=image-20250209205712219></p><p><a href=https://www.vlsisymposium.org/>VLSI</a>:</p><ul><li>有个DTCO?</li><li>一般1月</li></ul><p><img src=/image-20250209213619851.png alt=image-20250209213619851></p><p><a href=https://www.eda2.com/iseda/index.html>ISEDA</a>:</p><ul><li>由IEEE和ACM主办，EDA²和CIE EDA委员会联合主办的ISEDA （EDA国际研讨会）是一个致力于VLSI设计自动化的年度顶级论坛。研讨会旨在探索新的挑战，展示前沿技术，并为EDA社区提供预测EDA研究领域未来发展方向的机会。ISEDA涵盖了从器件和电路级到系统级的所有EDA主题，从模拟到数字设计以及制造。会议的形式旨在培养富有成效和新颖</li><li>二月</li><li>25年第三届</li><li><img src=/image-20241210024033587.png alt=image-20241210024033587></li></ul><p><img src=/image-20241210023830404.png alt=image-20241210023830404></p><ul><li>NeurIPS</li><li>ICML</li></ul><h2 id=期刊>期刊
<a class=anchor href=#%e6%9c%9f%e5%88%8a>#</a></h2><p><a href=https://ieeexplore.ieee.org/document/10186100>TCAD</a></p><ul><li>由美国电器电子工程师学会（IEEE）出版(就是Trans?)</li></ul><p><a href=https://dl.acm.org/journal/todaes>TODAES</a></p><ul><li>由美国计算机学会（ACM）出版的电子系统设计自动化汇刊</li><li>It publishes innovative work documenting significant research and development advances on the specification, design, analysis, simulation, testing, and evaluation of electronic systems, emphasizing a computer science/engineering orientation. Design automation for machine learning/AI and machine learning/AI for design automation are very much welcomed. For topics of interest please see
<a href=https://dl.acm.org/journal/todaes/about>https://dl.acm.org/journal/todaes/about</a>.</li></ul><h2 id=参考-1>参考
<a class=anchor href=#%e5%8f%82%e8%80%83-1>#</a></h2><ul><li><a href="https://www.zhihu.com/question/559252881/answer/2849452833?utm_campaign=shareopn&amp;utm_medium=social&amp;utm_psn=1875695916662534144&amp;utm_source=wechat_session">(99+ 封私信 / 81 条消息) 集成电路设计的学术会议含金量排名如何？ - 知乎</a></li><li></li></ul><h1 id=相关科研实验室>相关科研实验室
<a class=anchor href=#%e7%9b%b8%e5%85%b3%e7%a7%91%e7%a0%94%e5%ae%9e%e9%aa%8c%e5%ae%a4>#</a></h1><h2 id=清华>清华
<a class=anchor href=#%e6%b8%85%e5%8d%8e>#</a></h2><p>清华大学是国内较早从事EDA研究的高校，<strong>洪先龙教授</strong>和<strong>边计年教授</strong>做<code>物理实现</code>和<code>逻辑综合</code>，两位老先生的学生大部分去了三大EDA公司</p><h2 id=北大-无锡eda研究院>北大-无锡EDA研究院
<a class=anchor href=#%e5%8c%97%e5%a4%a7-%e6%97%a0%e9%94%a1eda%e7%a0%94%e7%a9%b6%e9%99%a2>#</a></h2><p><a href=http://pkueda.org.cn/index.htm>无锡北京大学电子设计自动化研究院</a></p><p><a href=http://pkueda.org.cn/xgzy/dwfw/open.htm>北京大学无锡电子设计自动化研究院-开源工具整合</a></p><p><img src=/image-20250105135331192.png alt=image-20250105135331192></p><p>北京大学集成电路学院成立了国内唯一聚焦EDA技术的“设计自动化与计算系统系”，打造先进的教学与人才培养体系，并与国内外领先的企业深入合作，部分成果已经成功得到转化应用，相关技术是业内目前唯一的解决方案；近期依托院系新成立了<code>无锡北京大学EDA研究院</code>，加上此前与EDA及设计方向头部企业共建的多个联合实验室，形成了教育、科技和人才三位一体的布局。</p><p>研究方向包括<code>布局布线</code>、<code>FPGA设计自动化的可重构算法</code></p><p>林亦波
<a href=https://yibolin.com/>Yibo Lin</a>:yibolin@pku.edu.cn</p><ul><li><p><code>Contest@ISPD 2024第一名</code>指导的本科生赵春源提出的高效<code>GPU异构并行布线算法</code></p></li><li><p><code>CADathlon@ICCAD 2024第一名</code>指导<strong>郭资政（毕设开源项目作者）、麦景</strong>。在9小时内，运用自己的编码和分析技巧来解决6道集成电路与系统中电子设计自动化问题</p></li><li><p><code>CAD Contest@ICCAD第一名</code>指导<strong>杜宇凡、郭资政</strong>。C赛题《Scalable Logic Gate Sizing Using ML Techniques and GPU Acceleration》</p></li><li><p><code>DreamPlace</code>, <code>Limbo</code>开源项目作者</p></li><li><p>相关采访
<a href=https://blog.csdn.net/BAAIBeijing/article/details/126944929>北大林亦波：探索AI+EDA新路径 | 青源专栏 2022-09</a></p></li><li><p><img src=/image-20250105141555651.png alt=image-20250105141555651></p></li><li><p>一个现象：</p><p><img src=/image-20250207165145656.png alt=image-20250207165145656></p></li></ul><p><img src=/ec7d7183c0dd379cccae82cd8354620.jpg alt=ec7d7183c0dd379cccae82cd8354620></p><h2 id=复旦>复旦
<a class=anchor href=#%e5%a4%8d%e6%97%a6>#</a></h2><p>集成芯片与系统国家重点实验室</p><p>研究方向包括<code>物理实现</code>、<code>参数提取</code>、<code>逻辑综合</code>、<code>可制造性设计</code>等方向</p><p>陈建利教授</p><ul><li>指导蔡志杰、魏民、邹鹏，ISPD 2024 contest 第三名</li></ul><h2 id=北航>北航
<a class=anchor href=#%e5%8c%97%e8%88%aa>#</a></h2><p><img src=/image-20241116114923595.png alt=image-20241116114923595></p><h2 id=港中文-eda-center>港中文-EDA Center
<a class=anchor href=#%e6%b8%af%e4%b8%ad%e6%96%87-eda-center>#</a></h2><p><a href=https://cueda-center.github.io/index.html>CUHK EDA Center官网</a></p><p><a href=https://github.com/cuhk-eda>CUHK EDA Github</a></p><p><a href=https://www.cse.cuhk.edu.hk/~byu/>Bei Yu(余备)@CUHK-CSE</a></p><ul><li><p><a href=mailto:byu@cse.cuhk.edu.hk>byu@cse.cuhk.edu.hk</a></p></li><li><p><a href=https://www.cse.cuhk.edu.hk/~byu/topics.html>Research Topics</a></p></li><li><p><code>CAD Contest@ICCAD 2012</code>第二名获得者</p></li><li><p><a href=https://lusica1031.github.io/>Siting Liu(刘思婷)@CUHK-CSE</a></p></li><li><p><a href=mailto:lusicaliu@outlook.com>lusicaliu@outlook.com</a></p></li></ul><p><a href=https://www.cse.cuhk.edu.hk/~fyyoung/>F.Y. Young</a></p><p><img src=/image-20250209204835789.png alt=image-20250209204835789></p><ul><li>Jinwei Liu</li></ul><p><a href=https://sse.cuhk.edu.cn/en/faculty/chentinghuan>陈廷欢CHEN, Tinghuan</a></p><ul><li>方向：VLSI CAD and deep learning accelerators for edge devices</li><li><a href=mailto:chentinghuan@cuhk.edu.cn>chentinghuan@cuhk.edu.cn</a></li></ul><h2 id=chen-tinghuan>CHEN, Tinghuan
<a class=anchor href=#chen-tinghuan>#</a></h2><h2 id=福大>福大
<a class=anchor href=#%e7%a6%8f%e5%a4%a7>#</a></h2><p>福州大学早期EDA研究始于<strong>范更华教授</strong>和<strong>朱文兴教授</strong>，当前的研究方向主要是<strong>物理实现</strong>。福州大学团队曾连续三年在<code>CAD Contest@ICCAD</code>夺冠。</p><p><code>福州大学团队</code>在<code>CAD Contest@ICCAD</code>大赛中提出的<code>6T&amp;6T PPNN单元布局方法</code>已转让给<code>华大九天</code></p><p>林智锋教授</p><ul><li>指导陈忆鹭、吴昭怡， ISPD 2024 contest 第三名</li></ul><h2 id=上海交大>上海交大
<a class=anchor href=#%e4%b8%8a%e6%b5%b7%e4%ba%a4%e5%a4%a7>#</a></h2><p><a href=https://www.shlab.org.cn/>首页_上海人工智能实验室</a></p><h2 id=东南大学-国家asic工程中心>东南大学-国家ASIC工程中心
<a class=anchor href=#%e4%b8%9c%e5%8d%97%e5%a4%a7%e5%ad%a6-%e5%9b%bd%e5%ae%b6asic%e5%b7%a5%e7%a8%8b%e4%b8%ad%e5%bf%83>#</a></h2><p>研究方向是<code>亚阈值和近阈值相关的时序分析</code></p><p><code>CAD Contest@ICCAD 2017第一名</code>获奖者福州大学的<strong>朱自然</strong>（Ziran Zhu）毕业后任教于<code>东南大学ASIC</code>中心</p><p>2020年和<strong>国微集团</strong>成立<strong>EDA联合实验室</strong>，瞄准EDA共性技术研发</p><p><a href=https://ic.seu.edu.cn/shilongxing/main.psp>时龙兴</a>:</p><ul><li>老所长</li></ul><p><a href=https://ic.seu.edu.cn/yanhao/main.psp>闫浩</a>:</p><ul><li><a href=mailto:yanhao@seu.edu.cn>yanhao@seu.edu.cn</a></li><li>领域：智能EDA，面向先进工艺、高能效电路设计中存在的问题，应用人工智能算法辅助电路设计；先进制程/低电压下的<strong>时序</strong>分析与优化</li></ul><h2 id=华中科技大学>华中科技大学
<a class=anchor href=#%e5%8d%8e%e4%b8%ad%e7%a7%91%e6%8a%80%e5%a4%a7%e5%ad%a6>#</a></h2><h2 id=西安电子科技大学>西安电子科技大学
<a class=anchor href=#%e8%a5%bf%e5%ae%89%e7%94%b5%e5%ad%90%e7%a7%91%e6%8a%80%e5%a4%a7%e5%ad%a6>#</a></h2><p>在国内较早开始从事成品率分析算法的研究，并且一直在宽禁带半导体的器件建模、可靠性分析等领域有深入的研究和突出的成果</p><p>在2019年和<strong>囯微集团</strong>建立<strong>EDA研究院</strong>之后，开始进入<code>布局布线</code>和<code>原型验证</code>领域</p><h2 id=广东工业大学>广东工业大学
<a class=anchor href=#%e5%b9%bf%e4%b8%9c%e5%b7%a5%e4%b8%9a%e5%a4%a7%e5%ad%a6>#</a></h2><p><a href=https://sme.gdut.edu.cn/info/1163/1478.htm>电子设计自动化（EDA）科研团队-广东工业大学集成电路学院</a></p><p>电子设计自动化（EDA）科研团队依托广东工业大学集成电路学院成立。面向人工智能辅助集成电路设计EDA工具开发、应用等国家重大战略与行业重大需求，以人工智能辅助EDA为研究核心，聚焦于数字集成电路设计后端工具、FPGA设计工具优化等领域的前沿基础理论和关键技术研究。团队主要开展“数据驱动机器学习的集成电路智能设计”、“人工智能方法实现集成电路的敏捷设计”、“基于传统的分析和优化技术的集成电路辅助设计”等研究</p><p><img src=/image-20241214171155300.png alt=image-20241214171155300></p><ol><li>数据驱动机器学习的集成电路智能设计</li><li>人工智能方法实现集成电路的敏捷设计</li><li>基于传统的分析和优化技术的集成电路辅助设计</li></ol><p><img src=/image-20241214171245832.png alt=image-20241214171245832></p><h2 id=国立清华大学>国立清华大学
<a class=anchor href=#%e5%9b%bd%e7%ab%8b%e6%b8%85%e5%8d%8e%e5%a4%a7%e5%ad%a6>#</a></h2><h2 id=university-of-california>University of California
<a class=anchor href=#university-of-california>#</a></h2><p><a href=http://eda.ee.ucla.edu/>Design Automation Laboratory</a></p><h1 id=相关企业机构>相关企业/机构
<a class=anchor href=#%e7%9b%b8%e5%85%b3%e4%bc%81%e4%b8%9a%e6%9c%ba%e6%9e%84>#</a></h1><h2 id=华为诺亚方舟--海思>华为诺亚方舟 & 海思
<a class=anchor href=#%e5%8d%8e%e4%b8%ba%e8%af%ba%e4%ba%9a%e6%96%b9%e8%88%9f--%e6%b5%b7%e6%80%9d>#</a></h2><p>Huawei Noah’s Ark Lab
<a href=https://noahai4eda.github.io/>AI4EDA</a></p><p><code>CAD Contest@ICCAD 2018第一名</code>获奖者<code>香港中文大学</code>的<strong>陈劲松</strong>（Jingsong Chen，2021年博士毕业）毕业后加入<code>华为</code></p><h2 id=eda国创中心>EDA国创中心
<a class=anchor href=#eda%e5%9b%bd%e5%88%9b%e4%b8%ad%e5%bf%83>#</a></h2><p>与东南大学
<a href=https://ic.seu.edu.cn/2024/0509/c47774a489994/page.htm>有关联</a></p><p><a href=https://www.nctieda.com/AboutUs.html>中心介绍—国家集成电路设计自动化技术创新中心，EDA国创中心【官方网站】</a></p><p><img src=/image-20241211184948328.png alt=image-20241211184948328></p><p><img src=/image-20241214171422358.png alt=image-20241214171422358></p><h2 id=芯行纪><a href=https://www.xtimes-da.com/>芯行纪</a>
<a class=anchor href=#%e8%8a%af%e8%a1%8c%e7%ba%aa>#</a></h2><p><img src=/image-20241214160736661.png alt=image-20241214160736661></p><h3 id=amazesys>AmazeSys
<a class=anchor href=#amazesys>#</a></h3><p>应用于数字芯片物理设计领域的<strong>布局布线</strong>工具</p><p>包含宏单元布局规划、电源规划、布局、时钟树综合、布线、优化、寄生参数提取以及时序功耗分析等全功能模块，支持先进工艺制程下的超大规模设计，可完成数字芯片从<strong>Netlist到GDS</strong>的完整设计流程，快速达成性能、功耗、面积优化等设计目标</p><p>基于强大的<strong>机器学习引擎内核</strong>，AmazeSys具备自适应超高质量优化能力。该引擎智能提取设计本身特点进行样本训练，综合性能、功耗、面积和布线拥塞等多项关键指标，快速获取量身定制的最佳优化方案，可有效帮助用户降低调整大量工具设置的时间成本。</p><h3 id=amazefp>AmazeFP
<a class=anchor href=#amazefp>#</a></h3><p>智能布局规划工具<strong>AmazeFP</strong>将<strong>机器学习</strong>技术与<strong>布局规划</strong>引警结合，在兼顾性能、功耗和面积(<strong>PPA</strong>)的同时，提供了高度智能的<strong>拥塞感知</strong>、便捷的数据流分析和<strong>宏单元自动整理对齐功能</strong>，有效解决当前数字芯片在后端设计阶段的布局规划节点面临的经验值需求高、手工耗时长、数据流结构分析不够深入、设计目标收敛性差等难题，助力用户在后端设计初期快速有效地获取高质量布局规划方案，减少迭代次数，从而节约大规模设计的研发成本，提速产品上市时间。</p><h3 id=amazefp-me>AmazeFP-ME
<a class=anchor href=#amazefp-me>#</a></h3><p>作为一款EDA机器学习的工具，AmazeFP-ME在AmazeFP的基础上，能够快速探索数百倍甚至更多的庞大解空间，无需用户手动调参，同时配备优异且精准的数据、图形分析功能，可为用户提供高效便捷的设计体验</p><p>AmazeFP-ME作为AmazeFP的AI配套工具，将机器学习技术引入到AmazeFP的解空间探索中，不仅进一步显著地提升了PPA，还为用户创造全新的自动化使用体验。</p><h3 id=amazedrclite>AmazeDRCLite
<a class=anchor href=#amazedrclite>#</a></h3><p><img src=/image-20241214162304222.png alt=image-20241214162304222></p><h3 id=云>云
<a class=anchor href=#%e4%ba%91>#</a></h3><h2 id=华大九天>华大九天
<a class=anchor href=#%e5%8d%8e%e5%a4%a7%e4%b9%9d%e5%a4%a9>#</a></h2><p>东南大学-华大九天-NiiCEDA联合实验室</p><h3 id=pyaether>PyAether
<a class=anchor href=#pyaether>#</a></h3><p>Aether就是全定制电路（例如模拟、存储、射频、平板等）设计平台，包括原理图，版图，仿真环境，以及数据版本管理工具和Python接口等。</p><p><strong>Python拥有众多针对****数据科学和人工智能的强大的开源库</strong>，例如NumPy和Pandas用于数据处理，Matplotlib用于数据可视化，Scikit-Learn提供了大量的预处理方法和机器学习算法，TensorFlow和PyTorch则是深度学习领域的重要工具。这些库大大降低了开发难度，使得Python在AI领域的地位无可替代。所以无论是数据清洗和预处理，还是模型建立，例如决策树，神经网络，贝叶斯优化等，以及模型训练和测试，对模型结果的解读等，<strong>都会</strong>天然的<strong>使用Python</strong>。</p><p>所以Python的开放性生态、天然的数据挖掘、包括机器学习的人工智能（AI）以及各类算法优化包，友好的web开发，使用户可以在更开放、更强大的生态体系里开展设计。可以用它来构建电路与版图的自动化任务，快速进行数据处理和分析。例如，PyAether可以赋能IC CAD，更好得响应IC 设计和版图各种要求。</p><ul><li><a href=https://bbs.eetop.cn/thread-977456-1-1.html>10月18日深度解析 PyAether EDA 生态系统，带您探索电路设计自动化的秘籍！ - 华大九天PyAether - EETOP 创芯网论坛 (原名：电子顶级开发网) -</a></li></ul><p><img src=/image-20250112113619108.png alt=image-20250112113619108></p><p><img src=/image-20250113112132020.png alt=image-20250113112132020></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> pyAether
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>InvLe</span>:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self, lib, cell, tech_lib, view<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;layout&#34;</span>, mode<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;a&#34;</span>):
</span></span><span style=display:flex><span>        <span style=color:#e6db74>r</span><span style=color:#e6db74>&#34;&#34;&#34;InvLe init function, receive the specified layout information.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        Parameters
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        ----------
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        lib : str
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            Library name.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        cell : str
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            Cell name.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        tech_lib : str
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            Attach tech library name.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        view : str
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            View name, the default value is &#39;layout&#39;.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        mode : str
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            Mode for open design, the default value is &#39;a&#39;.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>        pyAether<span style=color:#f92672>.</span>emyInitDb()
</span></span><span style=display:flex><span>        pyAether<span style=color:#f92672>.</span>emyInitLog()
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>pnt_x <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>pnt_y <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>namespace <span style=color:#f92672>=</span> pyAether<span style=color:#f92672>.</span>emyUnixNS()
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>design <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>open_design(lib, cell, view, mode<span style=color:#f92672>=</span>mode)
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>block <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>design<span style=color:#f92672>.</span>getTopBlock()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> self<span style=color:#f92672>.</span>block <span style=color:#f92672>is</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>block <span style=color:#f92672>=</span> pyAether<span style=color:#f92672>.</span>emyBlock<span style=color:#f92672>.</span>create(self<span style=color:#f92672>.</span>design)
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>uu2dbu <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>block<span style=color:#f92672>.</span>getDBUPerUU()
</span></span><span style=display:flex><span>        oplib <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>design<span style=color:#f92672>.</span>getLib()
</span></span><span style=display:flex><span>        tech_scl <span style=color:#f92672>=</span> pyAether<span style=color:#f92672>.</span>emyScalarName(self<span style=color:#f92672>.</span>namespace, tech_lib)
</span></span><span style=display:flex><span>        tech <span style=color:#f92672>=</span> pyAether<span style=color:#f92672>.</span>emyTech<span style=color:#f92672>.</span>open(tech_scl)
</span></span><span style=display:flex><span>        tech<span style=color:#f92672>.</span>attach(oplib, tech_scl)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>open_design</span>(self, lib, cell, view, view_type<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;maskLayout&#34;</span>, mode<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;r&#34;</span>):
</span></span><span style=display:flex><span>        <span style=color:#e6db74>r</span><span style=color:#e6db74>&#34;&#34;&#34;This function is used to open design and return an emyDesign object.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        Parameters
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        ----------
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        lib : str
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            Library name.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        cell : str
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            Cell name.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        view : str
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            View name.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        view_type : str
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            Type of view, the default value is &#39;layout&#39;.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        mode : str
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            Mode for open design, the default value is &#39;r&#39;.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        Returns
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        -------
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        design : emyDesign
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            An emyDesign object opened by given parameters.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>        lib_scl <span style=color:#f92672>=</span> pyAether<span style=color:#f92672>.</span>emyScalarName(self<span style=color:#f92672>.</span>namespace, lib)
</span></span><span style=display:flex><span>        cell_scl <span style=color:#f92672>=</span> pyAether<span style=color:#f92672>.</span>emyScalarName(self<span style=color:#f92672>.</span>namespace, cell)
</span></span><span style=display:flex><span>        view_scl <span style=color:#f92672>=</span> pyAether<span style=color:#f92672>.</span>emyScalarName(self<span style=color:#f92672>.</span>namespace, view)
</span></span><span style=display:flex><span>        reserved_view <span style=color:#f92672>=</span> pyAether<span style=color:#f92672>.</span>emyReservedViewType(view_type)
</span></span><span style=display:flex><span>        view_type <span style=color:#f92672>=</span> pyAether<span style=color:#f92672>.</span>emyViewType<span style=color:#f92672>.</span>get(reserved_view)
</span></span><span style=display:flex><span>        design <span style=color:#f92672>=</span> pyAether<span style=color:#f92672>.</span>emyDesign<span style=color:#f92672>.</span>open(lib_scl, cell_scl, view_scl,
</span></span><span style=display:flex><span>                                         view_type, mode)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> design
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>create_inst</span>(self, master_lib, master_cell, master_view, inst_name,
</span></span><span style=display:flex><span>                    point, params, <span style=color:#f92672>**</span>kwargs):
</span></span><span style=display:flex><span>        <span style=color:#e6db74>r</span><span style=color:#e6db74>&#34;&#34;&#34;This function creates an emyScalarInst object on specified block.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        Parameters
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        ----------
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        master_lib : str
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            Library name of instance.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        master_cell : str
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            Cell name of instance.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        master_view : str
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            View name of instance.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        inst_name : str
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            Text string of instance.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        point : tuple
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            Point to create an emyTransform object, such as (0, 0).
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        params: emyParamArray
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            emyParamArray
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        kwargs
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            Other keyword arguments,
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            here specifies view_type, mode, view, status.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>        view_type <span style=color:#f92672>=</span> kwargs<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#34;view_type&#34;</span>, <span style=color:#e6db74>&#34;maskLayout&#34;</span>)
</span></span><span style=display:flex><span>        mode <span style=color:#f92672>=</span> kwargs<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#34;mode&#34;</span>, <span style=color:#e6db74>&#34;r&#34;</span>)
</span></span><span style=display:flex><span>        view <span style=color:#f92672>=</span> kwargs<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#34;view&#34;</span>, pyAether<span style=color:#f92672>.</span>emcInheritFromTopBlock)
</span></span><span style=display:flex><span>        status <span style=color:#f92672>=</span> kwargs<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#34;status&#34;</span>, pyAether<span style=color:#f92672>.</span>emcNonePlacementStatus)
</span></span><span style=display:flex><span>        master <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>open_design(master_lib, master_cell, master_view,
</span></span><span style=display:flex><span>                                  view_type, mode)
</span></span><span style=display:flex><span>        inst_scl_name <span style=color:#f92672>=</span> pyAether<span style=color:#f92672>.</span>emyScalarName(self<span style=color:#f92672>.</span>namespace, inst_name)
</span></span><span style=display:flex><span>        pnt_x0, pnt_y0 <span style=color:#f92672>=</span> point
</span></span><span style=display:flex><span>        point_1 <span style=color:#f92672>=</span> pyAether<span style=color:#f92672>.</span>emyPoint(int(pnt_x0 <span style=color:#f92672>*</span> self<span style=color:#f92672>.</span>uu2dbu),
</span></span><span style=display:flex><span>                                    int(pnt_y0 <span style=color:#f92672>*</span> self<span style=color:#f92672>.</span>uu2dbu))
</span></span><span style=display:flex><span>        trans <span style=color:#f92672>=</span> pyAether<span style=color:#f92672>.</span>emyTransform(point_1)
</span></span><span style=display:flex><span>        pyAether<span style=color:#f92672>.</span>emyScalarInst<span style=color:#f92672>.</span>create(self<span style=color:#f92672>.</span>block, master, inst_scl_name, trans,
</span></span><span style=display:flex><span>                                      params, view, status)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>create_net</span>(self, net_name, path, <span style=color:#f92672>**</span>kwargs):
</span></span><span style=display:flex><span>        <span style=color:#e6db74>r</span><span style=color:#e6db74>&#34;&#34;&#34;This function creates an emyScalarNet object on specified block.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        Parameters
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        ----------
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        net_name : str
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            It specifies the net name string.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        path : list
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            It specifies path list.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        kwargs
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            Other keyword arguments,
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            here specifies sigType, isGlobal, view.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        Returns
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        -------
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        scl_net : emyScalarNet
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            An emyScalarNet object created by given parameters.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>        sig_type <span style=color:#f92672>=</span> kwargs<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#34;sigType&#34;</span>,
</span></span><span style=display:flex><span>                              pyAether<span style=color:#f92672>.</span>emySigType(pyAether<span style=color:#f92672>.</span>emcSignalSigType))
</span></span><span style=display:flex><span>        is_global <span style=color:#f92672>=</span> kwargs<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#34;isGlobal&#34;</span>, <span style=color:#66d9ef>False</span>)
</span></span><span style=display:flex><span>        view <span style=color:#f92672>=</span> kwargs<span style=color:#f92672>.</span>get(
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;view&#34;</span>,
</span></span><span style=display:flex><span>            pyAether<span style=color:#f92672>.</span>emyBlockDomainVisibility(pyAether<span style=color:#f92672>.</span>emcInheritFromTopBlock))
</span></span><span style=display:flex><span>        net <span style=color:#f92672>=</span> pyAether<span style=color:#f92672>.</span>emyScalarName(self<span style=color:#f92672>.</span>namespace, net_name)
</span></span><span style=display:flex><span>        scl_net <span style=color:#f92672>=</span> pyAether<span style=color:#f92672>.</span>emyScalarNet<span style=color:#f92672>.</span>create(self<span style=color:#f92672>.</span>block, net, sig_type,
</span></span><span style=display:flex><span>                                               is_global, view)
</span></span><span style=display:flex><span>        path<span style=color:#f92672>.</span>addToNet(scl_net)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> scl_net
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>create_path</span>(self, layer, purpose, width, start_point, end_point):
</span></span><span style=display:flex><span>        <span style=color:#e6db74>r</span><span style=color:#e6db74>&#34;&#34;&#34;This function creates an emyScalarNet object on specified block.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        Parameters
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        ----------
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        layer : str
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            It specifies the layer name string.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        purpose : str
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            It specifies the purpose name string.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        width : float
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            Define the width of the path.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        start_point : tuple
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            Path start point, such as (0, 0).
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        end_point : tuple
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            Path end point, such as (1, 1).
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        Returns
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        -------
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        path : emyPath
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            A path object created by given parameters.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>        (sta_x0, sta_y0), (end_x0, end_y0) <span style=color:#f92672>=</span> start_point, end_point
</span></span><span style=display:flex><span>        sta_pnt <span style=color:#f92672>=</span> pyAether<span style=color:#f92672>.</span>emyPoint(
</span></span><span style=display:flex><span>            int(self<span style=color:#f92672>.</span>pnt_x <span style=color:#f92672>*</span> self<span style=color:#f92672>.</span>uu2dbu) <span style=color:#f92672>+</span> int(sta_x0 <span style=color:#f92672>*</span> self<span style=color:#f92672>.</span>uu2dbu),
</span></span><span style=display:flex><span>            int(self<span style=color:#f92672>.</span>pnt_y <span style=color:#f92672>*</span> self<span style=color:#f92672>.</span>uu2dbu) <span style=color:#f92672>+</span> int(sta_y0 <span style=color:#f92672>*</span> self<span style=color:#f92672>.</span>uu2dbu))
</span></span><span style=display:flex><span>        end_pnt <span style=color:#f92672>=</span> pyAether<span style=color:#f92672>.</span>emyPoint(
</span></span><span style=display:flex><span>            int(self<span style=color:#f92672>.</span>pnt_x <span style=color:#f92672>*</span> self<span style=color:#f92672>.</span>uu2dbu) <span style=color:#f92672>+</span> int(end_x0 <span style=color:#f92672>*</span> self<span style=color:#f92672>.</span>uu2dbu),
</span></span><span style=display:flex><span>            int(self<span style=color:#f92672>.</span>pnt_y <span style=color:#f92672>*</span> self<span style=color:#f92672>.</span>uu2dbu) <span style=color:#f92672>+</span> int(end_y0 <span style=color:#f92672>*</span> self<span style=color:#f92672>.</span>uu2dbu))
</span></span><span style=display:flex><span>        points <span style=color:#f92672>=</span> [sta_pnt, end_pnt]
</span></span><span style=display:flex><span>        layernum <span style=color:#f92672>=</span> pyAether<span style=color:#f92672>.</span>emyGetLayerNumByName(self<span style=color:#f92672>.</span>design, layer)
</span></span><span style=display:flex><span>        purposenum <span style=color:#f92672>=</span> pyAether<span style=color:#f92672>.</span>emyGetPurposeNumByName(self<span style=color:#f92672>.</span>design, purpose)
</span></span><span style=display:flex><span>        wid <span style=color:#f92672>=</span> int(width <span style=color:#f92672>*</span> self<span style=color:#f92672>.</span>uu2dbu)
</span></span><span style=display:flex><span>        path <span style=color:#f92672>=</span> pyAether<span style=color:#f92672>.</span>emyPath<span style=color:#f92672>.</span>create(self<span style=color:#f92672>.</span>block, layernum, purposenum, wid,
</span></span><span style=display:flex><span>                                       points)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> path
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>create_gr</span>(self, centerLine, templateName, <span style=color:#f92672>**</span>kwargs):
</span></span><span style=display:flex><span>        <span style=color:#e6db74>r</span><span style=color:#e6db74>&#34;&#34;&#34;This function creates an emyScalarNet object on specified block.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        Parameters
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        ----------
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        centerLine : emyPointArrayF
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            Set the drawing route of the guard ring.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        templateName : str
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            Set the template name of the guard ring.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        kwargs
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            Other keyword arguments,
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            here specifies type, justify, offset, topLayer, stackMode, maxContPattern,
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            isBodyMode, bodyWidth, contRow, contSpaceX, contSpaceY, contSizeX, contSizeY,
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            bIsChamfer, chamferAmount, metalSameBody, stackSameMetal, cornerContact.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        Returns
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        -------
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        rect_nwgr : emyRect
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            Build nwGuardRings.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        type <span style=color:#f92672>=</span> kwargs<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#34;type&#34;</span>, <span style=color:#e6db74>&#34;Polygon&#34;</span>)
</span></span><span style=display:flex><span>        justify <span style=color:#f92672>=</span> kwargs<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#34;justify&#34;</span>, <span style=color:#e6db74>&#34;Center&#34;</span>)
</span></span><span style=display:flex><span>        offset <span style=color:#f92672>=</span> kwargs<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#34;offset&#34;</span>, <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        topLayer <span style=color:#f92672>=</span> kwargs<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#34;topLayer&#34;</span>, <span style=color:#66d9ef>None</span>)
</span></span><span style=display:flex><span>        stackMode <span style=color:#f92672>=</span> kwargs<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#34;stackMode&#34;</span>, <span style=color:#66d9ef>False</span>)
</span></span><span style=display:flex><span>        maxContPattern <span style=color:#f92672>=</span> kwargs<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#34;maxContPattern&#34;</span>, <span style=color:#66d9ef>False</span>)
</span></span><span style=display:flex><span>        isBodyMode <span style=color:#f92672>=</span> kwargs<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#34;isBodyMode&#34;</span>, <span style=color:#66d9ef>True</span>)
</span></span><span style=display:flex><span>        bodyWidth <span style=color:#f92672>=</span> kwargs<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#34;bodyWidth&#34;</span>, <span style=color:#ae81ff>0.5</span>)
</span></span><span style=display:flex><span>        contRow <span style=color:#f92672>=</span> kwargs<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#34;contRow&#34;</span>, <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        contSpaceX <span style=color:#f92672>=</span> kwargs<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#34;contSpaceX&#34;</span>, <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        contSpaceY <span style=color:#f92672>=</span> kwargs<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#34;contSpaceY&#34;</span>, <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        contSizeX <span style=color:#f92672>=</span> kwargs<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#34;contSizeX&#34;</span>, <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        contSizeY <span style=color:#f92672>=</span> kwargs<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#34;contSizeY&#34;</span>, <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        bIsChamfer <span style=color:#f92672>=</span> kwargs<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#34;bIsChamfer&#34;</span>, <span style=color:#66d9ef>False</span>)
</span></span><span style=display:flex><span>        chamferAmount <span style=color:#f92672>=</span> kwargs<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#34;chamferAmount &#34;</span>, <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        metalSameBody <span style=color:#f92672>=</span> kwargs<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#34;metalSameBody&#34;</span>, <span style=color:#66d9ef>False</span>)
</span></span><span style=display:flex><span>        stackSameMetal <span style=color:#f92672>=</span> kwargs<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#34;stackSameMetal&#34;</span>, <span style=color:#66d9ef>False</span>)
</span></span><span style=display:flex><span>        cornerContact <span style=color:#f92672>=</span> kwargs<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#34;cornerContact&#34;</span>, <span style=color:#66d9ef>True</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        pyAether<span style=color:#f92672>.</span>aeCrtGuardring(self<span style=color:#f92672>.</span>design,
</span></span><span style=display:flex><span>                                centerLine,
</span></span><span style=display:flex><span>                                templateName,
</span></span><span style=display:flex><span>                                type<span style=color:#f92672>=</span>type,
</span></span><span style=display:flex><span>                                justify<span style=color:#f92672>=</span>justify,
</span></span><span style=display:flex><span>                                offset<span style=color:#f92672>=</span>offset,
</span></span><span style=display:flex><span>                                stackMode<span style=color:#f92672>=</span>stackMode,
</span></span><span style=display:flex><span>                                maxContPattern<span style=color:#f92672>=</span>maxContPattern,
</span></span><span style=display:flex><span>                                isBodyMode<span style=color:#f92672>=</span>isBodyMode,
</span></span><span style=display:flex><span>                                contRow<span style=color:#f92672>=</span>contRow,
</span></span><span style=display:flex><span>                                contSpaceX<span style=color:#f92672>=</span>contSpaceX,
</span></span><span style=display:flex><span>                                topLayer<span style=color:#f92672>=</span>topLayer,
</span></span><span style=display:flex><span>                                contSpaceY<span style=color:#f92672>=</span>contSpaceY,
</span></span><span style=display:flex><span>                                contSizeX<span style=color:#f92672>=</span>contSizeX,
</span></span><span style=display:flex><span>                                contSizeY<span style=color:#f92672>=</span>contSizeY,
</span></span><span style=display:flex><span>                                bIsChamfer<span style=color:#f92672>=</span>bIsChamfer,
</span></span><span style=display:flex><span>                                chamferAmount<span style=color:#f92672>=</span>chamferAmount,
</span></span><span style=display:flex><span>                                metalSameBody<span style=color:#f92672>=</span>metalSameBody,
</span></span><span style=display:flex><span>                                stackSameMetal<span style=color:#f92672>=</span>stackSameMetal,
</span></span><span style=display:flex><span>                                cornerContact<span style=color:#f92672>=</span>cornerContact,
</span></span><span style=display:flex><span>                                bodyWidth<span style=color:#f92672>=</span>bodyWidth)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>close</span>(self):
</span></span><span style=display:flex><span>        <span style=color:#e6db74>r</span><span style=color:#e6db74>&#34;&#34;&#34;This function save and close the emyDesign object which is opened.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>design<span style=color:#f92672>.</span>save()
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>design<span style=color:#f92672>.</span>close()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>create</span>(self, x_0, y_0):
</span></span><span style=display:flex><span>        <span style=color:#e6db74>r</span><span style=color:#e6db74>&#34;&#34;&#34;This function creates an inverter.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>pnt_x <span style=color:#f92672>=</span> x_0
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>pnt_y <span style=color:#f92672>=</span> y_0
</span></span><span style=display:flex><span>        <span style=color:#75715e># Create scalar instances</span>
</span></span><span style=display:flex><span>        params_p18 <span style=color:#f92672>=</span> pyAether<span style=color:#f92672>.</span>emyParamArray()
</span></span><span style=display:flex><span>        params_p18<span style=color:#f92672>.</span>append(pyAether<span style=color:#f92672>.</span>emyParam(<span style=color:#e6db74>&#39;Single_Width&#39;</span>, <span style=color:#e6db74>&#39;1u&#39;</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>create_inst(<span style=color:#e6db74>&#34;reference_pdk&#34;</span>, <span style=color:#e6db74>&#34;p18&#34;</span>, <span style=color:#e6db74>&#34;layout&#34;</span>, <span style=color:#e6db74>&#34;M0&#34;</span>, (<span style=color:#ae81ff>0.43</span>, <span style=color:#ae81ff>3.15</span>),
</span></span><span style=display:flex><span>                         params_p18)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># pyAether.emyArray()</span>
</span></span><span style=display:flex><span>        params_n18 <span style=color:#f92672>=</span> pyAether<span style=color:#f92672>.</span>emyParamArray()
</span></span><span style=display:flex><span>        params_n18<span style=color:#f92672>.</span>append(pyAether<span style=color:#f92672>.</span>emyParam(<span style=color:#e6db74>&#39;Single_Width&#39;</span>, <span style=color:#e6db74>&#39;600n&#39;</span>))
</span></span><span style=display:flex><span>        params_n18<span style=color:#f92672>.</span>append(pyAether<span style=color:#f92672>.</span>emyParam(<span style=color:#e6db74>&#39;SD_Metal_Width&#39;</span>, <span style=color:#e6db74>&#39;370n&#39;</span>))
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>create_inst(<span style=color:#e6db74>&#34;reference_pdk&#34;</span>, <span style=color:#e6db74>&#34;n18&#34;</span>, <span style=color:#e6db74>&#34;layout&#34;</span>, <span style=color:#e6db74>&#34;M1&#34;</span>, (<span style=color:#ae81ff>0.29</span>, <span style=color:#ae81ff>1.17</span>),
</span></span><span style=display:flex><span>                         params_n18)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># Create path</span>
</span></span><span style=display:flex><span>        path1 <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>create_path(<span style=color:#e6db74>&#34;GT&#34;</span>, <span style=color:#e6db74>&#34;drawing&#34;</span>, <span style=color:#ae81ff>0.18</span>, (<span style=color:#ae81ff>1.0</span>, <span style=color:#ae81ff>3.15</span>),
</span></span><span style=display:flex><span>                                 (<span style=color:#ae81ff>1.0</span>, <span style=color:#ae81ff>1.77</span>))
</span></span><span style=display:flex><span>        path2 <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>create_path(<span style=color:#e6db74>&#34;M1&#34;</span>, <span style=color:#e6db74>&#34;drawing&#34;</span>, <span style=color:#ae81ff>0.23</span>, (<span style=color:#ae81ff>1.36</span>, <span style=color:#ae81ff>3.47</span>),
</span></span><span style=display:flex><span>                                 (<span style=color:#ae81ff>1.36</span>, <span style=color:#ae81ff>1.21</span>))
</span></span><span style=display:flex><span>        path3 <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>create_path(<span style=color:#e6db74>&#34;M1&#34;</span>, <span style=color:#e6db74>&#34;drawing&#34;</span>, <span style=color:#ae81ff>0.23</span>, (<span style=color:#ae81ff>0.64</span>, <span style=color:#ae81ff>1.21</span>),
</span></span><span style=display:flex><span>                                 (<span style=color:#ae81ff>0.64</span>, <span style=color:#ae81ff>0.18</span>))
</span></span><span style=display:flex><span>        path4 <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>create_path(<span style=color:#e6db74>&#34;M1&#34;</span>, <span style=color:#e6db74>&#34;drawing&#34;</span>, <span style=color:#ae81ff>0.23</span>, (<span style=color:#ae81ff>0.64</span>, <span style=color:#ae81ff>4.11</span>),
</span></span><span style=display:flex><span>                                 (<span style=color:#ae81ff>0.64</span>, <span style=color:#ae81ff>5.14</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># Create net</span>
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>create_net(<span style=color:#e6db74>&#34;Y&#34;</span>, path1)
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>create_net(<span style=color:#e6db74>&#34;A&#34;</span>, path2)
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>create_net(<span style=color:#e6db74>&#34;vss&#34;</span>, path3)
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>create_net(<span style=color:#e6db74>&#34;vdd&#34;</span>, path4)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># create GR</span>
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>create_gr([(<span style=color:#ae81ff>0.53</span>, <span style=color:#ae81ff>4.89</span>), (<span style=color:#ae81ff>1.47</span>, <span style=color:#ae81ff>4.89</span>)], <span style=color:#e6db74>&#34;NWGR&#34;</span>, bodyWidth<span style=color:#f92672>=</span><span style=color:#ae81ff>0.4</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># create PGR</span>
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>create_gr([(<span style=color:#ae81ff>0.52</span>, <span style=color:#ae81ff>0.41</span>), (<span style=color:#ae81ff>1.48</span>, <span style=color:#ae81ff>0.41</span>)], <span style=color:#e6db74>&#34;PGR&#34;</span>, bodyWidth<span style=color:#f92672>=</span><span style=color:#ae81ff>0.4</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> __name__ <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;__main__&#39;</span>:
</span></span><span style=display:flex><span>    example <span style=color:#f92672>=</span> InvLe(<span style=color:#e6db74>&#34;lib01&#34;</span>, <span style=color:#e6db74>&#34;test&#34;</span>, <span style=color:#e6db74>&#34;reference_pdk&#34;</span>, <span style=color:#e6db74>&#34;layout&#34;</span>, mode<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;w&#34;</span>)
</span></span><span style=display:flex><span>    example<span style=color:#f92672>.</span>create(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    example<span style=color:#f92672>.</span>close()
</span></span></code></pre></div><h2 id=概伦电子>概伦电子
<a class=anchor href=#%e6%a6%82%e4%bc%a6%e7%94%b5%e5%ad%90>#</a></h2><p>收购了Entasys</p><p><img src=/image-20241223162717895.png alt=image-20241223162717895></p><h2 id=鸿芯微纳>鸿芯微纳
<a class=anchor href=#%e9%b8%bf%e8%8a%af%e5%be%ae%e7%ba%b3>#</a></h2><p><img src=/image-20250105132642028.png alt=image-20250105132642028></p><p><img src=/image-20250105132734272.png alt=image-20250105132734272></p><h2 id=华芯巨数>华芯巨数
<a class=anchor href=#%e5%8d%8e%e8%8a%af%e5%b7%a8%e6%95%b0>#</a></h2><p>浙江</p><p><img src=/image-20250105132135256.png alt=image-20250105132135256></p><p><img src=/image-20250105132149726.png alt=image-20250105132149726></p><h2 id=嘉立创>嘉立创
<a class=anchor href=#%e5%98%89%e7%ab%8b%e5%88%9b>#</a></h2><p>PCB</p><h1 id=相关竞赛>相关竞赛
<a class=anchor href=#%e7%9b%b8%e5%85%b3%e7%ab%9e%e8%b5%9b>#</a></h1><h2 id=cadathloniccad>CADathlon@ICCAD
<a class=anchor href=#cadathloniccad>#</a></h2><p><a href=https://2024.iccad.com/cadathlon-iccad-2024>CADathlon@ICCAD 2024 | ICCAD 2024</a></p><ul><li>EDA领域的**“奥林匹克运动会”<strong>，始于</strong>2002年**</li><li><strong>in-person</strong> event, <strong>all-day programming</strong> competition, <strong>9 hours</strong>, two-person teams, information about the problems and relevant research papers will be released online one week before the competition.</li><li>一般在10月份举办</li><li>six problems<ul><li>Circuit Design & Analysis</li><li><strong>Physical Design</strong> & Design for Manufacturability</li><li>Logic & High-Level Synthesis</li><li>System Design & Analysis</li><li>Functional Verification & Testing</li><li>Future technologies (Bio-EDA, Security, AI, etc.)</li></ul></li></ul><h2 id=contestispd>Contest@ISPD
<a class=anchor href=#contestispd>#</a></h2><p><a href="https://ispd.cc/ispd2025/index.php?page=contests">International Symposium on Physical Design (ISPD)</a></p><ul><li>于<strong>2005年</strong>首次举办</li><li>Contest@ISPD作为<strong>ISPD研讨会</strong>的一部分，是全球三大顶尖国<strong>际物理设计</strong>学术竞赛之一，由全球研究计算机科学的权威学会<strong>ACM</strong>（Association for Computing Machinery）所举办</li><li>每年<strong>12月份</strong>由业界一流公司（IBM、Intel、Xilinx等）公布学术竞赛题目，<strong>3月份</strong>提交研发成果和软件系统，由业界公司负责提供测试电路，并测试参赛队伍所提交的软件系统，最后于3月底或4月初<strong>在年度ACM ISPD会议上公布竞赛结果</strong>。</li></ul><table><thead><tr><th></th><th style=text-align:center>题目</th><th style=text-align:center>First Place</th></tr></thead><tbody><tr><td>2015</td><td style=text-align:center>Blockage-Aware Detailed Routing-Driven <strong>Placement</strong> Contest</td><td style=text-align:center>NTUPlacerDR</td></tr></tbody></table><h2 id=cad-contesticcad>CAD Contest@ICCAD
<a class=anchor href=#cad-contesticcad>#</a></h2><ul><li>始于 2012年</li><li>覆盖了EDA前端（front-end）和后端（back-end）</li><li>由<strong>IEEE CEDA、ACM SIGDA</strong>和工业界<strong>Cadence、Synopsys</strong>等共同赞助</li><li><strong>Each year</strong> the organizing committee announce <strong>three challenging problems</strong> in different topic, can participate in one or more problems</li></ul><p>Blockage-Aware Detailed Routing-Driven Placement Contest</p><p><img src=/image-20241214172612304.png alt=image-20241214172612304></p><h3 id=历年相关赛题>历年相关赛题
<a class=anchor href=#%e5%8e%86%e5%b9%b4%e7%9b%b8%e5%85%b3%e8%b5%9b%e9%a2%98>#</a></h3><table><thead><tr><th></th><th style=text-align:center>题目</th><th>Sponsor</th></tr></thead><tbody><tr><td>2024-C</td><td style=text-align:center>Scalable Logic <strong>Gate Sizing</strong> Using <strong>ML</strong> Techniques and <strong>GPU Acceleration</strong></td><td>Nvidia</td></tr><tr><td></td><td style=text-align:center></td><td></td></tr><tr><td></td><td style=text-align:center></td><td></td></tr><tr><td>2011</td><td style=text-align:center><strong>Routability-driven Placement</strong> Contest and Benchmark Suite</td><td></td></tr><tr><td></td><td style=text-align:center></td><td></td></tr></tbody></table><h2 id=侠客岛>侠客岛
<a class=anchor href=#%e4%be%a0%e5%ae%a2%e5%b2%9b>#</a></h2><h2 id=eda精英挑战赛>EDA精英挑战赛
<a class=anchor href=#eda%e7%b2%be%e8%8b%b1%e6%8c%91%e6%88%98%e8%b5%9b>#</a></h2><h2 id=tau-contest>TAU Contest
<a class=anchor href=#tau-contest>#</a></h2><p><a href=https://sites.google.com/view/tau-contest-2021/home>Tau 2021 Contest</a></p><ul><li>数字电路<strong>时序分析</strong>竞赛（TAU）</li><li>始于<strong>2011年</strong>，是由<strong>国际计算机协会ACM</strong>所举办的专业赛事</li><li>一般由<strong>IBM、Cadence、Synopsys、TMSC</strong>等国际顶尖公司参与命题</li><li>好像到21年就没了。。。</li></ul><h2 id=programming-contestiwls><a href=https://www.iwls.org/contest/>Programming Contest@IWLS</a>
<a class=anchor href=#programming-contestiwls>#</a></h2><p><a href=https://www.iwls.org/contest/>IWLS Contest</a></p><ul><li>始于2017年</li><li>是由IEEE/ACM International Workshop on Logic & Synthesis（IWLS）举办</li><li>由业界一流公司（Synopsys、Xilinx、Google等）公布竞赛题目</li><li>以<strong>逻辑综合（Logic Synthesis）和工具研发</strong>为竞赛主题</li></ul><h2 id=全国大学生集成电路创新创业大赛的华大九天赛道>“全国大学生集成电路创新创业大赛”的华大九天赛道
<a class=anchor href=#%e5%85%a8%e5%9b%bd%e5%a4%a7%e5%ad%a6%e7%94%9f%e9%9b%86%e6%88%90%e7%94%b5%e8%b7%af%e5%88%9b%e6%96%b0%e5%88%9b%e4%b8%9a%e5%a4%a7%e8%b5%9b%e7%9a%84%e5%8d%8e%e5%a4%a7%e4%b9%9d%e5%a4%a9%e8%b5%9b%e9%81%93>#</a></h2><p><img src=/image-20241214193431391.png alt=image-20241214193431391></p><p><a href=http://univ.ciciec.com/>全国大学生集成电路创新创业大赛</a></p><p><a href="http://univ.ciciec.com/nd.jsp?id=733#_jcp=1">第八届集创赛杯赛题目——华大九天杯 - 全国大学生集成电路创新创业大赛</a></p><p><img src=/image-20241214203159713.png alt=image-20241214203159713></p><p><img src=/image-20241214203523404.png alt=image-20241214203523404></p><h2 id=llm4hwdesign-contest>LLM4HWDesign Contest
<a class=anchor href=#llm4hwdesign-contest>#</a></h2><p>2024年ICCAD新设立<strong>LLM</strong> for <strong>Hardware</strong> Design Contest</p><p>LLM4HW Design竞赛旨在为硬件代码生成构建大规模、高质量的Verilog代码生成数据集。在基于LLM的硬件代码生成中引发一场类似ImageNet的革命。为了实现这一目标，LLM4HWDesign竞赛鼓励参与者收集数据样本，并开发创新的数据清理和标记技术，以有效提高硬件代码生成数据集的规模和质量，为推进LLM辅助硬件设计工作流程建立关键基础设施。</p><h2 id=dac-system-design-contest><a href=https://pku-sec-lab.github.io/dac-sdc-2024/><strong>DAC System Design Contest</strong> </a><a class=anchor href=#dac-system-design-contest>#</a></h2><p><strong>DAC 2012 Routability-Driven Placement Contest and Benchmark Suite</strong></p><p><img src=/image-20241220204933457.png alt=image-20241220204933457></p><h2 id=参考-2>参考
<a class=anchor href=#%e5%8f%82%e8%80%83-2>#</a></h2><ul><li><a href=https://www.163.com/dy/article/GQS44UUR0531PW97.html>盘点全球顶级EDA竞赛及中国大陆获奖情况|清华大学|福州大学|iccad|上海交通大学|eda_网易订阅</a></li></ul><h1 id=相关pdk>相关PDK
<a class=anchor href=#%e7%9b%b8%e5%85%b3pdk>#</a></h1></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/alex-shpak/hugo-book/commit/d7c6057f9423f417d2c652ed30fcb1424d3b5138 title='最后修改者 pxhg02 | 二月 20, 2025' target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt>
<span>二月 20, 2025</span></a></div><div><a class="flex align-center" href=https://github.com/alex-shpak/hugo-book/edit/main/exampleSite/content.zh/docs/Digtal/flow/EDA4PR.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt>
<span>编辑本页</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#研究背景>研究背景</a></li><li><a href=#难点>难点</a></li><li><a href=#研究方向>研究方向</a><ul><li><a href=#cross-stage-prediction>Cross-Stage Prediction</a><ul><li><a href=#routing-congestion-prediction>routing congestion prediction</a></li><li><a href=#timing-prediction>Timing Prediction</a></li></ul></li><li><a href=#optimization>Optimization</a><ul><li><a href=#timing>Timing</a></li><li><a href=#marco-placement>Marco Placement</a></li><li><a href=#placement>Placement</a></li><li><a href=#routing>Routing</a></li></ul></li><li><a href=#pr-tools>PR Tools</a><ul><li><a href=#placer>Placer</a></li><li><a href=#router>Router</a></li></ul></li></ul></li><li><a href=#综述>综述</a><ul><li><a href=#ml4pr>ML4PR</a></li><li><a href=#超大规模集成电路布线算法综述>超大规模集成电路布线算法综述</a></li><li><a href=#edagnn>EDA+GNN</a></li></ul></li><li><a href=#参考>参考</a></li><li><a href=#bak>bak</a></li><li><a href=#相关数据集>相关数据集</a><ul><li><a href=#only-rtl>only rtl</a><ul><li><a href=#home--opencores><a href=https://opencores.org/>Home :: OpenCores</a></a></li><li><a href=#iwls-2005-benchmarks><a href=https://iwls.org/iwls2005/benchmarks.html>IWLS 2005 Benchmarks</a></a></li><li><a href=#openlane-examples-examples-from-the-openlane-repository><a href=https://github.com/klasnordmark/openlane-examples>openlane-examples: Examples from the Openlane repository</a></a></li></ul></li><li><a href=#global-route>Global route</a><ul><li><a href=#ispd-2007>ISPD-2007</a></li><li><a href=#ispd-2008>ISPD-2008</a></li><li><a href=#iccad-2019>ICCAD-2019</a></li><li><a href=#ispd-2024>ISPD-2024</a></li><li><a href=#ispd-2025>ISPD-2025</a></li></ul></li><li><a href=#detail-route>Detail Route</a><ul><li><a href=#ispd-20182019>ISPD-2018/2019</a></li></ul></li><li><a href=#congestiondrcir-droptiming>congestion/DRC/IR drop/timing</a></li></ul></li><li><a href=#相关会议期刊>相关会议/期刊</a><ul><li><a href=#会议>会议</a></li><li><a href=#期刊>期刊</a></li><li><a href=#参考-1>参考</a></li></ul></li><li><a href=#相关科研实验室>相关科研实验室</a><ul><li><a href=#清华>清华</a></li><li><a href=#北大-无锡eda研究院>北大-无锡EDA研究院</a></li><li><a href=#复旦>复旦</a></li><li><a href=#北航>北航</a></li><li><a href=#港中文-eda-center>港中文-EDA Center</a></li><li><a href=#chen-tinghuan>CHEN, Tinghuan</a></li><li><a href=#福大>福大</a></li><li><a href=#上海交大>上海交大</a></li><li><a href=#东南大学-国家asic工程中心>东南大学-国家ASIC工程中心</a></li><li><a href=#华中科技大学>华中科技大学</a></li><li><a href=#西安电子科技大学>西安电子科技大学</a></li><li><a href=#广东工业大学>广东工业大学</a></li><li><a href=#国立清华大学>国立清华大学</a></li><li><a href=#university-of-california>University of California</a></li></ul></li><li><a href=#相关企业机构>相关企业/机构</a><ul><li><a href=#华为诺亚方舟--海思>华为诺亚方舟 & 海思</a></li><li><a href=#eda国创中心>EDA国创中心</a></li><li><a href=#芯行纪><a href=https://www.xtimes-da.com/>芯行纪</a></a><ul><li><a href=#amazesys>AmazeSys</a></li><li><a href=#amazefp>AmazeFP</a></li><li><a href=#amazefp-me>AmazeFP-ME</a></li><li><a href=#amazedrclite>AmazeDRCLite</a></li><li><a href=#云>云</a></li></ul></li><li><a href=#华大九天>华大九天</a><ul><li><a href=#pyaether>PyAether</a></li></ul></li><li><a href=#概伦电子>概伦电子</a></li><li><a href=#鸿芯微纳>鸿芯微纳</a></li><li><a href=#华芯巨数>华芯巨数</a></li><li><a href=#嘉立创>嘉立创</a></li></ul></li><li><a href=#相关竞赛>相关竞赛</a><ul><li><a href=#cadathloniccad>CADathlon@ICCAD</a></li><li><a href=#contestispd>Contest@ISPD</a></li><li><a href=#cad-contesticcad>CAD Contest@ICCAD</a><ul><li><a href=#历年相关赛题>历年相关赛题</a></li></ul></li><li><a href=#侠客岛>侠客岛</a></li><li><a href=#eda精英挑战赛>EDA精英挑战赛</a></li><li><a href=#tau-contest>TAU Contest</a></li><li><a href=#programming-contestiwls><a href=https://www.iwls.org/contest/>Programming Contest@IWLS</a></a></li><li><a href=#全国大学生集成电路创新创业大赛的华大九天赛道>“全国大学生集成电路创新创业大赛”的华大九天赛道</a></li><li><a href=#llm4hwdesign-contest>LLM4HWDesign Contest</a></li><li><a href=#dac-system-design-contest><a href=https://pku-sec-lab.github.io/dac-sdc-2024/><strong>DAC System Design Contest</strong></a></a></li><li><a href=#参考-2>参考</a></li></ul></li><li><a href=#相关pdk>相关PDK</a></li></ul></nav></div></aside></main></body></html>